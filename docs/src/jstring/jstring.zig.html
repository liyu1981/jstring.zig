<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>jstring.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==">
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxNTMgMTQwIj48ZyBmaWxsPSIjRjdBNDFEIj48Zz48cG9seWdvbiBwb2ludHM9IjQ2LDIyIDI4LDQ0IDE5LDMwIi8+PHBvbHlnb24gcG9pbnRzPSI0NiwyMiAzMywzMyAyOCw0NCAyMiw0NCAyMiw5NSAzMSw5NSAyMCwxMDAgMTIsMTE3IDAsMTE3IDAsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMzEsOTUgMTIsMTE3IDQsMTA2Ii8+PC9nPjxnPjxwb2x5Z29uIHBvaW50cz0iNTYsMjIgNjIsMzYgMzcsNDQiLz48cG9seWdvbiBwb2ludHM9IjU2LDIyIDExMSwyMiAxMTEsNDQgMzcsNDQgNTYsMzIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTE2LDk1IDk3LDExNyA5MCwxMDQiLz48cG9seWdvbiBwb2ludHM9IjExNiw5NSAxMDAsMTA0IDk3LDExNyA0MiwxMTcgNDIsOTUiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTUwLDAgNTIsMTE3IDMsMTQwIDEwMSwyMiIvPjwvZz48Zz48cG9seWdvbiBwb2ludHM9IjE0MSwyMiAxNDAsNDAgMTIyLDQ1Ii8+PHBvbHlnb24gcG9pbnRzPSIxNTMsMjIgMTUzLDExNyAxMDYsMTE3IDEyMCwxMDUgMTI1LDk1IDEzMSw5NSAxMzEsNDUgMTIyLDQ1IDEzMiwzNiAxNDEsMjIiIHNoYXBlLXJlbmRlcmluZz0iY3Jpc3BFZGdlcyIvPjxwb2x5Z29uIHBvaW50cz0iMTI1LDk1IDEzMCwxMTAgMTA2LDExNyIvPjwvZz48L2c+PC9zdmc+">
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-comment">/// jstring.zig</span></span>
<span class="line" id="L2"><span class="tok-comment">///</span></span>
<span class="line" id="L3"><span class="tok-comment">/// Author: Yu Li (liyu1981@gmail.com)</span></span>
<span class="line" id="L4"><span class="tok-comment">///</span></span>
<span class="line" id="L5"><span class="tok-comment">/// Target: create a reusable string lib for myself with all familiar methods methods can find in javascript string.</span></span>
<span class="line" id="L6"><span class="tok-comment">///</span></span>
<span class="line" id="L7"><span class="tok-comment">/// Reason:</span></span>
<span class="line" id="L8"><span class="tok-comment">///   1. string is important we all know, so a good string lib will be very useful.</span></span>
<span class="line" id="L9"><span class="tok-comment">///   2. javascript string is (in my opinion) the most battle tested string library out there, strike a good balance</span></span>
<span class="line" id="L10"><span class="tok-comment">///      between features and complexity.</span></span>
<span class="line" id="L11"><span class="tok-comment">///</span></span>
<span class="line" id="L12"><span class="tok-comment">/// The javascript string specs and methods this file use as reference can be found at</span></span>
<span class="line" id="L13"><span class="tok-comment">///   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String</span></span>
<span class="line" id="L14"><span class="tok-comment">///</span></span>
<span class="line" id="L15"><span class="tok-comment">/// All methods except those marked as deprecated (such as anchor, big, blink etc) are implemented, in zig way.</span></span>
<span class="line" id="L16"><span class="tok-kw">const</span> enable_arena_allocator: <span class="tok-type">bool</span> = <span class="tok-null">true</span>;</span>
<span class="line" id="L17"><span class="tok-kw">const</span> enable_pcre: <span class="tok-type">bool</span> = <span class="tok-null">true</span>;</span>
<span class="line" id="L18"></span>
<span class="line" id="L19"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L20"><span class="tok-kw">const</span> testing = std.testing;</span>
<span class="line" id="L21"></span>
<span class="line" id="L22"><span class="tok-kw">const</span> pcre = <span class="tok-kw">if</span> (enable_pcre) <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;pcre_binding.zig&quot;</span>) <span class="tok-kw">else</span> <span class="tok-null">undefined</span>;</span>
<span class="line" id="L23"></span>
<span class="line" id="L24"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> JStringError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L25">    RegexFetchBeforeMatch,</span>
<span class="line" id="L26">    RegexBadPattern,</span>
<span class="line" id="L27">    RegexMatchFailed,</span>
<span class="line" id="L28">    <span class="tok-comment">// Usually reported when use with splitByRegex/replaceByRegex, indicating that the pattern used will result in</span>
</span>
<span class="line" id="L29">    <span class="tok-comment">// overlapped matches so that we can determinstically know how to split/replace. The possible reason is the pattern</span>
</span>
<span class="line" id="L30">    <span class="tok-comment">// is using named group. Or you can debug your regex with `RegexUnmanaged.matchAll` or use https://regex101.com/</span>
</span>
<span class="line" id="L31">    RegexMatchOverlapped,</span>
<span class="line" id="L32">};</span>
<span class="line" id="L33"></span>
<span class="line" id="L34"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> ArenaAllocator = defineArenaAllocator(enable_arena_allocator);</span>
<span class="line" id="L35"></span>
<span class="line" id="L36"><span class="tok-comment">// managed versions</span>
</span>
<span class="line" id="L37"><span class="tok-comment">//   just very thin wrap around unmanaged versions, where has all real implemenats</span>
</span>
<span class="line" id="L38"></span>
<span class="line" id="L39"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Regex = defineRegex(enable_pcre);</span>
<span class="line" id="L40"></span>
<span class="line" id="L41"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> JString = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L42">    allocator: std.mem.Allocator,</span>
<span class="line" id="L43">    unmanaged: JStringUnmanaged,</span>
<span class="line" id="L44"></span>
<span class="line" id="L45">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> U8Iterator = JStringUnmanaged.U8Iterator;</span>
<span class="line" id="L46">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> U8ReverseIterator = JStringUnmanaged.U8ReverseIterator;</span>
<span class="line" id="L47"></span>
<span class="line" id="L48">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(this: *JString) <span class="tok-type">void</span> {</span>
<span class="line" id="L49">        this.unmanaged.deinit(this.allocator);</span>
<span class="line" id="L50">    }</span>
<span class="line" id="L51"></span>
<span class="line" id="L52">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">newEmpty</span>(allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L53">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L54">            .allocator = allocator,</span>
<span class="line" id="L55">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newEmpty(allocator),</span>
<span class="line" id="L56">        };</span>
<span class="line" id="L57">    }</span>
<span class="line" id="L58"></span>
<span class="line" id="L59">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromSlice</span>(allocator: std.mem.Allocator, string_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L60">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L61">            .allocator = allocator,</span>
<span class="line" id="L62">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(allocator, string_slice),</span>
<span class="line" id="L63">        };</span>
<span class="line" id="L64">    }</span>
<span class="line" id="L65"></span>
<span class="line" id="L66">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromJString</span>(that: JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L67">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L68">            .allocator = that.allocator,</span>
<span class="line" id="L69">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromJStringUnmanaged(that.allocator, that.unmanaged),</span>
<span class="line" id="L70">        };</span>
<span class="line" id="L71">    }</span>
<span class="line" id="L72"></span>
<span class="line" id="L73">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromFormat</span>(allocator: std.mem.Allocator, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L74">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L75">            .allocator = allocator,</span>
<span class="line" id="L76">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromFormat(allocator, fmt, args),</span>
<span class="line" id="L77">        };</span>
<span class="line" id="L78">    }</span>
<span class="line" id="L79"></span>
<span class="line" id="L80">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromTuple</span>(allocator: std.mem.Allocator, rest_items: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L81">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L82">            .allocator = allocator,</span>
<span class="line" id="L83">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromTuple(allocator, rest_items),</span>
<span class="line" id="L84">        };</span>
<span class="line" id="L85">    }</span>
<span class="line" id="L86"></span>
<span class="line" id="L87">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromNumber</span>(allocator: std.mem.Allocator, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L88">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L89">            .allocator = allocator,</span>
<span class="line" id="L90">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromNumber(allocator, T, value),</span>
<span class="line" id="L91">        };</span>
<span class="line" id="L92">    }</span>
<span class="line" id="L93"></span>
<span class="line" id="L94">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromStringify</span>(allocator: std.mem.Allocator, value: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L95">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L96">            .allocator = allocator,</span>
<span class="line" id="L97">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromStringify(allocator, value),</span>
<span class="line" id="L98">        };</span>
<span class="line" id="L99">    }</span>
<span class="line" id="L100"></span>
<span class="line" id="L101">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromStringifyWithOptions</span>(allocator: std.mem.Allocator, value: <span class="tok-kw">anytype</span>, options: std.json.StringifyOptions) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L102">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L103">            .allocator = allocator,</span>
<span class="line" id="L104">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromStringifyWithOptions(allocator, value, options),</span>
<span class="line" id="L105">        };</span>
<span class="line" id="L106">    }</span>
<span class="line" id="L107"></span>
<span class="line" id="L108">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromFile</span>(allocator: std.mem.Allocator, f: std.fs.File) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L109">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L110">            .allocator = allocator,</span>
<span class="line" id="L111">            .unmanaged = <span class="tok-kw">try</span> JStringUnmanaged.newFromFile(allocator, f),</span>
<span class="line" id="L112">        };</span>
<span class="line" id="L113">    }</span>
<span class="line" id="L114"></span>
<span class="line" id="L115">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">usize</span> {</span>
<span class="line" id="L116">        <span class="tok-kw">return</span> this.unmanaged.hash();</span>
<span class="line" id="L117">    }</span>
<span class="line" id="L118"></span>
<span class="line" id="L119">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L120">        this: *<span class="tok-kw">const</span> JString,</span>
<span class="line" id="L121">        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L122">        options: std.fmt.FormatOptions,</span>
<span class="line" id="L123">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L124">    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L125">        <span class="tok-kw">try</span> this.unmanaged.format(fmt, options, writer);</span>
<span class="line" id="L126">    }</span>
<span class="line" id="L127"></span>
<span class="line" id="L128">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">usize</span> {</span>
<span class="line" id="L129">        <span class="tok-kw">return</span> this.unmanaged.len();</span>
<span class="line" id="L130">    }</span>
<span class="line" id="L131"></span>
<span class="line" id="L132">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">utf8Len</span>(this: *JString) <span class="tok-type">anyerror</span>!<span class="tok-type">usize</span> {</span>
<span class="line" id="L133">        <span class="tok-kw">return</span> this.unmanaged.utf8Len();</span>
<span class="line" id="L134">    }</span>
<span class="line" id="L135"></span>
<span class="line" id="L136">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L137">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L138">            .allocator = this.allocator,</span>
<span class="line" id="L139">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.clone(this.allocator),</span>
<span class="line" id="L140">        };</span>
<span class="line" id="L141">    }</span>
<span class="line" id="L142"></span>
<span class="line" id="L143">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">bool</span> {</span>
<span class="line" id="L144">        <span class="tok-kw">return</span> this.unmanaged.isEmpty();</span>
<span class="line" id="L145">    }</span>
<span class="line" id="L146"></span>
<span class="line" id="L147">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlSlice</span>(this: *<span class="tok-kw">const</span> JString, string_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L148">        <span class="tok-kw">return</span> this.unmanaged.eqlSlice(string_slice);</span>
<span class="line" id="L149">    }</span>
<span class="line" id="L150"></span>
<span class="line" id="L151">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(this: *<span class="tok-kw">const</span> JString, that: JString) <span class="tok-type">bool</span> {</span>
<span class="line" id="L152">        <span class="tok-kw">return</span> this.eqlSlice(that.unmanaged.str_slice);</span>
<span class="line" id="L153">    }</span>
<span class="line" id="L154"></span>
<span class="line" id="L155">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">explode</span>(this: *<span class="tok-kw">const</span> JString, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JString {</span>
<span class="line" id="L156">        <span class="tok-kw">const</span> unmanaged_strings = <span class="tok-kw">try</span> this.unmanaged.explode(this.allocator, limit);</span>
<span class="line" id="L157">        <span class="tok-kw">const</span> strings = <span class="tok-kw">try</span> this.allocator.alloc(JString, unmanaged_strings.len);</span>
<span class="line" id="L158">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..unmanaged_strings.len) |i| {</span>
<span class="line" id="L159">            strings[i] = JString{</span>
<span class="line" id="L160">                .allocator = this.allocator,</span>
<span class="line" id="L161">                .unmanaged = unmanaged_strings[i],</span>
<span class="line" id="L162">            };</span>
<span class="line" id="L163">        }</span>
<span class="line" id="L164">        <span class="tok-kw">return</span> strings;</span>
<span class="line" id="L165">    }</span>
<span class="line" id="L166"></span>
<span class="line" id="L167">    <span class="tok-comment">// ** iterator</span>
</span>
<span class="line" id="L168"></span>
<span class="line" id="L169">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(this: *<span class="tok-kw">const</span> JString) U8Iterator {</span>
<span class="line" id="L170">        <span class="tok-kw">return</span> this.unmanaged.iterator();</span>
<span class="line" id="L171">    }</span>
<span class="line" id="L172"></span>
<span class="line" id="L173">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseIterator</span>(this: *<span class="tok-kw">const</span> JString) U8ReverseIterator {</span>
<span class="line" id="L174">        <span class="tok-kw">return</span> this.unmanaged.reverseIterator();</span>
<span class="line" id="L175">    }</span>
<span class="line" id="L176"></span>
<span class="line" id="L177">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">utf8Iterator</span>(this: *JString) <span class="tok-type">anyerror</span>!std.unicode.Utf8Iterator {</span>
<span class="line" id="L178">        <span class="tok-kw">return</span> this.unmanaged.utf8Iterator();</span>
<span class="line" id="L179">    }</span>
<span class="line" id="L180"></span>
<span class="line" id="L181">    <span class="tok-comment">// ** at</span>
</span>
<span class="line" id="L182"></span>
<span class="line" id="L183">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">at</span>(this: *JString, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u21</span> {</span>
<span class="line" id="L184">        <span class="tok-kw">return</span> this.unmanaged.at(index);</span>
<span class="line" id="L185">    }</span>
<span class="line" id="L186"></span>
<span class="line" id="L187">    <span class="tok-comment">// ** charAt</span>
</span>
<span class="line" id="L188"></span>
<span class="line" id="L189">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">charAt</span>(this: *<span class="tok-kw">const</span> JString, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u8</span> {</span>
<span class="line" id="L190">        <span class="tok-kw">return</span> this.unmanaged.charAt(index);</span>
<span class="line" id="L191">    }</span>
<span class="line" id="L192"></span>
<span class="line" id="L193">    <span class="tok-comment">// ** charCodeAt</span>
</span>
<span class="line" id="L194"></span>
<span class="line" id="L195">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">charCodeAt</span>(this: *<span class="tok-kw">const</span> JString, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u21</span> {</span>
<span class="line" id="L196">        _ = this;</span>
<span class="line" id="L197">        _ = index;</span>
<span class="line" id="L198">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;charCodeAt does not make sense in zig, please use at or charAt!&quot;</span>);</span>
<span class="line" id="L199">    }</span>
<span class="line" id="L200"></span>
<span class="line" id="L201">    <span class="tok-comment">// ** codePointAt</span>
</span>
<span class="line" id="L202"></span>
<span class="line" id="L203">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">codePointAt</span>(this: *<span class="tok-kw">const</span> JString, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u21</span> {</span>
<span class="line" id="L204">        _ = this;</span>
<span class="line" id="L205">        _ = index;</span>
<span class="line" id="L206">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;codePointAt does not make sense in zig, please use at or charAt!&quot;</span>);</span>
<span class="line" id="L207">    }</span>
<span class="line" id="L208"></span>
<span class="line" id="L209">    <span class="tok-comment">// ** concat</span>
</span>
<span class="line" id="L210"></span>
<span class="line" id="L211">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(this: *<span class="tok-kw">const</span> JString, other_jstring: JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L212">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L213">            .allocator = this.allocator,</span>
<span class="line" id="L214">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.concat(this.allocator, other_jstring.unmanaged),</span>
<span class="line" id="L215">        };</span>
<span class="line" id="L216">    }</span>
<span class="line" id="L217"></span>
<span class="line" id="L218">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatSlice</span>(this: *<span class="tok-kw">const</span> JString, other_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L219">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L220">            .allocator = this.allocator,</span>
<span class="line" id="L221">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.concatSlice(this.allocator, other_slice),</span>
<span class="line" id="L222">        };</span>
<span class="line" id="L223">    }</span>
<span class="line" id="L224"></span>
<span class="line" id="L225">    <span class="tok-comment">/// as we can not know len of rest_jstrings in comptime, so this method is a bit of slower than unmanaged version</span></span>
<span class="line" id="L226">    <span class="tok-comment">/// (or concatManySlices). Preciesly, slower than one allocation/deallocation of</span></span>
<span class="line" id="L227">    <span class="tok-comment">/// `[rest_jstrings.len]const []const u8` time.</span></span>
<span class="line" id="L228">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatMany</span>(this: *<span class="tok-kw">const</span> JString, rest_jstrings: []<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L229">        <span class="tok-kw">if</span> (rest_jstrings.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L230">            <span class="tok-kw">return</span> this.clone();</span>
<span class="line" id="L231">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L232">            <span class="tok-kw">const</span> rest_slices = <span class="tok-kw">try</span> this.allocator.alloc([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, rest_jstrings.len);</span>
<span class="line" id="L233">            <span class="tok-kw">defer</span> this.allocator.free(rest_slices);</span>
<span class="line" id="L234">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..rest_slices.len) |i| rest_slices[i] = rest_jstrings[i].unmanaged.str_slice;</span>
<span class="line" id="L235">            <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L236">                .allocator = this.allocator,</span>
<span class="line" id="L237">                .unmanaged = <span class="tok-kw">try</span> this.unmanaged.concatManySlices(this.allocator, rest_slices),</span>
<span class="line" id="L238">            };</span>
<span class="line" id="L239">        }</span>
<span class="line" id="L240">    }</span>
<span class="line" id="L241"></span>
<span class="line" id="L242">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatManySlices</span>(this: *<span class="tok-kw">const</span> JString, rest_slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L243">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L244">            .allocator = this.allocator,</span>
<span class="line" id="L245">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.concatManySlices(this.allocator, rest_slices),</span>
<span class="line" id="L246">        };</span>
<span class="line" id="L247">    }</span>
<span class="line" id="L248"></span>
<span class="line" id="L249">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatFormat</span>(this: *<span class="tok-kw">const</span> JString, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, rest_items: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L250">        <span class="tok-kw">const</span> ArgsType = <span class="tok-builtin">@TypeOf</span>(rest_items);</span>
<span class="line" id="L251">        <span class="tok-kw">const</span> args_type_info = <span class="tok-builtin">@typeInfo</span>(ArgsType);</span>
<span class="line" id="L252">        <span class="tok-kw">if</span> (args_type_info != .Struct) {</span>
<span class="line" id="L253">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected tuple or struct argument, found &quot;</span> ++ <span class="tok-builtin">@typeName</span>(ArgsType));</span>
<span class="line" id="L254">        }</span>
<span class="line" id="L255"></span>
<span class="line" id="L256">        <span class="tok-kw">const</span> fields_info = args_type_info.Struct.fields;</span>
<span class="line" id="L257">        <span class="tok-kw">if</span> (fields_info.len &gt; <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">u32</span>).Int.bits) {</span>
<span class="line" id="L258">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;32 arguments max are supported per format call&quot;</span>);</span>
<span class="line" id="L259">        }</span>
<span class="line" id="L260"></span>
<span class="line" id="L261">        <span class="tok-kw">if</span> (rest_items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L262">            <span class="tok-kw">return</span> this.clone();</span>
<span class="line" id="L263">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L264">            <span class="tok-kw">var</span> rest_items_unmanaged_jstring = <span class="tok-kw">try</span> JStringUnmanaged.newFromFormat(this.allocator, fmt, rest_items);</span>
<span class="line" id="L265">            <span class="tok-kw">defer</span> rest_items_unmanaged_jstring.deinit(this.allocator);</span>
<span class="line" id="L266">            <span class="tok-kw">var</span> rest_items_jstrings = [<span class="tok-number">1</span>]JString{JString{ .allocator = this.allocator, .unmanaged = rest_items_unmanaged_jstring }};</span>
<span class="line" id="L267">            <span class="tok-kw">return</span> this.concatMany(&amp;rest_items_jstrings);</span>
<span class="line" id="L268">        }</span>
<span class="line" id="L269">    }</span>
<span class="line" id="L270"></span>
<span class="line" id="L271">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatTuple</span>(this: *<span class="tok-kw">const</span> JString, rest_items: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L272">        <span class="tok-kw">const</span> ArgsType = <span class="tok-builtin">@TypeOf</span>(rest_items);</span>
<span class="line" id="L273">        <span class="tok-kw">const</span> args_type_info = <span class="tok-builtin">@typeInfo</span>(ArgsType);</span>
<span class="line" id="L274">        <span class="tok-kw">if</span> (args_type_info != .Struct) {</span>
<span class="line" id="L275">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected tuple or struct argument, found &quot;</span> ++ <span class="tok-builtin">@typeName</span>(ArgsType));</span>
<span class="line" id="L276">        }</span>
<span class="line" id="L277"></span>
<span class="line" id="L278">        <span class="tok-kw">const</span> fields_info = args_type_info.Struct.fields;</span>
<span class="line" id="L279">        <span class="tok-kw">if</span> (fields_info.len &gt; <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">u32</span>).Int.bits) {</span>
<span class="line" id="L280">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;32 arguments max are supported per format call&quot;</span>);</span>
<span class="line" id="L281">        }</span>
<span class="line" id="L282"></span>
<span class="line" id="L283">        <span class="tok-comment">// max 32 arguments, and each of them will not have long (&lt;8) specifier</span>
</span>
<span class="line" id="L284">        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fmt_buf: [<span class="tok-number">8</span> * <span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L285">        _ = &amp;fmt_buf;</span>
<span class="line" id="L286">        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fmt_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L287">        <span class="tok-kw">comptime</span> {</span>
<span class="line" id="L288">            <span class="tok-kw">var</span> fmt_print_slice: []<span class="tok-type">u8</span> = fmt_buf[<span class="tok-number">0</span>..];</span>
<span class="line" id="L289">            <span class="tok-kw">for</span> (fields_info) |field_info| {</span>
<span class="line" id="L290">                _bufPrintFmt(<span class="tok-builtin">@typeInfo</span>(field_info.<span class="tok-type">type</span>), &amp;fmt_buf, &amp;fmt_len, &amp;fmt_print_slice);</span>
<span class="line" id="L291">            }</span>
<span class="line" id="L292">        }</span>
<span class="line" id="L293"></span>
<span class="line" id="L294">        <span class="tok-kw">return</span> this.concatFormat(fmt_buf[<span class="tok-number">0</span>..fmt_len], rest_items);</span>
<span class="line" id="L295">    }</span>
<span class="line" id="L296"></span>
<span class="line" id="L297">    <span class="tok-comment">// ** endsWith</span>
</span>
<span class="line" id="L298"></span>
<span class="line" id="L299">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">endsWith</span>(this: *<span class="tok-kw">const</span> JString, suffix: JString) <span class="tok-type">bool</span> {</span>
<span class="line" id="L300">        <span class="tok-kw">return</span> this.unmanaged.endsWith(suffix.unmanaged);</span>
<span class="line" id="L301">    }</span>
<span class="line" id="L302"></span>
<span class="line" id="L303">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">endsWithSlice</span>(this: *<span class="tok-kw">const</span> JString, suffix_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L304">        <span class="tok-kw">return</span> this.unmanaged.endsWithSlice(suffix_slice);</span>
<span class="line" id="L305">    }</span>
<span class="line" id="L306"></span>
<span class="line" id="L307">    <span class="tok-comment">// ** fromCharCode</span>
</span>
<span class="line" id="L308"></span>
<span class="line" id="L309">    <span class="tok-comment">/// zig supports utf-8 natively, use newFromSlice instead.</span></span>
<span class="line" id="L310">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromCharCode</span>() JString {</span>
<span class="line" id="L311">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;zig supports utf-8 natively, use newFromSlice instead.&quot;</span>);</span>
<span class="line" id="L312">    }</span>
<span class="line" id="L313"></span>
<span class="line" id="L314">    <span class="tok-comment">// ** fromCodePoint</span>
</span>
<span class="line" id="L315"></span>
<span class="line" id="L316">    <span class="tok-comment">/// zig supports utf-8 natively, use newFromSlice instead.</span></span>
<span class="line" id="L317">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromCodePoint</span>() JString {</span>
<span class="line" id="L318">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;zig supports utf-8 natively, use newFromSlice instead.&quot;</span>);</span>
<span class="line" id="L319">    }</span>
<span class="line" id="L320"></span>
<span class="line" id="L321">    <span class="tok-comment">// ** includes</span>
</span>
<span class="line" id="L322"></span>
<span class="line" id="L323">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">includes</span>(this: *<span class="tok-kw">const</span> JString, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L324">        <span class="tok-kw">return</span> this.unmanaged.includes(needle_slice, pos);</span>
<span class="line" id="L325">    }</span>
<span class="line" id="L326"></span>
<span class="line" id="L327">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fastIncludes</span>(this: *<span class="tok-kw">const</span> JString, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L328">        <span class="tok-kw">return</span> this.unmanaged.fastIncludes(this.allocator, needle_slice, pos);</span>
<span class="line" id="L329">    }</span>
<span class="line" id="L330"></span>
<span class="line" id="L331">    <span class="tok-comment">// ** indexOf</span>
</span>
<span class="line" id="L332"></span>
<span class="line" id="L333">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(this: *<span class="tok-kw">const</span> JString, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">isize</span> {</span>
<span class="line" id="L334">        <span class="tok-kw">return</span> this.unmanaged.indexOf(needle_slice, pos);</span>
<span class="line" id="L335">    }</span>
<span class="line" id="L336"></span>
<span class="line" id="L337">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fastIndexOf</span>(this: *<span class="tok-kw">const</span> JString, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">isize</span> {</span>
<span class="line" id="L338">        <span class="tok-kw">return</span> this.unmanaged.fastIndexOf(this.allocator, needle_slice, pos);</span>
<span class="line" id="L339">    }</span>
<span class="line" id="L340"></span>
<span class="line" id="L341">    <span class="tok-comment">// ** isWellFormed</span>
</span>
<span class="line" id="L342"></span>
<span class="line" id="L343">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isWellFormed</span>(this: *JString) <span class="tok-type">bool</span> {</span>
<span class="line" id="L344">        <span class="tok-kw">return</span> this.unmanaged.isWellFormed();</span>
<span class="line" id="L345">    }</span>
<span class="line" id="L346"></span>
<span class="line" id="L347">    <span class="tok-comment">// ** lastIndexOf</span>
</span>
<span class="line" id="L348"></span>
<span class="line" id="L349">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOf</span>(this: *<span class="tok-kw">const</span> JString, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">isize</span> {</span>
<span class="line" id="L350">        <span class="tok-kw">return</span> this.unmanaged.lastIndexOf(needle_slice, pos);</span>
<span class="line" id="L351">    }</span>
<span class="line" id="L352"></span>
<span class="line" id="L353">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fastLastIndexOf</span>(this: *<span class="tok-kw">const</span> JString, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">isize</span> {</span>
<span class="line" id="L354">        <span class="tok-kw">return</span> this.unmanaged.fastLastIndexOf(this.allocator, needle_slice, pos);</span>
<span class="line" id="L355">    }</span>
<span class="line" id="L356"></span>
<span class="line" id="L357">    <span class="tok-comment">// ** localeCompare</span>
</span>
<span class="line" id="L358"></span>
<span class="line" id="L359">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">localeCompare</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">bool</span> {</span>
<span class="line" id="L360">        _ = this;</span>
<span class="line" id="L361">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Not implemented! Does localeCompare make sense in zig?&quot;</span>);</span>
<span class="line" id="L362">    }</span>
<span class="line" id="L363"></span>
<span class="line" id="L364">    <span class="tok-comment">// ** match</span>
</span>
<span class="line" id="L365"></span>
<span class="line" id="L366">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">match</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>, fetch_results: <span class="tok-type">bool</span>, regex_options: <span class="tok-type">u32</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Regex {</span>
<span class="line" id="L367">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L368">            <span class="tok-kw">return</span> Regex{</span>
<span class="line" id="L369">                .allocator = this.allocator,</span>
<span class="line" id="L370">                .unmanaged = <span class="tok-kw">try</span> this.unmanaged.match(this.allocator, pattern, offset, fetch_results, regex_options, match_options),</span>
<span class="line" id="L371">            };</span>
<span class="line" id="L372">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L373">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L374">        }</span>
<span class="line" id="L375">    }</span>
<span class="line" id="L376"></span>
<span class="line" id="L377">    <span class="tok-comment">// ** matchAll</span>
</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">matchAll</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>, regex_options: <span class="tok-type">u32</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Regex {</span>
<span class="line" id="L380">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L381">            <span class="tok-kw">return</span> Regex{</span>
<span class="line" id="L382">                .allocator = this.allocator,</span>
<span class="line" id="L383">                .unmanaged = <span class="tok-kw">try</span> this.unmanaged.matchAll(this.allocator, pattern, offset, regex_options, match_options),</span>
<span class="line" id="L384">            };</span>
<span class="line" id="L385">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L386">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L387">        }</span>
<span class="line" id="L388">    }</span>
<span class="line" id="L389"></span>
<span class="line" id="L390">    <span class="tok-comment">// ** normalize</span>
</span>
<span class="line" id="L391"></span>
<span class="line" id="L392">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(this: *<span class="tok-kw">const</span> JString) JString {</span>
<span class="line" id="L393">        _ = this;</span>
<span class="line" id="L394">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Not implemented! Does normalize make sense in zig?&quot;</span>);</span>
<span class="line" id="L395">    }</span>
<span class="line" id="L396"></span>
<span class="line" id="L397">    <span class="tok-comment">// ** padEnd</span>
</span>
<span class="line" id="L398"></span>
<span class="line" id="L399">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">padEnd</span>(this: *<span class="tok-kw">const</span> JString, wanted_len: <span class="tok-type">usize</span>, pad_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L400">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L401">            .allocator = this.allocator,</span>
<span class="line" id="L402">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.padEnd(this.allocator, wanted_len, pad_slice),</span>
<span class="line" id="L403">        };</span>
<span class="line" id="L404">    }</span>
<span class="line" id="L405"></span>
<span class="line" id="L406">    <span class="tok-comment">/// JString version of padEnd, accept pad_string (*const JStringUnmanaged) instead of slice.</span></span>
<span class="line" id="L407">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">padEndJString</span>(this: *<span class="tok-kw">const</span> JString, wanted_len: <span class="tok-type">usize</span>, pad_string: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L408">        <span class="tok-kw">return</span> this.padEnd(wanted_len, pad_string.unmanaged.str_slice);</span>
<span class="line" id="L409">    }</span>
<span class="line" id="L410"></span>
<span class="line" id="L411">    <span class="tok-comment">// ** padStart</span>
</span>
<span class="line" id="L412"></span>
<span class="line" id="L413">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">padStart</span>(this: *<span class="tok-kw">const</span> JString, wanted_len: <span class="tok-type">usize</span>, pad_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L414">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L415">            .allocator = this.allocator,</span>
<span class="line" id="L416">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.padStart(this.allocator, wanted_len, pad_slice),</span>
<span class="line" id="L417">        };</span>
<span class="line" id="L418">    }</span>
<span class="line" id="L419"></span>
<span class="line" id="L420">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">padStartJString</span>(this: *<span class="tok-kw">const</span> JString, wanted_len: <span class="tok-type">usize</span>, pad_string: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L421">        <span class="tok-kw">return</span> this.padStart(wanted_len, pad_string.unmanaged.str_slice);</span>
<span class="line" id="L422">    }</span>
<span class="line" id="L423"></span>
<span class="line" id="L424">    <span class="tok-comment">// ** raw</span>
</span>
<span class="line" id="L425"></span>
<span class="line" id="L426">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">raw</span>() JString {</span>
<span class="line" id="L427">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;zig has no template literals like javascript, use newFromSlice/newFromFormat/newFromTuple instead.&quot;</span>);</span>
<span class="line" id="L428">    }</span>
<span class="line" id="L429"></span>
<span class="line" id="L430">    <span class="tok-comment">// ** repeat</span>
</span>
<span class="line" id="L431"></span>
<span class="line" id="L432">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">repeat</span>(this: *<span class="tok-kw">const</span> JString, count: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L433">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L434">            .allocator = this.allocator,</span>
<span class="line" id="L435">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.repeat(this.allocator, count),</span>
<span class="line" id="L436">        };</span>
<span class="line" id="L437">    }</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">    <span class="tok-comment">// ** replace</span>
</span>
<span class="line" id="L440"></span>
<span class="line" id="L441">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">replace</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L442">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L443">            .allocator = this.allocator,</span>
<span class="line" id="L444">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.replace(this.allocator, pattern, replacement_slice),</span>
<span class="line" id="L445">        };</span>
<span class="line" id="L446">    }</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceByRegex</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L449">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L450">            .allocator = this.allocator,</span>
<span class="line" id="L451">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.replaceByRegex(this.allocator, pattern, replacement_slice),</span>
<span class="line" id="L452">        };</span>
<span class="line" id="L453">    }</span>
<span class="line" id="L454"></span>
<span class="line" id="L455">    <span class="tok-comment">// ** replaceAll</span>
</span>
<span class="line" id="L456"></span>
<span class="line" id="L457">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceAll</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L458">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L459">            .allocator = this.allocator,</span>
<span class="line" id="L460">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.replaceAll(this.allocator, pattern, replacement_slice),</span>
<span class="line" id="L461">        };</span>
<span class="line" id="L462">    }</span>
<span class="line" id="L463"></span>
<span class="line" id="L464">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceAllByRegex</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L465">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L466">            .allocator = this.allocator,</span>
<span class="line" id="L467">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.replaceAllByRegex(this.allocator, pattern, replacement_slice),</span>
<span class="line" id="L468">        };</span>
<span class="line" id="L469">    }</span>
<span class="line" id="L470"></span>
<span class="line" id="L471">    <span class="tok-comment">// ** search</span>
</span>
<span class="line" id="L472"></span>
<span class="line" id="L473">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">search</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>) <span class="tok-type">isize</span> {</span>
<span class="line" id="L474">        <span class="tok-kw">return</span> this.unmanaged.search(pattern, offset);</span>
<span class="line" id="L475">    }</span>
<span class="line" id="L476"></span>
<span class="line" id="L477">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">searchByRegex</span>(this: *<span class="tok-kw">const</span> JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">isize</span> {</span>
<span class="line" id="L478">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L479">            <span class="tok-kw">return</span> this.unmanaged.searchByRegex(this.allocator, pattern, offset);</span>
<span class="line" id="L480">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L481">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L482">        }</span>
<span class="line" id="L483">    }</span>
<span class="line" id="L484"></span>
<span class="line" id="L485">    <span class="tok-comment">// ** slice</span>
</span>
<span class="line" id="L486"></span>
<span class="line" id="L487">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(this: *<span class="tok-kw">const</span> JString, index_start: <span class="tok-type">isize</span>, index_end: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L488">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L489">            .allocator = this.allocator,</span>
<span class="line" id="L490">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.slice(this.allocator, index_start, index_end),</span>
<span class="line" id="L491">        };</span>
<span class="line" id="L492">    }</span>
<span class="line" id="L493"></span>
<span class="line" id="L494">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceWithStartOnly</span>(this: *<span class="tok-kw">const</span> JString, index_start: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L495">        <span class="tok-kw">return</span> this.slice(index_start, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(this.len())));</span>
<span class="line" id="L496">    }</span>
<span class="line" id="L497"></span>
<span class="line" id="L498">    <span class="tok-comment">// ** split</span>
</span>
<span class="line" id="L499"></span>
<span class="line" id="L500">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">split</span>(this: *JString, seperator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JString {</span>
<span class="line" id="L501">        <span class="tok-kw">const</span> unmanaged_strings = <span class="tok-kw">try</span> this.unmanaged.split(this.allocator, seperator, limit);</span>
<span class="line" id="L502">        <span class="tok-kw">const</span> strings = <span class="tok-kw">try</span> this.allocator.alloc(JString, unmanaged_strings.len);</span>
<span class="line" id="L503">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..unmanaged_strings.len) |i| strings[i] = JString{</span>
<span class="line" id="L504">            .allocator = this.allocator,</span>
<span class="line" id="L505">            .unmanaged = unmanaged_strings[i],</span>
<span class="line" id="L506">        };</span>
<span class="line" id="L507">        <span class="tok-kw">return</span> strings;</span>
<span class="line" id="L508">    }</span>
<span class="line" id="L509"></span>
<span class="line" id="L510">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitByWhiteSpace</span>(this: *JString, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JString {</span>
<span class="line" id="L511">        <span class="tok-kw">return</span> this.explode(limit);</span>
<span class="line" id="L512">    }</span>
<span class="line" id="L513"></span>
<span class="line" id="L514">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitByRegex</span>(this: *JString, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JString {</span>
<span class="line" id="L515">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L516">            <span class="tok-kw">const</span> unmanaged_strings = <span class="tok-kw">try</span> this.unmanaged.splitByRegex(this.allocator, pattern, offset, limit);</span>
<span class="line" id="L517">            <span class="tok-kw">const</span> strings = <span class="tok-kw">try</span> this.allocator.alloc(JString, unmanaged_strings.len);</span>
<span class="line" id="L518">            <span class="tok-kw">for</span> (<span class="tok-number">0</span>..unmanaged_strings.len) |i| strings[i] = JString{</span>
<span class="line" id="L519">                .allocator = this.allocator,</span>
<span class="line" id="L520">                .unmanaged = unmanaged_strings[i],</span>
<span class="line" id="L521">            };</span>
<span class="line" id="L522">            <span class="tok-kw">return</span> strings;</span>
<span class="line" id="L523">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L524">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L525">        }</span>
<span class="line" id="L526">    }</span>
<span class="line" id="L527"></span>
<span class="line" id="L528">    <span class="tok-comment">// ** startsWith</span>
</span>
<span class="line" id="L529"></span>
<span class="line" id="L530">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">startsWith</span>(this: *<span class="tok-kw">const</span> JString, prefix: JString) <span class="tok-type">bool</span> {</span>
<span class="line" id="L531">        <span class="tok-kw">return</span> this.startsWithSlice(prefix.unmanaged.str_slice);</span>
<span class="line" id="L532">    }</span>
<span class="line" id="L533"></span>
<span class="line" id="L534">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startsWithSlice</span>(this: *<span class="tok-kw">const</span> JString, prefix_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L535">        <span class="tok-kw">return</span> this.unmanaged.startsWithSlice(prefix_slice);</span>
<span class="line" id="L536">    }</span>
<span class="line" id="L537"></span>
<span class="line" id="L538">    <span class="tok-comment">// ** toLocaleLowerCase</span>
</span>
<span class="line" id="L539"></span>
<span class="line" id="L540">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLocaleLowerCase</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L541">        _ = this;</span>
<span class="line" id="L542">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO, not yet implemented!&quot;</span>);</span>
<span class="line" id="L543">    }</span>
<span class="line" id="L544"></span>
<span class="line" id="L545">    <span class="tok-comment">// ** toLocaleUpperCase</span>
</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLocalUpperCase</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L548">        _ = this;</span>
<span class="line" id="L549">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO, not yet implemented!&quot;</span>);</span>
<span class="line" id="L550">    }</span>
<span class="line" id="L551"></span>
<span class="line" id="L552">    <span class="tok-comment">// ** toLowerCase</span>
</span>
<span class="line" id="L553"></span>
<span class="line" id="L554">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLowerCase</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L555">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L556">            .allocator = this.allocator,</span>
<span class="line" id="L557">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.toLowerCase(this.allocator),</span>
<span class="line" id="L558">        };</span>
<span class="line" id="L559">    }</span>
<span class="line" id="L560"></span>
<span class="line" id="L561">    <span class="tok-comment">// ** toUpperCase</span>
</span>
<span class="line" id="L562"></span>
<span class="line" id="L563">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toUpperCase</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L564">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L565">            .allocator = this.allocator,</span>
<span class="line" id="L566">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.toUpperCase(this.allocator),</span>
<span class="line" id="L567">        };</span>
<span class="line" id="L568">    }</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">    <span class="tok-comment">// ** toWellFormed</span>
</span>
<span class="line" id="L571"></span>
<span class="line" id="L572">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toWellFormed</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">void</span> {</span>
<span class="line" id="L573">        _ = this;</span>
<span class="line" id="L574">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;toWellFormed does not make sense in zig as zig is u8/utf8 based. No need to use this.&quot;</span>);</span>
<span class="line" id="L575">    }</span>
<span class="line" id="L576"></span>
<span class="line" id="L577">    <span class="tok-comment">// ** trim</span>
</span>
<span class="line" id="L578"></span>
<span class="line" id="L579">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trim</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L580">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L581">            .allocator = this.allocator,</span>
<span class="line" id="L582">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.trim(this.allocator),</span>
<span class="line" id="L583">        };</span>
<span class="line" id="L584">    }</span>
<span class="line" id="L585"></span>
<span class="line" id="L586">    <span class="tok-comment">// ** trimEnd</span>
</span>
<span class="line" id="L587"></span>
<span class="line" id="L588">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimEnd</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L589">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L590">            .allocator = this.allocator,</span>
<span class="line" id="L591">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.trimEnd(this.allocator),</span>
<span class="line" id="L592">        };</span>
<span class="line" id="L593">    }</span>
<span class="line" id="L594"></span>
<span class="line" id="L595">    <span class="tok-comment">// ** trimStart</span>
</span>
<span class="line" id="L596"></span>
<span class="line" id="L597">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimStart</span>(this: *<span class="tok-kw">const</span> JString) <span class="tok-type">anyerror</span>!JString {</span>
<span class="line" id="L598">        <span class="tok-kw">return</span> JString{</span>
<span class="line" id="L599">            .allocator = this.allocator,</span>
<span class="line" id="L600">            .unmanaged = <span class="tok-kw">try</span> this.unmanaged.trimStart(this.allocator),</span>
<span class="line" id="L601">        };</span>
<span class="line" id="L602">    }</span>
<span class="line" id="L603"></span>
<span class="line" id="L604">    <span class="tok-comment">// ** valueOf</span>
</span>
<span class="line" id="L605"></span>
<span class="line" id="L606">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueOf</span>(this: *<span class="tok-kw">const</span> JString) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L607">        <span class="tok-kw">return</span> this.unmanaged.str_slice;</span>
<span class="line" id="L608">    }</span>
<span class="line" id="L609">};</span>
<span class="line" id="L610"></span>
<span class="line" id="L611"><span class="tok-comment">// unmanaged versions: the real deal</span>
</span>
<span class="line" id="L612"></span>
<span class="line" id="L613"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> RegexUnmanaged = defineRegexUnmanaged(enable_pcre);</span>
<span class="line" id="L614"></span>
<span class="line" id="L615"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> JStringUnmanaged = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L616">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> U8Iterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L617">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L618"></span>
<span class="line" id="L619">        jstring_: *<span class="tok-kw">const</span> JStringUnmanaged = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L620">        pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L621"></span>
<span class="line" id="L622">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(this: *Self) ?<span class="tok-type">u8</span> {</span>
<span class="line" id="L623">            <span class="tok-kw">if</span> (this.pos &gt;= this.jstring_.*.len()) {</span>
<span class="line" id="L624">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L625">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L626">                <span class="tok-kw">const</span> c = this.jstring_.*.charAt(<span class="tok-builtin">@as</span>(<span class="tok-type">i32</span>, <span class="tok-builtin">@intCast</span>(this.pos))) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L627">                this.pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L628">                <span class="tok-kw">return</span> c;</span>
<span class="line" id="L629">            }</span>
<span class="line" id="L630">        }</span>
<span class="line" id="L631">    };</span>
<span class="line" id="L632"></span>
<span class="line" id="L633">    <span class="tok-kw">pub</span> <span class="tok-kw">const</span> U8ReverseIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L634">        <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L635"></span>
<span class="line" id="L636">        jstring_: *<span class="tok-kw">const</span> JStringUnmanaged = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L637">        pos: <span class="tok-type">isize</span> = -<span class="tok-number">1</span>,</span>
<span class="line" id="L638"></span>
<span class="line" id="L639">        <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">next</span>(this: *Self) ?<span class="tok-type">u8</span> {</span>
<span class="line" id="L640">            <span class="tok-kw">if</span> (this.pos &lt; -<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(this.jstring_.*.len()))) {</span>
<span class="line" id="L641">                <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L642">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L643">                <span class="tok-kw">const</span> c = this.jstring_.*.charAt(this.pos) <span class="tok-kw">catch</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L644">                this.pos -= <span class="tok-number">1</span>;</span>
<span class="line" id="L645">                <span class="tok-kw">return</span> c;</span>
<span class="line" id="L646">            }</span>
<span class="line" id="L647">        }</span>
<span class="line" id="L648">    };</span>
<span class="line" id="L649"></span>
<span class="line" id="L650">    str_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L651">    utf8_view_inited: <span class="tok-type">bool</span> = <span class="tok-null">false</span>,</span>
<span class="line" id="L652">    utf8_view: std.unicode.Utf8View = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L653">    utf8_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L654"></span>
<span class="line" id="L655">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L656">        allocator.free(this.str_slice);</span>
<span class="line" id="L657">    }</span>
<span class="line" id="L658"></span>
<span class="line" id="L659">    <span class="tok-comment">// constructors</span>
</span>
<span class="line" id="L660"></span>
<span class="line" id="L661">    <span class="tok-comment">/// As the name assumes, it returns an empty string.</span></span>
<span class="line" id="L662">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newEmpty</span>(allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L663">        <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L664">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L665">            .str_slice = new_slice,</span>
<span class="line" id="L666">        };</span>
<span class="line" id="L667">    }</span>
<span class="line" id="L668"></span>
<span class="line" id="L669">    <span class="tok-comment">/// Returns a string copied the content of slice. i.e.,</span></span>
<span class="line" id="L670">    <span class="tok-comment">/// `const s = try JStringUnmanaged.newFromSlice(allocator, &quot;hello,world&quot;);`</span></span>
<span class="line" id="L671">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromSlice</span>(allocator: std.mem.Allocator, string_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L672">        <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, string_slice.len);</span>
<span class="line" id="L673">        <span class="tok-builtin">@memcpy</span>(new_slice, string_slice);</span>
<span class="line" id="L674">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L675">            .str_slice = new_slice,</span>
<span class="line" id="L676">        };</span>
<span class="line" id="L677">    }</span>
<span class="line" id="L678"></span>
<span class="line" id="L679">    <span class="tok-comment">/// Returns a string copied the content of the other JStringUnmanaged</span></span>
<span class="line" id="L680">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromJStringUnmanaged</span>(allocator: std.mem.Allocator, that: JStringUnmanaged) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L681">        <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, that.len());</span>
<span class="line" id="L682">        <span class="tok-builtin">@memcpy</span>(new_slice, that.str_slice);</span>
<span class="line" id="L683">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L684">            .str_slice = new_slice,</span>
<span class="line" id="L685">        };</span>
<span class="line" id="L686">    }</span>
<span class="line" id="L687"></span>
<span class="line" id="L688">    <span class="tok-comment">/// Returns a string from the result of formatting, i.e., sprintf.</span></span>
<span class="line" id="L689">    <span class="tok-comment">/// Example: `var s = JStringUnmanaged.newFromFormat(allocator, &quot;{s}{d}&quot;, .{ &quot;hello&quot;, 5 })`</span></span>
<span class="line" id="L690">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromFormat</span>(allocator: std.mem.Allocator, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, args: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L691">        <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> std.fmt.allocPrint(allocator, fmt, args);</span>
<span class="line" id="L692">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L693">            .str_slice = new_slice,</span>
<span class="line" id="L694">        };</span>
<span class="line" id="L695">    }</span>
<span class="line" id="L696"></span>
<span class="line" id="L697">    <span class="tok-comment">/// Returns a string from auto formatting a tuple of items. Essentially what it does is to guess the fmt</span></span>
<span class="line" id="L698">    <span class="tok-comment">/// automatically. The max items of the tuple is 32.</span></span>
<span class="line" id="L699">    <span class="tok-comment">/// Example: `var s = JStringUnmanaged.newFromFormat(allocator, .{ &quot;hello&quot;, 5 })`</span></span>
<span class="line" id="L700">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromTuple</span>(allocator: std.mem.Allocator, rest_items: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L701">        <span class="tok-kw">const</span> ArgsType = <span class="tok-builtin">@TypeOf</span>(rest_items);</span>
<span class="line" id="L702">        <span class="tok-kw">const</span> args_type_info = <span class="tok-builtin">@typeInfo</span>(ArgsType);</span>
<span class="line" id="L703">        <span class="tok-kw">if</span> (args_type_info != .Struct) {</span>
<span class="line" id="L704">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected tuple or struct argument, found &quot;</span> ++ <span class="tok-builtin">@typeName</span>(ArgsType));</span>
<span class="line" id="L705">        }</span>
<span class="line" id="L706"></span>
<span class="line" id="L707">        <span class="tok-kw">const</span> fields_info = args_type_info.Struct.fields;</span>
<span class="line" id="L708">        <span class="tok-kw">if</span> (fields_info.len &gt; <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">u32</span>).Int.bits) {</span>
<span class="line" id="L709">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;32 arguments max are supported per format call&quot;</span>);</span>
<span class="line" id="L710">        }</span>
<span class="line" id="L711"></span>
<span class="line" id="L712">        <span class="tok-comment">// max 32 arguments, and each of them will not have long (&lt;8) specifier</span>
</span>
<span class="line" id="L713">        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fmt_buf: [<span class="tok-number">8</span> * <span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L714">        _ = &amp;fmt_buf;</span>
<span class="line" id="L715">        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fmt_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L716">        <span class="tok-kw">comptime</span> {</span>
<span class="line" id="L717">            <span class="tok-kw">var</span> fmt_print_slice: []<span class="tok-type">u8</span> = fmt_buf[<span class="tok-number">0</span>..];</span>
<span class="line" id="L718">            <span class="tok-kw">for</span> (fields_info) |field_info| {</span>
<span class="line" id="L719">                _bufPrintFmt(<span class="tok-builtin">@typeInfo</span>(field_info.<span class="tok-type">type</span>), &amp;fmt_buf, &amp;fmt_len, &amp;fmt_print_slice);</span>
<span class="line" id="L720">            }</span>
<span class="line" id="L721">        }</span>
<span class="line" id="L722">        <span class="tok-kw">return</span> JStringUnmanaged.newFromFormat(allocator, fmt_buf[<span class="tok-number">0</span>..fmt_len], rest_items);</span>
<span class="line" id="L723">    }</span>
<span class="line" id="L724"></span>
<span class="line" id="L725">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromNumber</span>(allocator: std.mem.Allocator, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L726">        <span class="tok-kw">switch</span> (<span class="tok-builtin">@typeInfo</span>(T)) {</span>
<span class="line" id="L727">            .Int =&gt; {},</span>
<span class="line" id="L728">            .Float =&gt; {},</span>
<span class="line" id="L729">            <span class="tok-kw">else</span> =&gt; <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;parseInt can only work on number like types: integer or float (i32/u32/f32...).&quot;</span>),</span>
<span class="line" id="L730">        }</span>
<span class="line" id="L731">        <span class="tok-kw">return</span> JStringUnmanaged.newFromFormat(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{value});</span>
<span class="line" id="L732">    }</span>
<span class="line" id="L733"></span>
<span class="line" id="L734">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromStringify</span>(allocator: std.mem.Allocator, value: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L735">        <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> std.json.stringifyAlloc(allocator, value, .{});</span>
<span class="line" id="L736">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L737">            .str_slice = new_slice,</span>
<span class="line" id="L738">        };</span>
<span class="line" id="L739">    }</span>
<span class="line" id="L740"></span>
<span class="line" id="L741">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromStringifyWithOptions</span>(allocator: std.mem.Allocator, value: <span class="tok-kw">anytype</span>, options: std.json.StringifyOptions) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L742">        <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> std.json.stringifyAlloc(allocator, value, options);</span>
<span class="line" id="L743">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L744">            .str_slice = new_slice,</span>
<span class="line" id="L745">        };</span>
<span class="line" id="L746">    }</span>
<span class="line" id="L747"></span>
<span class="line" id="L748">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">newFromFile</span>(allocator: std.mem.Allocator, f: std.fs.File) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L749">        <span class="tok-kw">const</span> stat = <span class="tok-kw">try</span> f.stat();</span>
<span class="line" id="L750">        <span class="tok-kw">var</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, stat.size);</span>
<span class="line" id="L751">        <span class="tok-kw">const</span> read_size = <span class="tok-kw">try</span> f.readAll(new_slice);</span>
<span class="line" id="L752">        <span class="tok-kw">if</span> (read_size == stat.size) {</span>
<span class="line" id="L753">            <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L754">                .str_slice = new_slice,</span>
<span class="line" id="L755">            };</span>
<span class="line" id="L756">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L757">            <span class="tok-kw">return</span> JStringUnmanaged.newFromSlice(allocator, new_slice[<span class="tok-number">0</span>..read_size]);</span>
<span class="line" id="L758">        }</span>
<span class="line" id="L759">    }</span>
<span class="line" id="L760"></span>
<span class="line" id="L761">    <span class="tok-comment">// utils</span>
</span>
<span class="line" id="L762"></span>
<span class="line" id="L763">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">hash</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">usize</span> {</span>
<span class="line" id="L764">        <span class="tok-kw">var</span> wyhash = std.hash.Wyhash.init(<span class="tok-number">0</span>);</span>
<span class="line" id="L765">        wyhash.update(this.str_slice);</span>
<span class="line" id="L766">        <span class="tok-kw">return</span> wyhash.final();</span>
<span class="line" id="L767">    }</span>
<span class="line" id="L768"></span>
<span class="line" id="L769">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">format</span>(</span>
<span class="line" id="L770">        this: *<span class="tok-kw">const</span> JStringUnmanaged,</span>
<span class="line" id="L771">        <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L772">        options: std.fmt.FormatOptions,</span>
<span class="line" id="L773">        writer: <span class="tok-kw">anytype</span>,</span>
<span class="line" id="L774">    ) <span class="tok-builtin">@TypeOf</span>(writer).Error!<span class="tok-type">void</span> {</span>
<span class="line" id="L775">        _ = options;</span>
<span class="line" id="L776">        _ = fmt;</span>
<span class="line" id="L777">        <span class="tok-kw">try</span> writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{this.str_slice});</span>
<span class="line" id="L778">    }</span>
<span class="line" id="L779"></span>
<span class="line" id="L780">    <span class="tok-comment">/// Simple util to return the underlying slice's len (= this.str_slice.len). Less typing, less errors.</span></span>
<span class="line" id="L781">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">len</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">usize</span> {</span>
<span class="line" id="L782">        <span class="tok-kw">return</span> this.str_slice.len;</span>
<span class="line" id="L783">    }</span>
<span class="line" id="L784"></span>
<span class="line" id="L785">    <span class="tok-comment">/// First time call utf8Len will init the utf8_view and calculate len once. After that we will just use the cached</span></span>
<span class="line" id="L786">    <span class="tok-comment">/// view and len.</span></span>
<span class="line" id="L787">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">utf8Len</span>(this: *JStringUnmanaged) <span class="tok-type">anyerror</span>!<span class="tok-type">usize</span> {</span>
<span class="line" id="L788">        <span class="tok-kw">if</span> (!this.utf8_view_inited) {</span>
<span class="line" id="L789">            this.utf8_view = <span class="tok-kw">try</span> std.unicode.Utf8View.init(this.str_slice);</span>
<span class="line" id="L790">            this.utf8_view_inited = <span class="tok-null">true</span>;</span>
<span class="line" id="L791">            this.utf8_len = brk: {</span>
<span class="line" id="L792">                <span class="tok-kw">var</span> utf8_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L793">                <span class="tok-kw">var</span> it = this.utf8_view.iterator();</span>
<span class="line" id="L794">                <span class="tok-kw">while</span> (it.nextCodepoint()) |_| {</span>
<span class="line" id="L795">                    utf8_len += <span class="tok-number">1</span>;</span>
<span class="line" id="L796">                }</span>
<span class="line" id="L797">                <span class="tok-kw">break</span> :brk utf8_len;</span>
<span class="line" id="L798">            };</span>
<span class="line" id="L799">        }</span>
<span class="line" id="L800">        <span class="tok-kw">return</span> this.utf8_len;</span>
<span class="line" id="L801">    }</span>
<span class="line" id="L802"></span>
<span class="line" id="L803">    <span class="tok-comment">/// As the name assumes. Equals to `JStringUnmanaged.newFromJStringUnmanaged(allocator, this)`</span></span>
<span class="line" id="L804">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">clone</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L805">        <span class="tok-kw">return</span> JStringUnmanaged.newFromJStringUnmanaged(allocator, this.*);</span>
<span class="line" id="L806">    }</span>
<span class="line" id="L807"></span>
<span class="line" id="L808">    <span class="tok-kw">fn</span> <span class="tok-fn">_cloneAsArray</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>![]JStringUnmanaged {</span>
<span class="line" id="L809">        <span class="tok-kw">var</span> result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, <span class="tok-number">1</span>);</span>
<span class="line" id="L810">        result_jstrings[<span class="tok-number">0</span>] = <span class="tok-kw">try</span> this.clone(allocator);</span>
<span class="line" id="L811">        <span class="tok-kw">return</span> result_jstrings;</span>
<span class="line" id="L812">    }</span>
<span class="line" id="L813"></span>
<span class="line" id="L814">    <span class="tok-comment">/// Equals to `this.len() == 0` or `this.str_slice.len == 0`</span></span>
<span class="line" id="L815">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">isEmpty</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">bool</span> {</span>
<span class="line" id="L816">        <span class="tok-kw">return</span> this.len() == <span class="tok-number">0</span>;</span>
<span class="line" id="L817">    }</span>
<span class="line" id="L818"></span>
<span class="line" id="L819">    <span class="tok-comment">/// As simple as compare the underlying str_slice to string_slice</span></span>
<span class="line" id="L820">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">eqlSlice</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, string_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L821">        <span class="tok-kw">return</span> std.mem.eql(<span class="tok-type">u8</span>, this.str_slice, string_slice);</span>
<span class="line" id="L822">    }</span>
<span class="line" id="L823"></span>
<span class="line" id="L824">    <span class="tok-comment">/// Equals to `this.eqlSlice(that.str_slice)`</span></span>
<span class="line" id="L825">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">eql</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, that: JStringUnmanaged) <span class="tok-type">bool</span> {</span>
<span class="line" id="L826">        <span class="tok-kw">return</span> this.eqlSlice(that.str_slice);</span>
<span class="line" id="L827">    }</span>
<span class="line" id="L828"></span>
<span class="line" id="L829">    <span class="tok-comment">/// explode this string to small strings sperated by ascii spaces while respects utf8 chars. Limit can be -1 or</span></span>
<span class="line" id="L830">    <span class="tok-comment">/// positive numbers. When limit is negative means auto calculate how many strings can return; otherwise will return</span></span>
<span class="line" id="L831">    <span class="tok-comment">/// min(limit, possible max number of strings)</span></span>
<span class="line" id="L832">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">explode</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JStringUnmanaged {</span>
<span class="line" id="L833">        <span class="tok-kw">const</span> real_limit = brk: {</span>
<span class="line" id="L834">            <span class="tok-kw">if</span> (limit &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L835">                <span class="tok-kw">break</span> :brk this.str_slice.len;</span>
<span class="line" id="L836">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L837">                <span class="tok-kw">break</span> :brk <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(limit));</span>
<span class="line" id="L838">            }</span>
<span class="line" id="L839">        };</span>
<span class="line" id="L840">        <span class="tok-kw">return</span> this._explode(allocator, real_limit);</span>
<span class="line" id="L841">    }</span>
<span class="line" id="L842"></span>
<span class="line" id="L843">    <span class="tok-kw">fn</span> <span class="tok-fn">_explode</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, limit: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>![]JStringUnmanaged {</span>
<span class="line" id="L844">        <span class="tok-kw">var</span> result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, limit);</span>
<span class="line" id="L845">        <span class="tok-kw">var</span> result_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L846">        <span class="tok-kw">var</span> pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L847">        <span class="tok-kw">var</span> next_pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L848"></span>
<span class="line" id="L849">        <span class="tok-kw">while</span> (pos &lt; this.str_slice.len) {</span>
<span class="line" id="L850">            <span class="tok-kw">switch</span> (this.str_slice[pos]) {</span>
<span class="line" id="L851">                <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\n'</span>, <span class="tok-str">'\r'</span> =&gt; {</span>
<span class="line" id="L852">                    pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L853">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L854">                },</span>
<span class="line" id="L855">                <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L856">                    next_pos = pos + <span class="tok-number">1</span>;</span>
<span class="line" id="L857">                    next_pos = brk: {</span>
<span class="line" id="L858">                        <span class="tok-kw">while</span> (next_pos &lt; this.str_slice.len) : (next_pos += <span class="tok-number">1</span>) {</span>
<span class="line" id="L859">                            <span class="tok-kw">switch</span> (this.str_slice[next_pos]) {</span>
<span class="line" id="L860">                                <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\n'</span>, <span class="tok-str">'\r'</span> =&gt; <span class="tok-kw">break</span> :brk next_pos,</span>
<span class="line" id="L861">                                <span class="tok-kw">else</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L862">                            }</span>
<span class="line" id="L863">                        }</span>
<span class="line" id="L864">                        <span class="tok-kw">break</span> :brk next_pos;</span>
<span class="line" id="L865">                    };</span>
<span class="line" id="L866">                    result_jstrings[result_count] = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(allocator, this.str_slice[pos..next_pos]);</span>
<span class="line" id="L867">                    result_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L868">                    <span class="tok-kw">if</span> (result_count &gt;= limit) {</span>
<span class="line" id="L869">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L870">                    }</span>
<span class="line" id="L871">                    pos = next_pos;</span>
<span class="line" id="L872">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L873">                },</span>
<span class="line" id="L874">            }</span>
<span class="line" id="L875">        }</span>
<span class="line" id="L876"></span>
<span class="line" id="L877">        <span class="tok-kw">if</span> (result_count == limit) {</span>
<span class="line" id="L878">            <span class="tok-kw">return</span> result_jstrings;</span>
<span class="line" id="L879">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L880">            <span class="tok-kw">defer</span> allocator.free(result_jstrings);</span>
<span class="line" id="L881">            <span class="tok-kw">var</span> final_result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, result_count);</span>
<span class="line" id="L882">            _ = &amp;final_result_jstrings;</span>
<span class="line" id="L883">            <span class="tok-kw">if</span> (result_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L884">                <span class="tok-builtin">@memcpy</span>(final_result_jstrings, result_jstrings[<span class="tok-number">0</span>..result_count]);</span>
<span class="line" id="L885">            }</span>
<span class="line" id="L886">            <span class="tok-kw">return</span> final_result_jstrings;</span>
<span class="line" id="L887">        }</span>
<span class="line" id="L888">    }</span>
<span class="line" id="L889"></span>
<span class="line" id="L890">    <span class="tok-comment">// ** iterator</span>
</span>
<span class="line" id="L891"></span>
<span class="line" id="L892">    <span class="tok-comment">/// return an iterator can iterate char(u8) by char, from the beginning.</span></span>
<span class="line" id="L893">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">iterator</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) U8Iterator {</span>
<span class="line" id="L894">        <span class="tok-kw">return</span> U8Iterator{</span>
<span class="line" id="L895">            .jstring_ = this,</span>
<span class="line" id="L896">            .pos = <span class="tok-number">0</span>,</span>
<span class="line" id="L897">        };</span>
<span class="line" id="L898">    }</span>
<span class="line" id="L899"></span>
<span class="line" id="L900">    <span class="tok-comment">/// return an interator can iterate char(u8) by char, but from the end.</span></span>
<span class="line" id="L901">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">reverseIterator</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) U8ReverseIterator {</span>
<span class="line" id="L902">        <span class="tok-kw">return</span> U8ReverseIterator{</span>
<span class="line" id="L903">            .jstring_ = this,</span>
<span class="line" id="L904">            .pos = -<span class="tok-number">1</span>,</span>
<span class="line" id="L905">        };</span>
<span class="line" id="L906">    }</span>
<span class="line" id="L907"></span>
<span class="line" id="L908">    <span class="tok-comment">/// return std.unicode.Utf8Iterator, which can help to iterate through every</span></span>
<span class="line" id="L909">    <span class="tok-comment">/// unicode char</span></span>
<span class="line" id="L910">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">utf8Iterator</span>(this: *JStringUnmanaged) <span class="tok-type">anyerror</span>!std.unicode.Utf8Iterator {</span>
<span class="line" id="L911">        _ = <span class="tok-kw">try</span> this.utf8Len();</span>
<span class="line" id="L912">        <span class="tok-kw">return</span> this.utf8_view.iterator();</span>
<span class="line" id="L913">    }</span>
<span class="line" id="L914"></span>
<span class="line" id="L915">    <span class="tok-comment">// ** at</span>
</span>
<span class="line" id="L916"></span>
<span class="line" id="L917">    <span class="tok-comment">/// different to Javascript's string.at, return unicode char(u21) of index, as prefer utf-8 string. Same to</span></span>
<span class="line" id="L918">    <span class="tok-comment">/// Javascript, accept index as `i32`: when postive is from beginning; when negative is from ending; when</span></span>
<span class="line" id="L919">    <span class="tok-comment">/// `index == 0`, return the the first char if not empty.</span></span>
<span class="line" id="L920">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">at</span>(this: *JStringUnmanaged, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u21</span> {</span>
<span class="line" id="L921">        <span class="tok-kw">const</span> utf8_len = <span class="tok-kw">try</span> this.utf8Len();</span>
<span class="line" id="L922">        <span class="tok-kw">if</span> (index &gt;= utf8_len) {</span>
<span class="line" id="L923">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds;</span>
<span class="line" id="L924">        }</span>
<span class="line" id="L925"></span>
<span class="line" id="L926">        <span class="tok-kw">if</span> ((-index) &gt; utf8_len) {</span>
<span class="line" id="L927">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds;</span>
<span class="line" id="L928">        }</span>
<span class="line" id="L929"></span>
<span class="line" id="L930">        <span class="tok-kw">const</span> char_pos: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (index &gt;= <span class="tok-number">0</span>) <span class="tok-builtin">@intCast</span>(index) <span class="tok-kw">else</span> (utf8_len - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-index)));</span>
<span class="line" id="L931"></span>
<span class="line" id="L932">        <span class="tok-kw">var</span> it = this.utf8_view.iterator();</span>
<span class="line" id="L933">        <span class="tok-kw">var</span> unicode_char: <span class="tok-type">u21</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L934">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..utf8_len) |i| {</span>
<span class="line" id="L935">            <span class="tok-kw">if</span> (it.nextCodepoint()) |uc| {</span>
<span class="line" id="L936">                unicode_char = uc;</span>
<span class="line" id="L937">            }</span>
<span class="line" id="L938">            <span class="tok-kw">if</span> (i &gt;= char_pos) {</span>
<span class="line" id="L939">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L940">            }</span>
<span class="line" id="L941">        }</span>
<span class="line" id="L942">        <span class="tok-kw">return</span> unicode_char;</span>
<span class="line" id="L943">    }</span>
<span class="line" id="L944"></span>
<span class="line" id="L945">    <span class="tok-comment">// ** charAt</span>
</span>
<span class="line" id="L946"></span>
<span class="line" id="L947">    <span class="tok-comment">/// different to Javascript's string.charAt, return u8 of index, as prefer utf-8 string. Same to Javascript,</span></span>
<span class="line" id="L948">    <span class="tok-comment">/// accept index as `i32`: when postive is from beginning; when negative is from ending; when `index == 0`, return</span></span>
<span class="line" id="L949">    <span class="tok-comment">/// the the first char if not empty.</span></span>
<span class="line" id="L950">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">charAt</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u8</span> {</span>
<span class="line" id="L951">        <span class="tok-kw">if</span> (index &gt;= this.len()) {</span>
<span class="line" id="L952">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds;</span>
<span class="line" id="L953">        }</span>
<span class="line" id="L954"></span>
<span class="line" id="L955">        <span class="tok-kw">if</span> ((-index) &gt; this.len()) {</span>
<span class="line" id="L956">            <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds;</span>
<span class="line" id="L957">        }</span>
<span class="line" id="L958"></span>
<span class="line" id="L959">        <span class="tok-kw">if</span> (index &gt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L960">            <span class="tok-kw">return</span> this.str_slice[<span class="tok-builtin">@intCast</span>(index)];</span>
<span class="line" id="L961">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L962">            <span class="tok-kw">return</span> this.str_slice[this.len() - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-index))];</span>
<span class="line" id="L963">        }</span>
<span class="line" id="L964">    }</span>
<span class="line" id="L965"></span>
<span class="line" id="L966">    <span class="tok-comment">// ** charCodeAt</span>
</span>
<span class="line" id="L967"></span>
<span class="line" id="L968">    <span class="tok-comment">/// charCodeAt does not make sense in zig, please use at or charAt!</span></span>
<span class="line" id="L969">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">charCodeAt</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u21</span> {</span>
<span class="line" id="L970">        _ = this;</span>
<span class="line" id="L971">        _ = index;</span>
<span class="line" id="L972">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;charCodeAt does not make sense in zig, please use at or charAt!&quot;</span>);</span>
<span class="line" id="L973">    }</span>
<span class="line" id="L974"></span>
<span class="line" id="L975">    <span class="tok-comment">// ** codePointAt</span>
</span>
<span class="line" id="L976"></span>
<span class="line" id="L977">    <span class="tok-comment">/// as in zig we use u21 for char, so codePointAt is a trival alias to at().</span></span>
<span class="line" id="L978">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">codePointAt</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, index: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">u21</span> {</span>
<span class="line" id="L979">        _ = this;</span>
<span class="line" id="L980">        _ = index;</span>
<span class="line" id="L981">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;codePointAt does not make sense in zig, please use at or charAt!&quot;</span>);</span>
<span class="line" id="L982">    }</span>
<span class="line" id="L983"></span>
<span class="line" id="L984">    <span class="tok-comment">// ** concat</span>
</span>
<span class="line" id="L985"></span>
<span class="line" id="L986">    <span class="tok-comment">/// Concat jstrings with the other.</span></span>
<span class="line" id="L987">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concat</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, other_jstring: JStringUnmanaged) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L988">        <span class="tok-kw">return</span> this.concatSlice(allocator, other_jstring.str_slice);</span>
<span class="line" id="L989">    }</span>
<span class="line" id="L990"></span>
<span class="line" id="L991">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatSlice</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, other_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L992">        <span class="tok-kw">if</span> (other_slice.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L993">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L994">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L995">            <span class="tok-kw">const</span> this_len = this.len();</span>
<span class="line" id="L996">            <span class="tok-kw">const</span> other_len = other_slice.len;</span>
<span class="line" id="L997">            <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, this_len + other_len);</span>
<span class="line" id="L998">            <span class="tok-kw">var</span> new_slice_ptr = new_slice.ptr;</span>
<span class="line" id="L999">            <span class="tok-builtin">@memcpy</span>(new_slice_ptr, this.str_slice);</span>
<span class="line" id="L1000">            new_slice_ptr += this.str_slice.len;</span>
<span class="line" id="L1001">            <span class="tok-builtin">@memcpy</span>(new_slice_ptr, other_slice);</span>
<span class="line" id="L1002">            <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1003">                .str_slice = new_slice,</span>
<span class="line" id="L1004">            };</span>
<span class="line" id="L1005">        }</span>
<span class="line" id="L1006">    }</span>
<span class="line" id="L1007"></span>
<span class="line" id="L1008">    <span class="tok-comment">/// Concat jstrings in rest_jstrings in order, return a new allocated jstring. If `rest_jstrings.len == 0`, will</span></span>
<span class="line" id="L1009">    <span class="tok-comment">/// return a copy of this jstring.</span></span>
<span class="line" id="L1010">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatMany</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, rest_jstrings: []<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1011">        <span class="tok-kw">if</span> (rest_jstrings.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1012">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1013">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1014">            <span class="tok-kw">var</span> rest_sum_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1015">            <span class="tok-kw">const</span> new_len = this.len() + lenbrk: {</span>
<span class="line" id="L1016">                <span class="tok-kw">for</span> (rest_jstrings) |jstring| {</span>
<span class="line" id="L1017">                    rest_sum_len += jstring.len();</span>
<span class="line" id="L1018">                }</span>
<span class="line" id="L1019">                <span class="tok-kw">break</span> :lenbrk rest_sum_len;</span>
<span class="line" id="L1020">            };</span>
<span class="line" id="L1021"></span>
<span class="line" id="L1022">            <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, new_len);</span>
<span class="line" id="L1023">            <span class="tok-kw">var</span> new_slice_ptr = new_slice.ptr;</span>
<span class="line" id="L1024">            <span class="tok-builtin">@memcpy</span>(new_slice_ptr, this.str_slice);</span>
<span class="line" id="L1025">            new_slice_ptr += this.str_slice.len;</span>
<span class="line" id="L1026">            <span class="tok-kw">for</span> (rest_jstrings) |jstring| {</span>
<span class="line" id="L1027">                <span class="tok-builtin">@memcpy</span>(new_slice_ptr, jstring.str_slice);</span>
<span class="line" id="L1028">                new_slice_ptr += jstring.len();</span>
<span class="line" id="L1029">            }</span>
<span class="line" id="L1030">            <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1031">                .str_slice = new_slice,</span>
<span class="line" id="L1032">            };</span>
<span class="line" id="L1033">        }</span>
<span class="line" id="L1034">    }</span>
<span class="line" id="L1035"></span>
<span class="line" id="L1036">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatManySlices</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, rest_slices: []<span class="tok-kw">const</span> []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1037">        <span class="tok-kw">if</span> (rest_slices.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1038">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1039">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1040">            <span class="tok-kw">var</span> rest_sum_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1041">            <span class="tok-kw">const</span> new_len = this.len() + lenbrk: {</span>
<span class="line" id="L1042">                <span class="tok-kw">for</span> (rest_slices) |s| {</span>
<span class="line" id="L1043">                    rest_sum_len += s.len;</span>
<span class="line" id="L1044">                }</span>
<span class="line" id="L1045">                <span class="tok-kw">break</span> :lenbrk rest_sum_len;</span>
<span class="line" id="L1046">            };</span>
<span class="line" id="L1047"></span>
<span class="line" id="L1048">            <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, new_len);</span>
<span class="line" id="L1049">            <span class="tok-kw">var</span> new_slice_ptr = new_slice.ptr;</span>
<span class="line" id="L1050">            <span class="tok-builtin">@memcpy</span>(new_slice_ptr, this.str_slice);</span>
<span class="line" id="L1051">            new_slice_ptr += this.str_slice.len;</span>
<span class="line" id="L1052">            <span class="tok-kw">for</span> (rest_slices) |s| {</span>
<span class="line" id="L1053">                <span class="tok-builtin">@memcpy</span>(new_slice_ptr, s);</span>
<span class="line" id="L1054">                new_slice_ptr += s.len;</span>
<span class="line" id="L1055">            }</span>
<span class="line" id="L1056">            <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1057">                .str_slice = new_slice,</span>
<span class="line" id="L1058">            };</span>
<span class="line" id="L1059">        }</span>
<span class="line" id="L1060">    }</span>
<span class="line" id="L1061"></span>
<span class="line" id="L1062">    <span class="tok-comment">/// Concat jstrings by format with fmt &amp; .{ data }. It is a shortcut for first creating tmp str from</span></span>
<span class="line" id="L1063">    <span class="tok-comment">/// JStringUnmanaged.newFromFormat then second this.concat(tmp str). (or below psudeo code)</span></span>
<span class="line" id="L1064">    <span class="tok-comment">///</span></span>
<span class="line" id="L1065">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L1066">    <span class="tok-comment">/// var tmp_jstring = JStringUnmanaged.newFromFormat(allocator, fmt, rest_items);</span></span>
<span class="line" id="L1067">    <span class="tok-comment">/// defer tmp_jstring.deinit(allocator);</span></span>
<span class="line" id="L1068">    <span class="tok-comment">/// const tmp_jstrings = []JStringUnmanaged{ tmp_jstring };</span></span>
<span class="line" id="L1069">    <span class="tok-comment">/// this.concat(allocator, &amp;tmp_jstrings);</span></span>
<span class="line" id="L1070">    <span class="tok-comment">/// ```</span></span>
<span class="line" id="L1071">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatFormat</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, <span class="tok-kw">comptime</span> fmt: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, rest_items: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1072">        <span class="tok-kw">const</span> ArgsType = <span class="tok-builtin">@TypeOf</span>(rest_items);</span>
<span class="line" id="L1073">        <span class="tok-kw">const</span> args_type_info = <span class="tok-builtin">@typeInfo</span>(ArgsType);</span>
<span class="line" id="L1074">        <span class="tok-kw">if</span> (args_type_info != .Struct) {</span>
<span class="line" id="L1075">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected tuple or struct argument, found &quot;</span> ++ <span class="tok-builtin">@typeName</span>(ArgsType));</span>
<span class="line" id="L1076">        }</span>
<span class="line" id="L1077"></span>
<span class="line" id="L1078">        <span class="tok-kw">const</span> fields_info = args_type_info.Struct.fields;</span>
<span class="line" id="L1079">        <span class="tok-kw">if</span> (fields_info.len &gt; <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">u32</span>).Int.bits) {</span>
<span class="line" id="L1080">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;32 arguments max are supported per format call&quot;</span>);</span>
<span class="line" id="L1081">        }</span>
<span class="line" id="L1082"></span>
<span class="line" id="L1083">        <span class="tok-kw">if</span> (rest_items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1084">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1085">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1086">            <span class="tok-kw">var</span> rest_items_jstring = <span class="tok-kw">try</span> JStringUnmanaged.newFromFormat(allocator, fmt, rest_items);</span>
<span class="line" id="L1087">            <span class="tok-kw">defer</span> rest_items_jstring.deinit(allocator);</span>
<span class="line" id="L1088">            <span class="tok-kw">var</span> rest_items_jstrings = [<span class="tok-number">1</span>]JStringUnmanaged{rest_items_jstring};</span>
<span class="line" id="L1089">            <span class="tok-kw">return</span> this.concatMany(allocator, &amp;rest_items_jstrings);</span>
<span class="line" id="L1090">        }</span>
<span class="line" id="L1091">    }</span>
<span class="line" id="L1092"></span>
<span class="line" id="L1093">    <span class="tok-comment">/// Similar to concatFormat, but try to auto gen fmt from rest_items.</span></span>
<span class="line" id="L1094">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">concatTuple</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, rest_items: <span class="tok-kw">anytype</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1095">        <span class="tok-kw">const</span> ArgsType = <span class="tok-builtin">@TypeOf</span>(rest_items);</span>
<span class="line" id="L1096">        <span class="tok-kw">const</span> args_type_info = <span class="tok-builtin">@typeInfo</span>(ArgsType);</span>
<span class="line" id="L1097">        <span class="tok-kw">if</span> (args_type_info != .Struct) {</span>
<span class="line" id="L1098">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;expected tuple or struct argument, found &quot;</span> ++ <span class="tok-builtin">@typeName</span>(ArgsType));</span>
<span class="line" id="L1099">        }</span>
<span class="line" id="L1100"></span>
<span class="line" id="L1101">        <span class="tok-kw">const</span> fields_info = args_type_info.Struct.fields;</span>
<span class="line" id="L1102">        <span class="tok-kw">if</span> (fields_info.len &gt; <span class="tok-builtin">@typeInfo</span>(<span class="tok-type">u32</span>).Int.bits) {</span>
<span class="line" id="L1103">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;32 arguments max are supported per format call&quot;</span>);</span>
<span class="line" id="L1104">        }</span>
<span class="line" id="L1105"></span>
<span class="line" id="L1106">        <span class="tok-comment">// max 32 arguments, and each of them will not have long (&lt;8) specifier</span>
</span>
<span class="line" id="L1107">        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fmt_buf: [<span class="tok-number">8</span> * <span class="tok-number">32</span>]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1108">        _ = &amp;fmt_buf;</span>
<span class="line" id="L1109">        <span class="tok-kw">comptime</span> <span class="tok-kw">var</span> fmt_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1110">        <span class="tok-kw">comptime</span> {</span>
<span class="line" id="L1111">            <span class="tok-kw">var</span> fmt_print_slice: []<span class="tok-type">u8</span> = fmt_buf[<span class="tok-number">0</span>..];</span>
<span class="line" id="L1112">            <span class="tok-kw">for</span> (fields_info) |field_info| {</span>
<span class="line" id="L1113">                _bufPrintFmt(<span class="tok-builtin">@typeInfo</span>(field_info.<span class="tok-type">type</span>), &amp;fmt_buf, &amp;fmt_len, &amp;fmt_print_slice);</span>
<span class="line" id="L1114">            }</span>
<span class="line" id="L1115">        }</span>
<span class="line" id="L1116">        <span class="tok-comment">// std.debug.print(&quot;\n{s}\n&quot;, .{fmt_buf[0..fmt_len]});</span>
</span>
<span class="line" id="L1117">        <span class="tok-kw">return</span> this.concatFormat(allocator, fmt_buf[<span class="tok-number">0</span>..fmt_len], rest_items);</span>
<span class="line" id="L1118">    }</span>
<span class="line" id="L1119"></span>
<span class="line" id="L1120">    <span class="tok-comment">// ** endsWith</span>
</span>
<span class="line" id="L1121"></span>
<span class="line" id="L1122">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">endsWith</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, suffix: JStringUnmanaged) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1123">        <span class="tok-kw">return</span> this.endsWithSlice(suffix.str_slice);</span>
<span class="line" id="L1124">    }</span>
<span class="line" id="L1125"></span>
<span class="line" id="L1126">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">endsWithSlice</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, suffix_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1127">        <span class="tok-kw">if</span> (this.len() &lt; suffix_slice.len) {</span>
<span class="line" id="L1128">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1129">        }</span>
<span class="line" id="L1130">        <span class="tok-kw">return</span> std.mem.eql(<span class="tok-type">u8</span>, this.str_slice[this.str_slice.len - suffix_slice.len ..], suffix_slice);</span>
<span class="line" id="L1131">    }</span>
<span class="line" id="L1132"></span>
<span class="line" id="L1133">    <span class="tok-comment">// ** fromCharCode</span>
</span>
<span class="line" id="L1134"></span>
<span class="line" id="L1135">    <span class="tok-comment">/// zig supports utf-8 natively, use newFromSlice instead.</span></span>
<span class="line" id="L1136">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromCharCode</span>() JStringUnmanaged {</span>
<span class="line" id="L1137">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;zig supports utf-8 natively, use newFromSlice instead.&quot;</span>);</span>
<span class="line" id="L1138">    }</span>
<span class="line" id="L1139"></span>
<span class="line" id="L1140">    <span class="tok-comment">// ** fromCodePoint</span>
</span>
<span class="line" id="L1141"></span>
<span class="line" id="L1142">    <span class="tok-comment">/// zig supports utf-8 natively, use newFromSlice instead.</span></span>
<span class="line" id="L1143">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fromCodePoint</span>() JStringUnmanaged {</span>
<span class="line" id="L1144">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;zig supports utf-8 natively, use newFromSlice instead.&quot;</span>);</span>
<span class="line" id="L1145">    }</span>
<span class="line" id="L1146"></span>
<span class="line" id="L1147">    <span class="tok-comment">// ** includes</span>
</span>
<span class="line" id="L1148"></span>
<span class="line" id="L1149">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">includes</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1150">        <span class="tok-kw">return</span> this._naive_indexOf(needle_slice, pos, <span class="tok-null">false</span>) &gt;= <span class="tok-number">0</span>;</span>
<span class="line" id="L1151">    }</span>
<span class="line" id="L1152"></span>
<span class="line" id="L1153">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fastIncludes</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1154">        <span class="tok-kw">const</span> i = this._kmp_indexOf(allocator, needle_slice, pos, <span class="tok-null">false</span>) <span class="tok-kw">catch</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1155">        <span class="tok-kw">return</span> i &gt;= <span class="tok-number">0</span>;</span>
<span class="line" id="L1156">    }</span>
<span class="line" id="L1157"></span>
<span class="line" id="L1158">    <span class="tok-comment">// ** indexOf</span>
</span>
<span class="line" id="L1159"></span>
<span class="line" id="L1160">    <span class="tok-comment">/// The indexOf() method searches this string and returns the index of the first occurrence of the specified</span></span>
<span class="line" id="L1161">    <span class="tok-comment">/// substring. It takes an starting position and returns the first occurrence of the specified substring at an index</span></span>
<span class="line" id="L1162">    <span class="tok-comment">/// greater than or equal to the specified number.</span></span>
<span class="line" id="L1163">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">indexOf</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">isize</span> {</span>
<span class="line" id="L1164">        <span class="tok-kw">return</span> this._naive_indexOf(needle_slice, pos, <span class="tok-null">false</span>);</span>
<span class="line" id="L1165">    }</span>
<span class="line" id="L1166"></span>
<span class="line" id="L1167">    <span class="tok-comment">/// Fast version of indexOf as it uses KMP algorithm for searching. Will result in O(this.len+needle_slice.len) but</span></span>
<span class="line" id="L1168">    <span class="tok-comment">/// also requires allocator for creating KMP lookup table.</span></span>
<span class="line" id="L1169">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fastIndexOf</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">isize</span> {</span>
<span class="line" id="L1170">        <span class="tok-kw">return</span> this._kmp_indexOf(allocator, needle_slice, pos, <span class="tok-null">false</span>);</span>
<span class="line" id="L1171">    }</span>
<span class="line" id="L1172"></span>
<span class="line" id="L1173">    <span class="tok-kw">fn</span> <span class="tok-fn">_naive_indexOf</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>, want_last: <span class="tok-type">bool</span>) <span class="tok-type">isize</span> {</span>
<span class="line" id="L1174">        <span class="tok-kw">if</span> (needle_slice.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1175">            <span class="tok-kw">if</span> (want_last) {</span>
<span class="line" id="L1176">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(this.len() - <span class="tok-number">1</span>));</span>
<span class="line" id="L1177">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1178">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(pos));</span>
<span class="line" id="L1179">            }</span>
<span class="line" id="L1180">        }</span>
<span class="line" id="L1181"></span>
<span class="line" id="L1182">        <span class="tok-kw">if</span> (this.str_slice.len &lt; needle_slice.len) {</span>
<span class="line" id="L1183">            <span class="tok-kw">return</span> -<span class="tok-number">1</span>;</span>
<span class="line" id="L1184">        }</span>
<span class="line" id="L1185"></span>
<span class="line" id="L1186">        <span class="tok-kw">var</span> occurence: <span class="tok-type">isize</span> = -<span class="tok-number">1</span>;</span>
<span class="line" id="L1187">        <span class="tok-kw">const</span> haystack_slice = this.str_slice[pos..];</span>
<span class="line" id="L1188">        <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1189">        <span class="tok-kw">while</span> (k &lt; haystack_slice.len - needle_slice.len + <span class="tok-number">1</span>) : (k += <span class="tok-number">1</span>) {</span>
<span class="line" id="L1190">            <span class="tok-kw">if</span> (std.mem.eql(<span class="tok-type">u8</span>, haystack_slice[k .. k + needle_slice.len], needle_slice)) {</span>
<span class="line" id="L1191">                occurence = <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(k));</span>
<span class="line" id="L1192">                <span class="tok-kw">if</span> (!want_last) {</span>
<span class="line" id="L1193">                    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (occurence &gt;= <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(pos)) + occurence <span class="tok-kw">else</span> occurence;</span>
<span class="line" id="L1194">                }</span>
<span class="line" id="L1195">            } <span class="tok-kw">else</span> <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1196">        }</span>
<span class="line" id="L1197">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (occurence &gt;= <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(pos)) + occurence <span class="tok-kw">else</span> occurence;</span>
<span class="line" id="L1198">    }</span>
<span class="line" id="L1199"></span>
<span class="line" id="L1200">    <span class="tok-kw">fn</span> <span class="tok-fn">_kmp_indexOf</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>, want_last: <span class="tok-type">bool</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">isize</span> {</span>
<span class="line" id="L1201">        <span class="tok-kw">if</span> (needle_slice.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1202">            <span class="tok-kw">if</span> (want_last) {</span>
<span class="line" id="L1203">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(this.len() - <span class="tok-number">1</span>));</span>
<span class="line" id="L1204">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1205">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(pos));</span>
<span class="line" id="L1206">            }</span>
<span class="line" id="L1207">        }</span>
<span class="line" id="L1208"></span>
<span class="line" id="L1209">        <span class="tok-kw">if</span> (pos &gt;= this.len() <span class="tok-kw">or</span> pos + needle_slice.len &gt; this.len()) {</span>
<span class="line" id="L1210">            <span class="tok-kw">return</span> -<span class="tok-number">1</span>;</span>
<span class="line" id="L1211">        }</span>
<span class="line" id="L1212"></span>
<span class="line" id="L1213">        <span class="tok-kw">var</span> occurence: <span class="tok-type">isize</span> = -<span class="tok-number">1</span>;</span>
<span class="line" id="L1214">        <span class="tok-kw">const</span> haystack_slice = this.str_slice[pos..];</span>
<span class="line" id="L1215"></span>
<span class="line" id="L1216">        <span class="tok-kw">const</span> t = <span class="tok-kw">try</span> _kmpBuildFailureTable(allocator, needle_slice);</span>
<span class="line" id="L1217">        <span class="tok-kw">defer</span> allocator.free(t);</span>
<span class="line" id="L1218"></span>
<span class="line" id="L1219">        <span class="tok-kw">var</span> j: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1220">        <span class="tok-kw">var</span> k: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1221">        <span class="tok-kw">while</span> (j &lt; haystack_slice.len) {</span>
<span class="line" id="L1222">            <span class="tok-kw">if</span> (needle_slice[k] == haystack_slice[j]) {</span>
<span class="line" id="L1223">                j += <span class="tok-number">1</span>;</span>
<span class="line" id="L1224">                k += <span class="tok-number">1</span>;</span>
<span class="line" id="L1225">                <span class="tok-kw">if</span> (k == needle_slice.len) {</span>
<span class="line" id="L1226">                    <span class="tok-kw">if</span> (!want_last) {</span>
<span class="line" id="L1227">                        occurence = <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(j)) - <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(k));</span>
<span class="line" id="L1228">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1229">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1230">                        occurence = <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(j)) - <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(k));</span>
<span class="line" id="L1231">                        k = <span class="tok-kw">if</span> (t[k] &gt;= <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(t[k])) <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1232">                    }</span>
<span class="line" id="L1233">                }</span>
<span class="line" id="L1234">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1235">                <span class="tok-kw">if</span> (t[k] &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1236">                    j += <span class="tok-number">1</span>;</span>
<span class="line" id="L1237">                    k = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(t[k] + <span class="tok-number">1</span>));</span>
<span class="line" id="L1238">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1239">                    k = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(t[k]));</span>
<span class="line" id="L1240">                }</span>
<span class="line" id="L1241">            }</span>
<span class="line" id="L1242">        }</span>
<span class="line" id="L1243"></span>
<span class="line" id="L1244">        <span class="tok-kw">return</span> <span class="tok-kw">if</span> (occurence &gt;= <span class="tok-number">0</span>) <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(pos)) + occurence <span class="tok-kw">else</span> occurence;</span>
<span class="line" id="L1245">    }</span>
<span class="line" id="L1246"></span>
<span class="line" id="L1247">    <span class="tok-comment">// ** isWellFormed</span>
</span>
<span class="line" id="L1248"></span>
<span class="line" id="L1249">    <span class="tok-comment">/// similar to definition in javascript, but with difference that we are checking utf8.</span></span>
<span class="line" id="L1250">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">isWellFormed</span>(this: *JStringUnmanaged) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1251">        _ = this.utf8Len() <span class="tok-kw">catch</span> {</span>
<span class="line" id="L1252">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1253">        };</span>
<span class="line" id="L1254">        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L1255">    }</span>
<span class="line" id="L1256"></span>
<span class="line" id="L1257">    <span class="tok-comment">// ** lastIndexOf</span>
</span>
<span class="line" id="L1258"></span>
<span class="line" id="L1259">    <span class="tok-comment">/// The lastIndexOf() method searches this string and returns the index of the last occurrence of the specified</span></span>
<span class="line" id="L1260">    <span class="tok-comment">/// substring. It takes an optional starting position and returns the last occurrence of the specified substring at</span></span>
<span class="line" id="L1261">    <span class="tok-comment">/// an index less than or equal to the specified number.</span></span>
<span class="line" id="L1262">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">lastIndexOf</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">isize</span> {</span>
<span class="line" id="L1263">        <span class="tok-kw">return</span> this._naive_indexOf(needle_slice, pos, <span class="tok-null">true</span>);</span>
<span class="line" id="L1264">    }</span>
<span class="line" id="L1265"></span>
<span class="line" id="L1266">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fastLastIndexOf</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, pos: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">isize</span> {</span>
<span class="line" id="L1267">        <span class="tok-kw">return</span> this._kmp_indexOf(allocator, needle_slice, pos, <span class="tok-null">true</span>);</span>
<span class="line" id="L1268">    }</span>
<span class="line" id="L1269"></span>
<span class="line" id="L1270">    <span class="tok-comment">// ** localeCompare</span>
</span>
<span class="line" id="L1271"></span>
<span class="line" id="L1272">    <span class="tok-comment">/// Not implemented! Does this method make sense in zig?</span></span>
<span class="line" id="L1273">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">localeCompare</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1274">        _ = this;</span>
<span class="line" id="L1275">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Not implemented! Does localeCompare make sense in zig?&quot;</span>);</span>
<span class="line" id="L1276">    }</span>
<span class="line" id="L1277"></span>
<span class="line" id="L1278">    <span class="tok-comment">// ** match</span>
</span>
<span class="line" id="L1279"></span>
<span class="line" id="L1280">    <span class="tok-comment">/// Thin wrap of Regex's match against this.str_slice as search subject. The regex syntax used is pcre2, can read</span></span>
<span class="line" id="L1281">    <span class="tok-comment">/// here: https://pcre2project.github.io/pcre2/doc/html/pcre2pattern.html, or try it here: https://regex101.com/</span></span>
<span class="line" id="L1282">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">match</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>, fetch_results: <span class="tok-type">bool</span>, regex_options: <span class="tok-type">u32</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!RegexUnmanaged {</span>
<span class="line" id="L1283">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L1284">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(allocator, pattern, regex_options);</span>
<span class="line" id="L1285">            <span class="tok-kw">try</span> re.match(allocator, this.str_slice, offset, fetch_results, match_options);</span>
<span class="line" id="L1286">            <span class="tok-kw">return</span> re;</span>
<span class="line" id="L1287">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1288">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L1289">        }</span>
<span class="line" id="L1290">    }</span>
<span class="line" id="L1291"></span>
<span class="line" id="L1292">    <span class="tok-comment">// ** matchAll</span>
</span>
<span class="line" id="L1293"></span>
<span class="line" id="L1294">    <span class="tok-comment">/// Thin wrap of Regex's matchAll against this.str_slice as search subject. The regex syntax used is pcre2, can read</span></span>
<span class="line" id="L1295">    <span class="tok-comment">/// here: https://pcre2project.github.io/pcre2/doc/html/pcre2pattern.html, or try it here: https://regex101.com/</span></span>
<span class="line" id="L1296">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">matchAll</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>, regex_options: <span class="tok-type">u32</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!RegexUnmanaged {</span>
<span class="line" id="L1297">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L1298">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(allocator, pattern, regex_options);</span>
<span class="line" id="L1299">            <span class="tok-kw">try</span> re.matchAll(allocator, this.str_slice, offset, match_options);</span>
<span class="line" id="L1300">            <span class="tok-kw">return</span> re;</span>
<span class="line" id="L1301">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1302">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L1303">        }</span>
<span class="line" id="L1304">    }</span>
<span class="line" id="L1305"></span>
<span class="line" id="L1306">    <span class="tok-comment">// ** normalize</span>
</span>
<span class="line" id="L1307"></span>
<span class="line" id="L1308">    <span class="tok-comment">/// Not implemented! Does normalize make sense in zig?</span></span>
<span class="line" id="L1309">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">normalize</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) JStringUnmanaged {</span>
<span class="line" id="L1310">        _ = this;</span>
<span class="line" id="L1311">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;Not implemented! Does normalize make sense in zig?&quot;</span>);</span>
<span class="line" id="L1312">    }</span>
<span class="line" id="L1313"></span>
<span class="line" id="L1314">    <span class="tok-comment">// ** padEnd</span>
</span>
<span class="line" id="L1315"></span>
<span class="line" id="L1316">    <span class="tok-comment">/// The padEnd method creates a new string by padding this string with a given slice (repeated, if needed) so that</span></span>
<span class="line" id="L1317">    <span class="tok-comment">/// the resulting string reaches a given length. The padding is applied from the end of this string. If padString is</span></span>
<span class="line" id="L1318">    <span class="tok-comment">/// too long to stay within targetLength, it will be truncated from the beginning.</span></span>
<span class="line" id="L1319">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">padEnd</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, wanted_len: <span class="tok-type">usize</span>, pad_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1320">        <span class="tok-kw">if</span> (this.len() &gt;= wanted_len) {</span>
<span class="line" id="L1321">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1322">        }</span>
<span class="line" id="L1323"></span>
<span class="line" id="L1324">        <span class="tok-kw">var</span> wanted_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, wanted_len);</span>
<span class="line" id="L1325"></span>
<span class="line" id="L1326">        <span class="tok-kw">const</span> wanted_pad_len = wanted_len - this.len();</span>
<span class="line" id="L1327">        <span class="tok-kw">const</span> count = <span class="tok-builtin">@divTrunc</span>(wanted_pad_len, pad_slice.len);</span>
<span class="line" id="L1328">        <span class="tok-kw">const</span> residual_len = wanted_pad_len % pad_slice.len;</span>
<span class="line" id="L1329">        <span class="tok-kw">var</span> target_slice = wanted_slice[<span class="tok-number">0</span>..this.str_slice.len];</span>
<span class="line" id="L1330">        <span class="tok-builtin">@memcpy</span>(target_slice, this.str_slice);</span>
<span class="line" id="L1331">        target_slice = wanted_slice[wanted_len - residual_len ..];</span>
<span class="line" id="L1332">        <span class="tok-builtin">@memcpy</span>(target_slice, pad_slice[<span class="tok-number">0</span>..residual_len]);</span>
<span class="line" id="L1333">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |i| {</span>
<span class="line" id="L1334">            target_slice = wanted_slice[this.str_slice.len + i * pad_slice.len .. wanted_len - residual_len];</span>
<span class="line" id="L1335">            <span class="tok-builtin">@memcpy</span>(target_slice, pad_slice);</span>
<span class="line" id="L1336">        }</span>
<span class="line" id="L1337">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1338">            .str_slice = wanted_slice,</span>
<span class="line" id="L1339">        };</span>
<span class="line" id="L1340">    }</span>
<span class="line" id="L1341"></span>
<span class="line" id="L1342">    <span class="tok-comment">/// JString version of padEnd, accept pad_string (*const JStringUnmanaged) instead of slice.</span></span>
<span class="line" id="L1343">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">padEndJString</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, wanted_len: <span class="tok-type">usize</span>, pad_string: *<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1344">        <span class="tok-kw">return</span> this.padEnd(allocator, wanted_len, pad_string.str_slice);</span>
<span class="line" id="L1345">    }</span>
<span class="line" id="L1346"></span>
<span class="line" id="L1347">    <span class="tok-comment">// ** padStart</span>
</span>
<span class="line" id="L1348"></span>
<span class="line" id="L1349">    <span class="tok-comment">/// The padStart() method creates a new string by padding this string with another slice (multiple times, if needed)</span></span>
<span class="line" id="L1350">    <span class="tok-comment">/// until the resulting string reaches the given length. The padding is applied from the start of this string. If</span></span>
<span class="line" id="L1351">    <span class="tok-comment">/// pad_slice is too long to stay within the wanted_len, it will be truncated from the end.</span></span>
<span class="line" id="L1352">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">padStart</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, wanted_len: <span class="tok-type">usize</span>, pad_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1353">        <span class="tok-kw">if</span> (this.len() &gt;= wanted_len) {</span>
<span class="line" id="L1354">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1355">        }</span>
<span class="line" id="L1356"></span>
<span class="line" id="L1357">        <span class="tok-kw">var</span> wanted_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, wanted_len);</span>
<span class="line" id="L1358"></span>
<span class="line" id="L1359">        <span class="tok-kw">const</span> wanted_pad_len = wanted_len - this.len();</span>
<span class="line" id="L1360">        <span class="tok-kw">const</span> count = <span class="tok-builtin">@divTrunc</span>(wanted_pad_len, pad_slice.len);</span>
<span class="line" id="L1361">        <span class="tok-kw">const</span> residual_len = wanted_pad_len % pad_slice.len;</span>
<span class="line" id="L1362">        <span class="tok-kw">var</span> target_slice = wanted_slice[wanted_pad_len..];</span>
<span class="line" id="L1363">        <span class="tok-builtin">@memcpy</span>(target_slice, this.str_slice);</span>
<span class="line" id="L1364">        target_slice = wanted_slice[<span class="tok-number">0</span>..residual_len];</span>
<span class="line" id="L1365">        <span class="tok-builtin">@memcpy</span>(target_slice, pad_slice[pad_slice.len - residual_len ..]);</span>
<span class="line" id="L1366">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |i| {</span>
<span class="line" id="L1367">            target_slice = wanted_slice[residual_len + i * pad_slice.len .. wanted_pad_len];</span>
<span class="line" id="L1368">            <span class="tok-builtin">@memcpy</span>(target_slice, pad_slice);</span>
<span class="line" id="L1369">        }</span>
<span class="line" id="L1370"></span>
<span class="line" id="L1371">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1372">            .str_slice = wanted_slice,</span>
<span class="line" id="L1373">        };</span>
<span class="line" id="L1374">    }</span>
<span class="line" id="L1375"></span>
<span class="line" id="L1376">    <span class="tok-comment">/// JString version of padStart, accept pad_string (*const JStringUnmanaged) instead of slice.</span></span>
<span class="line" id="L1377">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">padStartJString</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, wanted_len: <span class="tok-type">usize</span>, pad_string: *<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1378">        <span class="tok-kw">return</span> this.padStart(allocator, wanted_len, pad_string.str_slice);</span>
<span class="line" id="L1379">    }</span>
<span class="line" id="L1380"></span>
<span class="line" id="L1381">    <span class="tok-comment">// ** raw</span>
</span>
<span class="line" id="L1382"></span>
<span class="line" id="L1383">    <span class="tok-comment">/// zig has no template literals like javascript, use newFromSlice/newFromFormat/newFromTuple instead.</span></span>
<span class="line" id="L1384">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">raw</span>() JStringUnmanaged {</span>
<span class="line" id="L1385">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;zig has no template literals like javascript, use newFromSlice/newFromFormat/newFromTuple instead.&quot;</span>);</span>
<span class="line" id="L1386">    }</span>
<span class="line" id="L1387"></span>
<span class="line" id="L1388">    <span class="tok-comment">// ** repeat</span>
</span>
<span class="line" id="L1389"></span>
<span class="line" id="L1390">    <span class="tok-comment">/// repeat current string for `count` times and return as a new string.</span></span>
<span class="line" id="L1391">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">repeat</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, count: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1392">        <span class="tok-kw">if</span> (count == <span class="tok-number">0</span> <span class="tok-kw">or</span> this.len() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1393">            <span class="tok-kw">return</span> JStringUnmanaged.newEmpty(allocator);</span>
<span class="line" id="L1394">        }</span>
<span class="line" id="L1395"></span>
<span class="line" id="L1396">        <span class="tok-kw">const</span> new_len = this.len() * count;</span>
<span class="line" id="L1397">        <span class="tok-kw">const</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, new_len);</span>
<span class="line" id="L1398">        <span class="tok-kw">var</span> target_slice: []<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1399">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..count) |i| {</span>
<span class="line" id="L1400">            target_slice = new_slice[i * this.len() .. (i + <span class="tok-number">1</span>) * this.len()];</span>
<span class="line" id="L1401">            <span class="tok-builtin">@memcpy</span>(target_slice, this.str_slice);</span>
<span class="line" id="L1402">        }</span>
<span class="line" id="L1403">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1404">            .str_slice = new_slice,</span>
<span class="line" id="L1405">        };</span>
<span class="line" id="L1406">    }</span>
<span class="line" id="L1407"></span>
<span class="line" id="L1408">    <span class="tok-comment">// ** replace</span>
</span>
<span class="line" id="L1409"></span>
<span class="line" id="L1410">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replace</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1411">        <span class="tok-kw">return</span> this._replace(allocator, pattern, replacement_slice, <span class="tok-null">false</span>);</span>
<span class="line" id="L1412">    }</span>
<span class="line" id="L1413"></span>
<span class="line" id="L1414">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceByRegex</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1415">        <span class="tok-kw">return</span> this._replaceByRegex(allocator, pattern, replacement_slice, <span class="tok-null">false</span>);</span>
<span class="line" id="L1416">    }</span>
<span class="line" id="L1417"></span>
<span class="line" id="L1418">    <span class="tok-comment">// ** replaceAll</span>
</span>
<span class="line" id="L1419"></span>
<span class="line" id="L1420">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceAll</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1421">        <span class="tok-kw">return</span> this._replace(allocator, pattern, replacement_slice, <span class="tok-null">true</span>);</span>
<span class="line" id="L1422">    }</span>
<span class="line" id="L1423"></span>
<span class="line" id="L1424">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">replaceAllByRegex</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1425">        <span class="tok-kw">return</span> this._replaceByRegex(allocator, pattern, replacement_slice, <span class="tok-null">true</span>);</span>
<span class="line" id="L1426">    }</span>
<span class="line" id="L1427"></span>
<span class="line" id="L1428">    <span class="tok-kw">fn</span> <span class="tok-fn">_replace</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> match_all: <span class="tok-type">bool</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1429">        <span class="tok-kw">const</span> max_gap_count: <span class="tok-type">usize</span> = <span class="tok-kw">if</span> (match_all) <span class="tok-builtin">@divFloor</span>(this.str_slice.len, pattern.len) <span class="tok-kw">else</span> <span class="tok-number">1</span>;</span>
<span class="line" id="L1430">        <span class="tok-kw">var</span> gaps = <span class="tok-kw">try</span> allocator.alloc(_MatchedGapIterator.Gap, max_gap_count);</span>
<span class="line" id="L1431">        <span class="tok-kw">defer</span> allocator.free(gaps);</span>
<span class="line" id="L1432">        <span class="tok-kw">var</span> gap_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1433">        <span class="tok-kw">var</span> search_offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1434">        <span class="tok-kw">var</span> found: <span class="tok-type">isize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1435">        <span class="tok-kw">if</span> (match_all) {</span>
<span class="line" id="L1436">            <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1437">                found = this.indexOf(pattern, search_offset);</span>
<span class="line" id="L1438">                <span class="tok-kw">if</span> (found &gt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L1439">                    gaps[gap_count] = _MatchedGapIterator.Gap{ .start = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(found)), .len = pattern.len };</span>
<span class="line" id="L1440">                    gap_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1441">                    search_offset = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(found)) + pattern.len;</span>
<span class="line" id="L1442">                } <span class="tok-kw">else</span> <span class="tok-kw">break</span>;</span>
<span class="line" id="L1443">            }</span>
<span class="line" id="L1444">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1445">            found = this.indexOf(pattern, <span class="tok-number">0</span>);</span>
<span class="line" id="L1446">            <span class="tok-kw">if</span> (found &gt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L1447">                gaps[gap_count] = _MatchedGapIterator.Gap{ .start = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(found)), .len = pattern.len };</span>
<span class="line" id="L1448">                gap_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1449">                search_offset = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(found)) + pattern.len;</span>
<span class="line" id="L1450">            }</span>
<span class="line" id="L1451">        }</span>
<span class="line" id="L1452">        <span class="tok-kw">if</span> (gap_count == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1453">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1454">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1455">            <span class="tok-kw">return</span> this._joinGapsWithSlice(allocator, gaps[<span class="tok-number">0</span>..gap_count], replacement_slice);</span>
<span class="line" id="L1456">        }</span>
<span class="line" id="L1457">    }</span>
<span class="line" id="L1458"></span>
<span class="line" id="L1459">    <span class="tok-kw">fn</span> <span class="tok-fn">_replaceByRegex</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> match_all: <span class="tok-type">bool</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1460">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L1461">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(allocator, pattern, RegexUnmanaged.DefaultRegexOptions);</span>
<span class="line" id="L1462">            <span class="tok-kw">if</span> (match_all) {</span>
<span class="line" id="L1463">                <span class="tok-kw">try</span> re.matchAll(allocator, this.str_slice, <span class="tok-number">0</span>, RegexUnmanaged.DefaultMatchOptions);</span>
<span class="line" id="L1464">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1465">                <span class="tok-kw">try</span> re.match(allocator, this.str_slice, <span class="tok-number">0</span>, <span class="tok-null">true</span>, RegexUnmanaged.DefaultMatchOptions);</span>
<span class="line" id="L1466">            }</span>
<span class="line" id="L1467">            <span class="tok-kw">if</span> (!re.succeed()) {</span>
<span class="line" id="L1468">                <span class="tok-kw">return</span> JStringError.RegexMatchFailed;</span>
<span class="line" id="L1469">            }</span>
<span class="line" id="L1470">            <span class="tok-kw">if</span> (re.matchSucceed()) {</span>
<span class="line" id="L1471">                <span class="tok-kw">var</span> first_gap_start_from_zero = <span class="tok-null">false</span>;</span>
<span class="line" id="L1472">                <span class="tok-kw">var</span> last_gap_end_in_end = <span class="tok-null">false</span>;</span>
<span class="line" id="L1473">                <span class="tok-kw">const</span> gap_count = brk: {</span>
<span class="line" id="L1474">                    <span class="tok-comment">// stupid method, scan once to know how many gaps we have</span>
</span>
<span class="line" id="L1475">                    <span class="tok-comment">// but since this helps us to avoid allocation (just mem access)</span>
</span>
<span class="line" id="L1476">                    <span class="tok-comment">// probably it is also fast enough</span>
</span>
<span class="line" id="L1477">                    <span class="tok-kw">var</span> gap_it = _MatchedGapIterator.init(&amp;re, this.str_slice);</span>
<span class="line" id="L1478">                    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1479">                    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> gap_it.nextGap()) |g| {</span>
<span class="line" id="L1480">                        <span class="tok-kw">if</span> (g.start == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1481">                            <span class="tok-comment">// gap is not overlapping, so simply check every one,</span>
</span>
<span class="line" id="L1482">                            <span class="tok-comment">// there must be one at most start at 0</span>
</span>
<span class="line" id="L1483">                            first_gap_start_from_zero = <span class="tok-null">true</span>;</span>
<span class="line" id="L1484">                        }</span>
<span class="line" id="L1485">                        <span class="tok-kw">if</span> (g.start + g.len == this.str_slice.len) {</span>
<span class="line" id="L1486">                            <span class="tok-comment">// same idea, must be at most one end at the end</span>
</span>
<span class="line" id="L1487">                            last_gap_end_in_end = <span class="tok-null">true</span>;</span>
<span class="line" id="L1488">                        }</span>
<span class="line" id="L1489">                        count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1490">                    }</span>
<span class="line" id="L1491">                    <span class="tok-kw">break</span> :brk count;</span>
<span class="line" id="L1492">                };</span>
<span class="line" id="L1493">                <span class="tok-kw">var</span> gaps = <span class="tok-kw">try</span> allocator.alloc(_MatchedGapIterator.Gap, gap_count);</span>
<span class="line" id="L1494">                <span class="tok-kw">defer</span> allocator.free(gaps);</span>
<span class="line" id="L1495">                <span class="tok-kw">var</span> gap_it = _MatchedGapIterator.init(&amp;re, this.str_slice);</span>
<span class="line" id="L1496">                <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1497">                <span class="tok-kw">while</span> (<span class="tok-kw">try</span> gap_it.nextGap()) |g| {</span>
<span class="line" id="L1498">                    gaps[count] = _MatchedGapIterator.Gap{ .start = g.start, .len = g.len };</span>
<span class="line" id="L1499">                    count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1500">                }</span>
<span class="line" id="L1501">                <span class="tok-kw">return</span> this._joinGapsWithSlice(allocator, gaps, replacement_slice);</span>
<span class="line" id="L1502">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> JStringError.RegexMatchFailed;</span>
<span class="line" id="L1503">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1504">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L1505">        }</span>
<span class="line" id="L1506">    }</span>
<span class="line" id="L1507"></span>
<span class="line" id="L1508">    <span class="tok-kw">fn</span> <span class="tok-fn">_joinGapsWithSlice</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, gaps: []_MatchedGapIterator.Gap, replacement_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1509">        <span class="tok-kw">var</span> first_gap_start_from_zero = <span class="tok-null">false</span>;</span>
<span class="line" id="L1510">        <span class="tok-kw">var</span> last_gap_end_in_end = <span class="tok-null">false</span>;</span>
<span class="line" id="L1511">        <span class="tok-kw">var</span> total_gap_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1512">        <span class="tok-kw">for</span> (gaps) |g| {</span>
<span class="line" id="L1513">            <span class="tok-kw">if</span> (g.start == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1514">                <span class="tok-comment">// gap is not overlapping, so simply check every one,</span>
</span>
<span class="line" id="L1515">                <span class="tok-comment">// there must be one at most start at 0</span>
</span>
<span class="line" id="L1516">                first_gap_start_from_zero = <span class="tok-null">true</span>;</span>
<span class="line" id="L1517">            }</span>
<span class="line" id="L1518">            <span class="tok-kw">if</span> (g.start + g.len == this.str_slice.len) {</span>
<span class="line" id="L1519">                <span class="tok-comment">// same idea, must be at most one end at the end</span>
</span>
<span class="line" id="L1520">                last_gap_end_in_end = <span class="tok-null">true</span>;</span>
<span class="line" id="L1521">            }</span>
<span class="line" id="L1522">            total_gap_len += g.len;</span>
<span class="line" id="L1523">        }</span>
<span class="line" id="L1524">        <span class="tok-kw">const</span> new_slice_len = this.str_slice.len - total_gap_len + replacement_slice.len * gaps.len;</span>
<span class="line" id="L1525">        <span class="tok-kw">var</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, new_slice_len);</span>
<span class="line" id="L1526">        <span class="tok-kw">var</span> copy_offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1527">        <span class="tok-kw">var</span> copy_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1528">        <span class="tok-kw">var</span> origin_offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1529">        <span class="tok-kw">for</span> (gaps) |g| {</span>
<span class="line" id="L1530">            <span class="tok-comment">// |&lt;gap&gt;..&lt;gap&gt;..|, |..&lt;gap&gt;..&lt;gap&gt;| or |..&lt;gap&gt;..&lt;gap&gt;..&lt;gap&gt;..|</span>
</span>
<span class="line" id="L1531">            copy_len = g.start - origin_offset;</span>
<span class="line" id="L1532">            <span class="tok-builtin">@memcpy</span>(new_slice[copy_offset .. copy_offset + copy_len], this.str_slice[origin_offset .. origin_offset + copy_len]);</span>
<span class="line" id="L1533">            copy_offset += copy_len;</span>
<span class="line" id="L1534">            origin_offset += copy_len;</span>
<span class="line" id="L1535"></span>
<span class="line" id="L1536">            copy_len = replacement_slice.len;</span>
<span class="line" id="L1537">            <span class="tok-builtin">@memcpy</span>(new_slice[copy_offset .. copy_offset + copy_len], replacement_slice);</span>
<span class="line" id="L1538">            copy_offset += copy_len;</span>
<span class="line" id="L1539">            origin_offset += g.len;</span>
<span class="line" id="L1540">        }</span>
<span class="line" id="L1541">        <span class="tok-kw">if</span> (!last_gap_end_in_end) {</span>
<span class="line" id="L1542">            <span class="tok-comment">// |&lt;gap&gt;..&lt;gap&gt;..| or |..&lt;gap&gt;..&lt;gap&gt;..&lt;gap&gt;..|</span>
</span>
<span class="line" id="L1543">            <span class="tok-builtin">@memcpy</span>(new_slice[copy_offset..], this.str_slice[origin_offset..]);</span>
<span class="line" id="L1544">        }</span>
<span class="line" id="L1545">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1546">            .str_slice = new_slice,</span>
<span class="line" id="L1547">        };</span>
<span class="line" id="L1548">    }</span>
<span class="line" id="L1549"></span>
<span class="line" id="L1550">    <span class="tok-comment">// ** search</span>
</span>
<span class="line" id="L1551"></span>
<span class="line" id="L1552">    <span class="tok-comment">/// simple search algorithm is alias of indexOf</span></span>
<span class="line" id="L1553">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">search</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>) <span class="tok-type">isize</span> {</span>
<span class="line" id="L1554">        <span class="tok-kw">return</span> this.indexOf(pattern, offset);</span>
<span class="line" id="L1555">    }</span>
<span class="line" id="L1556"></span>
<span class="line" id="L1557">    <span class="tok-comment">/// This function is searching by regex so it requires allocator. If the pattern is valid, will return first matched</span></span>
<span class="line" id="L1558">    <span class="tok-comment">/// start or -1 (when there is no match). Buf if the pattern itself has problem, will return</span></span>
<span class="line" id="L1559">    <span class="tok-comment">/// `JStringError.RegexMatchFailed`.</span></span>
<span class="line" id="L1560">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">searchByRegex</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">isize</span> {</span>
<span class="line" id="L1561">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L1562">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(allocator, pattern, RegexUnmanaged.DefaultRegexOptions);</span>
<span class="line" id="L1563">            <span class="tok-kw">try</span> re.match(allocator, this.str_slice, offset, <span class="tok-null">true</span>, RegexUnmanaged.DefaultMatchOptions);</span>
<span class="line" id="L1564">            <span class="tok-kw">defer</span> re.deinit(allocator);</span>
<span class="line" id="L1565">            <span class="tok-kw">if</span> (!re.succeed()) {</span>
<span class="line" id="L1566">                <span class="tok-comment">// This usually means there is a problem in the pattern, so we reports back instead of returning -1</span>
</span>
<span class="line" id="L1567">                <span class="tok-kw">return</span> JStringError.RegexMatchFailed;</span>
<span class="line" id="L1568">            }</span>
<span class="line" id="L1569">            <span class="tok-kw">if</span> (re.matchSucceed()) {</span>
<span class="line" id="L1570">                <span class="tok-kw">const</span> maybe_results = re.getResults();</span>
<span class="line" id="L1571">                <span class="tok-kw">if</span> (maybe_results) |results| {</span>
<span class="line" id="L1572">                    <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(results[<span class="tok-number">0</span>].start));</span>
<span class="line" id="L1573">                } <span class="tok-kw">else</span> <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L1574">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1575">                <span class="tok-kw">return</span> -<span class="tok-number">1</span>;</span>
<span class="line" id="L1576">            }</span>
<span class="line" id="L1577">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1578">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L1579">        }</span>
<span class="line" id="L1580">    }</span>
<span class="line" id="L1581"></span>
<span class="line" id="L1582">    <span class="tok-comment">// ** slice</span>
</span>
<span class="line" id="L1583"></span>
<span class="line" id="L1584">    <span class="tok-comment">/// Slice part of current string and return a new copy with content `[index_start, index_end)`. Both `index_start`</span></span>
<span class="line" id="L1585">    <span class="tok-comment">/// and `index_end` can be positive or negative numbers. When is positive, means the forward location from string</span></span>
<span class="line" id="L1586">    <span class="tok-comment">/// beginning; when is negative, means the backward location from string ending. Example: if `s` contains `&quot;hello&quot;`,</span></span>
<span class="line" id="L1587">    <span class="tok-comment">/// `s.slice(allocator, 1, -1)` will return a new string with content `&quot;ell&quot;`.</span></span>
<span class="line" id="L1588">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">slice</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, index_start: <span class="tok-type">isize</span>, index_end: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1589">        <span class="tok-kw">const</span> uindex_start = brk: {</span>
<span class="line" id="L1590">            <span class="tok-kw">if</span> (index_start &gt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L1591">                <span class="tok-kw">break</span> :brk <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(index_start));</span>
<span class="line" id="L1592">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1593">                <span class="tok-kw">if</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-index_start)) &gt; this.len()) {</span>
<span class="line" id="L1594">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds;</span>
<span class="line" id="L1595">                }</span>
<span class="line" id="L1596">                <span class="tok-kw">break</span> :brk this.len() - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-index_start));</span>
<span class="line" id="L1597">            }</span>
<span class="line" id="L1598">        };</span>
<span class="line" id="L1599">        <span class="tok-kw">const</span> uindex_end = brk: {</span>
<span class="line" id="L1600">            <span class="tok-kw">if</span> (index_end &gt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L1601">                <span class="tok-kw">break</span> :brk <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(index_end));</span>
<span class="line" id="L1602">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1603">                <span class="tok-kw">if</span> (<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-index_end)) &gt; this.len()) {</span>
<span class="line" id="L1604">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.IndexOutOfBounds;</span>
<span class="line" id="L1605">                }</span>
<span class="line" id="L1606">                <span class="tok-kw">break</span> :brk this.len() - <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(-index_end));</span>
<span class="line" id="L1607">            }</span>
<span class="line" id="L1608">        };</span>
<span class="line" id="L1609">        <span class="tok-kw">return</span> this._slice(allocator, uindex_start, uindex_end);</span>
<span class="line" id="L1610">    }</span>
<span class="line" id="L1611"></span>
<span class="line" id="L1612">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">sliceWithStartOnly</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, index_start: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1613">        <span class="tok-kw">return</span> this.slice(allocator, index_start, <span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(this.len())));</span>
<span class="line" id="L1614">    }</span>
<span class="line" id="L1615"></span>
<span class="line" id="L1616">    <span class="tok-kw">fn</span> <span class="tok-fn">_slice</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator, index_start: <span class="tok-type">usize</span>, index_end: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1617">        <span class="tok-kw">if</span> (index_start &gt;= index_end <span class="tok-kw">or</span> index_start &gt;= this.len()) {</span>
<span class="line" id="L1618">            <span class="tok-kw">return</span> JStringUnmanaged.newEmpty(allocator);</span>
<span class="line" id="L1619">        }</span>
<span class="line" id="L1620">        <span class="tok-kw">const</span> valid_index_end = <span class="tok-kw">if</span> (index_end &gt; this.len()) this.len() <span class="tok-kw">else</span> index_end;</span>
<span class="line" id="L1621">        <span class="tok-kw">return</span> JStringUnmanaged.newFromSlice(allocator, this.str_slice[index_start..valid_index_end]);</span>
<span class="line" id="L1622">    }</span>
<span class="line" id="L1623"></span>
<span class="line" id="L1624">    <span class="tok-comment">// ** split</span>
</span>
<span class="line" id="L1625"></span>
<span class="line" id="L1626">    <span class="tok-comment">/// pay attention that this function will not consider spaces in non-ascii.</span></span>
<span class="line" id="L1627">    <span class="tok-kw">fn</span> <span class="tok-fn">_splitToUtf8Chars</span>(this: *JStringUnmanaged, allocator: std.mem.Allocator, limit: <span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> with_spaces: <span class="tok-type">bool</span>) <span class="tok-type">anyerror</span>![]JStringUnmanaged {</span>
<span class="line" id="L1628">        <span class="tok-kw">if</span> (limit == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1629">            <span class="tok-kw">return</span> <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, <span class="tok-number">0</span>);</span>
<span class="line" id="L1630">        }</span>
<span class="line" id="L1631"></span>
<span class="line" id="L1632">        <span class="tok-kw">var</span> result_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1633">        <span class="tok-kw">const</span> utf8_len = <span class="tok-kw">try</span> this.utf8Len(); <span class="tok-comment">// force for a utf8_view</span>
</span>
<span class="line" id="L1634">        <span class="tok-kw">const</span> real_limit = <span class="tok-kw">if</span> (limit &lt; utf8_len) limit <span class="tok-kw">else</span> utf8_len;</span>
<span class="line" id="L1635">        <span class="tok-kw">var</span> result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, real_limit);</span>
<span class="line" id="L1636">        <span class="tok-kw">var</span> it = <span class="tok-kw">try</span> this.utf8Iterator();</span>
<span class="line" id="L1637">        <span class="tok-kw">while</span> (it.nextCodepoint()) |code_point| {</span>
<span class="line" id="L1638">            <span class="tok-kw">if</span> (with_spaces) {</span>
<span class="line" id="L1639">                result_jstrings[result_count] = <span class="tok-kw">try</span> JStringUnmanaged.newFromFormat(allocator, <span class="tok-str">&quot;{u}&quot;</span>, .{code_point});</span>
<span class="line" id="L1640">                result_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1641">                <span class="tok-kw">if</span> (result_count &gt;= real_limit) {</span>
<span class="line" id="L1642">                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L1643">                }</span>
<span class="line" id="L1644">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1645">                <span class="tok-kw">switch</span> (code_point) {</span>
<span class="line" id="L1646">                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\n'</span>, <span class="tok-str">'\r'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1647">                    <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L1648">                        result_jstrings[result_count] = <span class="tok-kw">try</span> JStringUnmanaged.newFromFormat(allocator, <span class="tok-str">&quot;{u}&quot;</span>, .{code_point});</span>
<span class="line" id="L1649">                        result_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1650">                        <span class="tok-kw">if</span> (result_count &gt;= real_limit) {</span>
<span class="line" id="L1651">                            <span class="tok-kw">break</span>;</span>
<span class="line" id="L1652">                        }</span>
<span class="line" id="L1653">                    },</span>
<span class="line" id="L1654">                }</span>
<span class="line" id="L1655">            }</span>
<span class="line" id="L1656">        }</span>
<span class="line" id="L1657"></span>
<span class="line" id="L1658">        <span class="tok-kw">if</span> (result_count == real_limit) {</span>
<span class="line" id="L1659">            <span class="tok-kw">return</span> result_jstrings;</span>
<span class="line" id="L1660">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1661">            <span class="tok-kw">defer</span> allocator.free(result_jstrings);</span>
<span class="line" id="L1662">            <span class="tok-kw">var</span> final_result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, result_count);</span>
<span class="line" id="L1663">            _ = &amp;final_result_jstrings;</span>
<span class="line" id="L1664">            <span class="tok-kw">if</span> (result_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1665">                <span class="tok-builtin">@memcpy</span>(final_result_jstrings, result_jstrings[<span class="tok-number">0</span>..result_count]);</span>
<span class="line" id="L1666">            }</span>
<span class="line" id="L1667">            <span class="tok-kw">return</span> final_result_jstrings;</span>
<span class="line" id="L1668">        }</span>
<span class="line" id="L1669">    }</span>
<span class="line" id="L1670"></span>
<span class="line" id="L1671">    <span class="tok-comment">/// split by simple seperator([]const u8). If you need to split by white spaces, use `splitByWhiteSpace`, or</span></span>
<span class="line" id="L1672">    <span class="tok-comment">/// even more advanced `splitByRegex` (need to enable pcre support). Given limit negative value to split any many</span></span>
<span class="line" id="L1673">    <span class="tok-comment">/// as possible.</span></span>
<span class="line" id="L1674">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">split</span>(this: *JStringUnmanaged, allocator: std.mem.Allocator, seperator: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JStringUnmanaged {</span>
<span class="line" id="L1675">        <span class="tok-kw">const</span> real_limit = brk: {</span>
<span class="line" id="L1676">            <span class="tok-kw">if</span> (limit &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1677">                <span class="tok-kw">break</span> :brk this.str_slice.len;</span>
<span class="line" id="L1678">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1679">                <span class="tok-kw">break</span> :brk <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(limit));</span>
<span class="line" id="L1680">            }</span>
<span class="line" id="L1681">        };</span>
<span class="line" id="L1682"></span>
<span class="line" id="L1683">        <span class="tok-kw">if</span> (seperator.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1684">            <span class="tok-comment">// Well this is quite stupid, but let us still try to cover it.</span>
</span>
<span class="line" id="L1685">            <span class="tok-kw">return</span> this._splitToUtf8Chars(allocator, <span class="tok-kw">if</span> (real_limit &lt; this.str_slice.len) real_limit <span class="tok-kw">else</span> this.str_slice.len, <span class="tok-null">true</span>);</span>
<span class="line" id="L1686">        }</span>
<span class="line" id="L1687"></span>
<span class="line" id="L1688">        <span class="tok-kw">var</span> result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, real_limit);</span>
<span class="line" id="L1689">        <span class="tok-kw">var</span> result_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1690">        <span class="tok-kw">var</span> search_start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1691">        <span class="tok-kw">var</span> pos: <span class="tok-type">isize</span> = -<span class="tok-number">1</span>;</span>
<span class="line" id="L1692">        <span class="tok-kw">while</span> (search_start &lt; this.str_slice.len) {</span>
<span class="line" id="L1693">            pos = this.indexOf(seperator, search_start);</span>
<span class="line" id="L1694">            <span class="tok-kw">if</span> (pos &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1695">                <span class="tok-kw">if</span> (result_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1696">                    <span class="tok-comment">// have found one, the what's left is rest part</span>
</span>
<span class="line" id="L1697">                    result_jstrings[result_count] = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(allocator, this.str_slice[search_start..]);</span>
<span class="line" id="L1698">                    result_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1699">                }</span>
<span class="line" id="L1700">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1701">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1702">                result_jstrings[result_count] = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(allocator, this.str_slice[search_start..<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(pos))]);</span>
<span class="line" id="L1703">                result_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1704">                <span class="tok-kw">if</span> (result_count &gt;= real_limit) {</span>
<span class="line" id="L1705">                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L1706">                }</span>
<span class="line" id="L1707">                search_start = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(pos)) + seperator.len;</span>
<span class="line" id="L1708">                <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1709">            }</span>
<span class="line" id="L1710">        }</span>
<span class="line" id="L1711"></span>
<span class="line" id="L1712">        <span class="tok-kw">if</span> (result_count == real_limit) {</span>
<span class="line" id="L1713">            <span class="tok-comment">// save the copy as all buf filled</span>
</span>
<span class="line" id="L1714">            <span class="tok-kw">return</span> result_jstrings;</span>
<span class="line" id="L1715">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1716">            <span class="tok-kw">defer</span> allocator.free(result_jstrings);</span>
<span class="line" id="L1717">            <span class="tok-kw">var</span> final_result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, result_count);</span>
<span class="line" id="L1718">            _ = &amp;final_result_jstrings;</span>
<span class="line" id="L1719">            <span class="tok-kw">if</span> (result_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1720">                <span class="tok-builtin">@memcpy</span>(final_result_jstrings, result_jstrings[<span class="tok-number">0</span>..result_count]);</span>
<span class="line" id="L1721">            }</span>
<span class="line" id="L1722">            <span class="tok-kw">return</span> final_result_jstrings;</span>
<span class="line" id="L1723">        }</span>
<span class="line" id="L1724">    }</span>
<span class="line" id="L1725"></span>
<span class="line" id="L1726">    <span class="tok-comment">/// Split by ascii whitespaces (&quot; \t\n\r&quot;), or called explode in languages like PHP (which is the best language! :))</span></span>
<span class="line" id="L1727">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitByWhiteSpace</span>(this: *JStringUnmanaged, allocator: std.mem.Allocator, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JStringUnmanaged {</span>
<span class="line" id="L1728">        <span class="tok-kw">return</span> this.explode(allocator, limit);</span>
<span class="line" id="L1729">    }</span>
<span class="line" id="L1730"></span>
<span class="line" id="L1731">    <span class="tok-comment">/// Split based on regex matching. With greate power comes great responsibility.</span></span>
<span class="line" id="L1732">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">splitByRegex</span>(this: *JStringUnmanaged, allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset: <span class="tok-type">usize</span>, limit: <span class="tok-type">isize</span>) <span class="tok-type">anyerror</span>![]JStringUnmanaged {</span>
<span class="line" id="L1733">        <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L1734">            <span class="tok-kw">const</span> real_limit = brk: {</span>
<span class="line" id="L1735">                <span class="tok-kw">if</span> (limit &lt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1736">                    <span class="tok-comment">// most will be +1, like &quot;hello&quot;.split(/./) =&gt; (6)['', '', '', '', '', '']</span>
</span>
<span class="line" id="L1737">                    <span class="tok-kw">break</span> :brk this.str_slice.len + <span class="tok-number">1</span>;</span>
<span class="line" id="L1738">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1739">                    <span class="tok-kw">break</span> :brk <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(limit));</span>
<span class="line" id="L1740">                }</span>
<span class="line" id="L1741">            };</span>
<span class="line" id="L1742">            <span class="tok-kw">if</span> (real_limit == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1743">                <span class="tok-kw">return</span> this._cloneAsArray(allocator);</span>
<span class="line" id="L1744">            }</span>
<span class="line" id="L1745"></span>
<span class="line" id="L1746">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(allocator, pattern, RegexUnmanaged.DefaultRegexOptions);</span>
<span class="line" id="L1747">            <span class="tok-kw">try</span> re.matchAll(allocator, this.str_slice, offset, RegexUnmanaged.DefaultMatchOptions);</span>
<span class="line" id="L1748">            <span class="tok-kw">if</span> (re.succeed() <span class="tok-kw">and</span> re.matchSucceed()) {</span>
<span class="line" id="L1749">                <span class="tok-kw">var</span> first_gap_start_from_zero = <span class="tok-null">false</span>;</span>
<span class="line" id="L1750">                <span class="tok-kw">var</span> last_gap_end_in_end = <span class="tok-null">false</span>;</span>
<span class="line" id="L1751">                <span class="tok-kw">const</span> gap_count = brk: {</span>
<span class="line" id="L1752">                    <span class="tok-comment">// stupid method, scan once to know how many gaps we have</span>
</span>
<span class="line" id="L1753">                    <span class="tok-comment">// but since this helps us to avoid allocation (just mem access)</span>
</span>
<span class="line" id="L1754">                    <span class="tok-comment">// probably it is also fast enough</span>
</span>
<span class="line" id="L1755">                    <span class="tok-kw">var</span> gap_it = _MatchedGapIterator.init(&amp;re, this.str_slice);</span>
<span class="line" id="L1756">                    <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1757">                    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> gap_it.nextGap()) |g| {</span>
<span class="line" id="L1758">                        <span class="tok-kw">if</span> (g.start == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1759">                            <span class="tok-comment">// gap is not overlapping, so simply check every one,</span>
</span>
<span class="line" id="L1760">                            <span class="tok-comment">// there must be one at most start at 0</span>
</span>
<span class="line" id="L1761">                            first_gap_start_from_zero = <span class="tok-null">true</span>;</span>
<span class="line" id="L1762">                        }</span>
<span class="line" id="L1763">                        <span class="tok-kw">if</span> (g.start + g.len == this.str_slice.len) {</span>
<span class="line" id="L1764">                            <span class="tok-comment">// same idea, must be at most one end at the end</span>
</span>
<span class="line" id="L1765">                            last_gap_end_in_end = <span class="tok-null">true</span>;</span>
<span class="line" id="L1766">                        }</span>
<span class="line" id="L1767">                        count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1768">                    }</span>
<span class="line" id="L1769">                    <span class="tok-kw">break</span> :brk count;</span>
<span class="line" id="L1770">                };</span>
<span class="line" id="L1771">                <span class="tok-kw">const</span> jstrings_count = brk2: {</span>
<span class="line" id="L1772">                    <span class="tok-kw">const</span> count_by_gap = brk: {</span>
<span class="line" id="L1773">                        <span class="tok-kw">if</span> (first_gap_start_from_zero <span class="tok-kw">and</span> last_gap_end_in_end) {</span>
<span class="line" id="L1774">                            <span class="tok-comment">// |&lt;gap&gt;..&lt;gap&gt;..&lt;gap&gt;|</span>
</span>
<span class="line" id="L1775">                            <span class="tok-kw">break</span> :brk gap_count + <span class="tok-number">1</span>;</span>
<span class="line" id="L1776">                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_gap_start_from_zero) {</span>
<span class="line" id="L1777">                            <span class="tok-comment">// |&lt;gap&gt;..&lt;gap&gt;..|</span>
</span>
<span class="line" id="L1778">                            <span class="tok-kw">break</span> :brk gap_count + <span class="tok-number">1</span>;</span>
<span class="line" id="L1779">                        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (last_gap_end_in_end) {</span>
<span class="line" id="L1780">                            <span class="tok-comment">// |..&lt;gap&gt;..&lt;gap&gt;|</span>
</span>
<span class="line" id="L1781">                            <span class="tok-kw">break</span> :brk gap_count;</span>
<span class="line" id="L1782">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1783">                            <span class="tok-comment">// |..&lt;gap&gt;..&lt;gap&gt;..&lt;gap&gt;..|</span>
</span>
<span class="line" id="L1784">                            <span class="tok-kw">break</span> :brk gap_count + <span class="tok-number">1</span>;</span>
<span class="line" id="L1785">                        }</span>
<span class="line" id="L1786">                    };</span>
<span class="line" id="L1787">                    <span class="tok-kw">break</span> :brk2 <span class="tok-kw">if</span> (real_limit &lt; count_by_gap) real_limit <span class="tok-kw">else</span> count_by_gap;</span>
<span class="line" id="L1788">                };</span>
<span class="line" id="L1789">                <span class="tok-kw">var</span> result_jstrings = <span class="tok-kw">try</span> allocator.alloc(JStringUnmanaged, jstrings_count);</span>
<span class="line" id="L1790">                <span class="tok-kw">var</span> count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1791">                <span class="tok-kw">var</span> slice_offset: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1792">                <span class="tok-kw">var</span> gap_it = _MatchedGapIterator.init(&amp;re, this.str_slice);</span>
<span class="line" id="L1793">                <span class="tok-kw">while</span> (<span class="tok-kw">try</span> gap_it.nextGap()) |g| {</span>
<span class="line" id="L1794">                    <span class="tok-kw">if</span> (count &gt;= jstrings_count) {</span>
<span class="line" id="L1795">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1796">                    }</span>
<span class="line" id="L1797">                    <span class="tok-comment">// |&lt;gap&gt;..&lt;gap&gt;..| or</span>
</span>
<span class="line" id="L1798">                    <span class="tok-comment">// |..&lt;gap&gt;..&lt;gap&gt;| or |..&lt;gap&gt;..&lt;gap&gt;..&lt;gap&gt;..|</span>
</span>
<span class="line" id="L1799">                    <span class="tok-comment">// no matter what, we can do this</span>
</span>
<span class="line" id="L1800">                    result_jstrings[count] = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(allocator, this.str_slice[slice_offset..g.start]);</span>
<span class="line" id="L1801">                    slice_offset = g.start + g.len;</span>
<span class="line" id="L1802">                    count += <span class="tok-number">1</span>;</span>
<span class="line" id="L1803">                }</span>
<span class="line" id="L1804">                <span class="tok-kw">if</span> (count &lt; jstrings_count) {</span>
<span class="line" id="L1805">                    <span class="tok-comment">// |&lt;gap&gt;| or |..&lt;gap&gt;..&lt;gap&gt;..&lt;gap&gt;..| or |&lt;gap&gt;..&lt;gap&gt;..|</span>
</span>
<span class="line" id="L1806">                    <span class="tok-comment">// still missing one so get the last piece done</span>
</span>
<span class="line" id="L1807">                    result_jstrings[count] = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(allocator, this.str_slice[slice_offset..]);</span>
<span class="line" id="L1808">                }</span>
<span class="line" id="L1809">                <span class="tok-kw">return</span> result_jstrings;</span>
<span class="line" id="L1810">            } <span class="tok-kw">else</span> <span class="tok-kw">return</span> JStringError.RegexMatchFailed;</span>
<span class="line" id="L1811">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1812">            <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L1813">        }</span>
<span class="line" id="L1814">    }</span>
<span class="line" id="L1815"></span>
<span class="line" id="L1816">    <span class="tok-comment">// ** startsWith</span>
</span>
<span class="line" id="L1817"></span>
<span class="line" id="L1818">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">startsWith</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, prefix: JStringUnmanaged) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1819">        <span class="tok-kw">return</span> this.startsWithSlice(prefix.str_slice);</span>
<span class="line" id="L1820">    }</span>
<span class="line" id="L1821"></span>
<span class="line" id="L1822">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">startsWithSlice</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, prefix_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1823">        <span class="tok-kw">if</span> (this.len() &lt; prefix_slice.len) {</span>
<span class="line" id="L1824">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L1825">        }</span>
<span class="line" id="L1826">        <span class="tok-kw">return</span> std.mem.eql(<span class="tok-type">u8</span>, this.str_slice[<span class="tok-number">0</span>..prefix_slice.len], prefix_slice);</span>
<span class="line" id="L1827">    }</span>
<span class="line" id="L1828"></span>
<span class="line" id="L1829">    <span class="tok-comment">// ** toLocaleLowerCase</span>
</span>
<span class="line" id="L1830"></span>
<span class="line" id="L1831">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLocaleLowerCase</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1832">        _ = this;</span>
<span class="line" id="L1833">        _ = allocator;</span>
<span class="line" id="L1834">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO, not yet implemented!&quot;</span>);</span>
<span class="line" id="L1835">    }</span>
<span class="line" id="L1836"></span>
<span class="line" id="L1837">    <span class="tok-comment">// ** toLocaleUpperCase</span>
</span>
<span class="line" id="L1838"></span>
<span class="line" id="L1839">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLocalUpperCase</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1840">        _ = this;</span>
<span class="line" id="L1841">        _ = allocator;</span>
<span class="line" id="L1842">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;TODO, not yet implemented!&quot;</span>);</span>
<span class="line" id="L1843">    }</span>
<span class="line" id="L1844"></span>
<span class="line" id="L1845">    <span class="tok-comment">// ** toLowerCase</span>
</span>
<span class="line" id="L1846"></span>
<span class="line" id="L1847">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toLowerCase</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1848">        <span class="tok-kw">if</span> (this.len() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1849">            <span class="tok-kw">return</span> JStringUnmanaged.newEmpty(allocator);</span>
<span class="line" id="L1850">        }</span>
<span class="line" id="L1851"></span>
<span class="line" id="L1852">        <span class="tok-kw">var</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, this.str_slice.len);</span>
<span class="line" id="L1853">        <span class="tok-builtin">@memcpy</span>(new_slice, this.str_slice);</span>
<span class="line" id="L1854">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1855">        <span class="tok-kw">while</span> (i &lt; new_slice.len) {</span>
<span class="line" id="L1856">            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> std.unicode.utf8ByteSequenceLength(new_slice[i]);</span>
<span class="line" id="L1857">            <span class="tok-kw">if</span> (size == <span class="tok-number">1</span>) {</span>
<span class="line" id="L1858">                new_slice[i] = std.ascii.toLower(new_slice[i]);</span>
<span class="line" id="L1859">            }</span>
<span class="line" id="L1860">            i += size;</span>
<span class="line" id="L1861">        }</span>
<span class="line" id="L1862">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1863">            .str_slice = new_slice,</span>
<span class="line" id="L1864">        };</span>
<span class="line" id="L1865">    }</span>
<span class="line" id="L1866"></span>
<span class="line" id="L1867">    <span class="tok-comment">// ** toUpperCase</span>
</span>
<span class="line" id="L1868"></span>
<span class="line" id="L1869">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toUpperCase</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1870">        <span class="tok-kw">if</span> (this.len() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1871">            <span class="tok-kw">return</span> JStringUnmanaged.newEmpty(allocator);</span>
<span class="line" id="L1872">        }</span>
<span class="line" id="L1873"></span>
<span class="line" id="L1874">        <span class="tok-kw">var</span> new_slice = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, this.str_slice.len);</span>
<span class="line" id="L1875">        <span class="tok-builtin">@memcpy</span>(new_slice, this.str_slice);</span>
<span class="line" id="L1876">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1877">        <span class="tok-kw">while</span> (i &lt; new_slice.len) {</span>
<span class="line" id="L1878">            <span class="tok-kw">const</span> size = <span class="tok-kw">try</span> std.unicode.utf8ByteSequenceLength(new_slice[i]);</span>
<span class="line" id="L1879">            <span class="tok-kw">if</span> (size == <span class="tok-number">1</span>) {</span>
<span class="line" id="L1880">                new_slice[i] = std.ascii.toUpper(new_slice[i]);</span>
<span class="line" id="L1881">            }</span>
<span class="line" id="L1882">            i += size;</span>
<span class="line" id="L1883">        }</span>
<span class="line" id="L1884">        <span class="tok-kw">return</span> JStringUnmanaged{</span>
<span class="line" id="L1885">            .str_slice = new_slice,</span>
<span class="line" id="L1886">        };</span>
<span class="line" id="L1887">    }</span>
<span class="line" id="L1888"></span>
<span class="line" id="L1889">    <span class="tok-comment">// ** toWellFormed</span>
</span>
<span class="line" id="L1890"></span>
<span class="line" id="L1891">    <span class="tok-comment">/// toWellFormed does not make sense in zig as zig is u8/utf8 based. No need to use this.</span></span>
<span class="line" id="L1892">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">toWellFormed</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) <span class="tok-type">void</span> {</span>
<span class="line" id="L1893">        _ = this;</span>
<span class="line" id="L1894">        <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;toWellFormed does not make sense in zig as zig is u8/utf8 based. No need to use this.&quot;</span>);</span>
<span class="line" id="L1895">    }</span>
<span class="line" id="L1896"></span>
<span class="line" id="L1897">    <span class="tok-comment">// ** trim</span>
</span>
<span class="line" id="L1898"></span>
<span class="line" id="L1899">    <span class="tok-comment">/// essentially =trimStart(trimEnd()). All temp strings produced in steps are deinited.</span></span>
<span class="line" id="L1900">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trim</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1901">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> this.trimStart(allocator);</span>
<span class="line" id="L1902">        <span class="tok-kw">if</span> (str1.len() == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1903">            <span class="tok-kw">return</span> str1;</span>
<span class="line" id="L1904">        }</span>
<span class="line" id="L1905">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.trimEnd(allocator);</span>
<span class="line" id="L1906">        <span class="tok-kw">defer</span> str1.deinit(allocator);</span>
<span class="line" id="L1907">        <span class="tok-kw">return</span> str2;</span>
<span class="line" id="L1908">    }</span>
<span class="line" id="L1909"></span>
<span class="line" id="L1910">    <span class="tok-comment">// ** trimEnd</span>
</span>
<span class="line" id="L1911"></span>
<span class="line" id="L1912">    <span class="tok-comment">/// trim blank chars(' ', '\t', '\n' and '\r') from the end. If there is nothing to trim it will return a clone of</span></span>
<span class="line" id="L1913">    <span class="tok-comment">/// original string.</span></span>
<span class="line" id="L1914">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimEnd</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1915">        <span class="tok-kw">const</span> first_nonblank = brk: {</span>
<span class="line" id="L1916">            <span class="tok-kw">var</span> i = this.str_slice.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L1917">            <span class="tok-kw">while</span> (i &gt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L1918">                <span class="tok-kw">switch</span> (this.str_slice[i]) {</span>
<span class="line" id="L1919">                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\n'</span>, <span class="tok-str">'\r'</span> =&gt; {</span>
<span class="line" id="L1920">                        <span class="tok-kw">if</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1921">                            i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1922">                            <span class="tok-kw">continue</span>;</span>
<span class="line" id="L1923">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1924">                            <span class="tok-kw">break</span> :brk <span class="tok-number">0</span>;</span>
<span class="line" id="L1925">                        }</span>
<span class="line" id="L1926">                    },</span>
<span class="line" id="L1927">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :brk i,</span>
<span class="line" id="L1928">                }</span>
<span class="line" id="L1929">            }</span>
<span class="line" id="L1930">            <span class="tok-kw">break</span> :brk <span class="tok-number">0</span>;</span>
<span class="line" id="L1931">        };</span>
<span class="line" id="L1932">        <span class="tok-kw">if</span> (first_nonblank == this.str_slice.len - <span class="tok-number">1</span>) {</span>
<span class="line" id="L1933">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1934">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (first_nonblank == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1935">            <span class="tok-kw">return</span> JStringUnmanaged.newEmpty(allocator);</span>
<span class="line" id="L1936">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1937">            <span class="tok-kw">const</span> new_slice = this.str_slice[<span class="tok-number">0</span> .. first_nonblank + <span class="tok-number">1</span>];</span>
<span class="line" id="L1938">            <span class="tok-kw">return</span> JStringUnmanaged.newFromSlice(allocator, new_slice);</span>
<span class="line" id="L1939">        }</span>
<span class="line" id="L1940">    }</span>
<span class="line" id="L1941"></span>
<span class="line" id="L1942">    <span class="tok-comment">// ** trimStart</span>
</span>
<span class="line" id="L1943"></span>
<span class="line" id="L1944">    <span class="tok-comment">/// trim blank chars(' ', '\t', '\n' and '\r') from beginning. If there is nothing to trim it will return a clone</span></span>
<span class="line" id="L1945">    <span class="tok-comment">/// of original string.</span></span>
<span class="line" id="L1946">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">trimStart</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!JStringUnmanaged {</span>
<span class="line" id="L1947">        <span class="tok-kw">const</span> first_nonblank = brk: {</span>
<span class="line" id="L1948">            <span class="tok-kw">for</span> (this.str_slice, <span class="tok-number">0</span>..) |char, i| {</span>
<span class="line" id="L1949">                <span class="tok-kw">switch</span> (char) {</span>
<span class="line" id="L1950">                    <span class="tok-str">' '</span>, <span class="tok-str">'\t'</span>, <span class="tok-str">'\n'</span>, <span class="tok-str">'\r'</span> =&gt; <span class="tok-kw">continue</span>,</span>
<span class="line" id="L1951">                    <span class="tok-kw">else</span> =&gt; <span class="tok-kw">break</span> :brk i,</span>
<span class="line" id="L1952">                }</span>
<span class="line" id="L1953">            }</span>
<span class="line" id="L1954">            <span class="tok-kw">break</span> :brk this.len();</span>
<span class="line" id="L1955">        };</span>
<span class="line" id="L1956">        <span class="tok-kw">if</span> (first_nonblank == <span class="tok-number">0</span>) {</span>
<span class="line" id="L1957">            <span class="tok-kw">return</span> this.clone(allocator);</span>
<span class="line" id="L1958">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1959">            <span class="tok-kw">const</span> new_slice = this.str_slice[first_nonblank..];</span>
<span class="line" id="L1960">            <span class="tok-kw">return</span> JStringUnmanaged.newFromSlice(allocator, new_slice);</span>
<span class="line" id="L1961">        }</span>
<span class="line" id="L1962">    }</span>
<span class="line" id="L1963"></span>
<span class="line" id="L1964">    <span class="tok-comment">// ** valueOf</span>
</span>
<span class="line" id="L1965"></span>
<span class="line" id="L1966">    <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">valueOf</span>(this: *<span class="tok-kw">const</span> JStringUnmanaged) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1967">        <span class="tok-kw">return</span> this.str_slice;</span>
<span class="line" id="L1968">    }</span>
<span class="line" id="L1969">};</span>
<span class="line" id="L1970"></span>
<span class="line" id="L1971"><span class="tok-comment">// util functions</span>
</span>
<span class="line" id="L1972"></span>
<span class="line" id="L1973"><span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">freeJStringArray</span>(a: []JString) <span class="tok-type">void</span> {</span>
<span class="line" id="L1974">    <span class="tok-kw">if</span> (a.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1975">        <span class="tok-kw">const</span> allocator = a[<span class="tok-number">0</span>].allocator;</span>
<span class="line" id="L1976">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..a.len) |i| a[i].deinit();</span>
<span class="line" id="L1977">        allocator.free(a);</span>
<span class="line" id="L1978">    }</span>
<span class="line" id="L1979">}</span>
<span class="line" id="L1980"></span>
<span class="line" id="L1981"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">freeJStringUnmanagedArray</span>(allocator: std.mem.Allocator, a: []JStringUnmanaged) <span class="tok-type">void</span> {</span>
<span class="line" id="L1982">    <span class="tok-kw">if</span> (a.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1983">        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..a.len) |i| a[i].deinit(allocator);</span>
<span class="line" id="L1984">        allocator.free(a);</span>
<span class="line" id="L1985">    }</span>
<span class="line" id="L1986">}</span>
<span class="line" id="L1987"></span>
<span class="line" id="L1988"><span class="tok-comment">// optional components</span>
</span>
<span class="line" id="L1989"></span>
<span class="line" id="L1990"><span class="tok-kw">fn</span> <span class="tok-fn">defineArenaAllocator</span>(<span class="tok-kw">comptime</span> enable: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L1991">    <span class="tok-kw">if</span> (enable) {</span>
<span class="line" id="L1992">        <span class="tok-comment">// A copy of zig's std.heap.ArenaAllocator for possibility to optimise for string usage.</span>
</span>
<span class="line" id="L1993">        <span class="tok-comment">// This allocator takes an existing allocator, wraps it, and provides an</span>
</span>
<span class="line" id="L1994">        <span class="tok-comment">// interface where you can allocate without freeing, and then free it all</span>
</span>
<span class="line" id="L1995">        <span class="tok-comment">// together.</span>
</span>
<span class="line" id="L1996">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L1997">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L1998"></span>
<span class="line" id="L1999">            child_allocator: std.mem.Allocator,</span>
<span class="line" id="L2000">            state: State,</span>
<span class="line" id="L2001"></span>
<span class="line" id="L2002">            <span class="tok-comment">/// Inner state of ArenaAllocator. Can be stored rather than the entire ArenaAllocator</span></span>
<span class="line" id="L2003">            <span class="tok-comment">/// as a memory-saving optimization.</span></span>
<span class="line" id="L2004">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> State = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2005">                buffer_list: std.SinglyLinkedList(<span class="tok-type">usize</span>) = .{},</span>
<span class="line" id="L2006">                end_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>, <span class="tok-comment">// the next addr to write in cur_buf</span>
</span>
<span class="line" id="L2007"></span>
<span class="line" id="L2008">                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">promote</span>(self: State, child_allocator: std.mem.Allocator) Self {</span>
<span class="line" id="L2009">                    <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2010">                        .child_allocator = child_allocator,</span>
<span class="line" id="L2011">                        .state = self,</span>
<span class="line" id="L2012">                    };</span>
<span class="line" id="L2013">                }</span>
<span class="line" id="L2014">            };</span>
<span class="line" id="L2015"></span>
<span class="line" id="L2016">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">allocator</span>(self: *Self) std.mem.Allocator {</span>
<span class="line" id="L2017">                <span class="tok-kw">return</span> .{</span>
<span class="line" id="L2018">                    .ptr = self,</span>
<span class="line" id="L2019">                    .vtable = &amp;.{</span>
<span class="line" id="L2020">                        .alloc = alloc,</span>
<span class="line" id="L2021">                        .resize = resize,</span>
<span class="line" id="L2022">                        .free = free,</span>
<span class="line" id="L2023">                    },</span>
<span class="line" id="L2024">                };</span>
<span class="line" id="L2025">            }</span>
<span class="line" id="L2026"></span>
<span class="line" id="L2027">            <span class="tok-kw">const</span> BufNode = std.SinglyLinkedList(<span class="tok-type">usize</span>).Node;</span>
<span class="line" id="L2028"></span>
<span class="line" id="L2029">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(child_allocator: std.mem.Allocator) Self {</span>
<span class="line" id="L2030">                <span class="tok-kw">return</span> (State{}).promote(child_allocator);</span>
<span class="line" id="L2031">            }</span>
<span class="line" id="L2032"></span>
<span class="line" id="L2033">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(self: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L2034">                <span class="tok-comment">// NOTE: When changing this, make sure `reset()` is adjusted accordingly!</span>
</span>
<span class="line" id="L2035">                <span class="tok-kw">var</span> it = self.state.buffer_list.first;</span>
<span class="line" id="L2036">                <span class="tok-kw">while</span> (it) |node| {</span>
<span class="line" id="L2037">                    <span class="tok-comment">// this has to occur before the free because the free frees node</span>
</span>
<span class="line" id="L2038">                    <span class="tok-kw">const</span> next_it = node.next;</span>
<span class="line" id="L2039">                    <span class="tok-kw">const</span> align_bits = std.math.log2_int(<span class="tok-type">usize</span>, <span class="tok-builtin">@alignOf</span>(BufNode));</span>
<span class="line" id="L2040">                    <span class="tok-kw">const</span> alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(node))[<span class="tok-number">0</span>..node.data];</span>
<span class="line" id="L2041">                    self.child_allocator.rawFree(alloc_buf, align_bits, <span class="tok-builtin">@returnAddress</span>());</span>
<span class="line" id="L2042">                    it = next_it;</span>
<span class="line" id="L2043">                }</span>
<span class="line" id="L2044">            }</span>
<span class="line" id="L2045"></span>
<span class="line" id="L2046">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> ResetMode = <span class="tok-kw">union</span>(<span class="tok-kw">enum</span>) {</span>
<span class="line" id="L2047">                <span class="tok-comment">/// Releases all allocated memory in the arena.</span></span>
<span class="line" id="L2048">                free_all,</span>
<span class="line" id="L2049">                <span class="tok-comment">/// This will pre-heat the arena for future allocations by allocating a</span></span>
<span class="line" id="L2050">                <span class="tok-comment">/// large enough buffer for all previously done allocations.</span></span>
<span class="line" id="L2051">                <span class="tok-comment">/// Preheating will speed up the allocation process by invoking the</span></span>
<span class="line" id="L2052">                <span class="tok-comment">/// backing allocator less often than before. If `reset()` is used in a</span></span>
<span class="line" id="L2053">                <span class="tok-comment">/// loop, this means that after the biggest operation, no memory</span></span>
<span class="line" id="L2054">                <span class="tok-comment">/// allocations are performed anymore.</span></span>
<span class="line" id="L2055">                retain_capacity,</span>
<span class="line" id="L2056">                <span class="tok-comment">/// This is the same as `retain_capacity`, but the memory will be shrunk</span></span>
<span class="line" id="L2057">                <span class="tok-comment">/// to this value if it exceeds the limit.</span></span>
<span class="line" id="L2058">                retain_with_limit: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2059">            };</span>
<span class="line" id="L2060"></span>
<span class="line" id="L2061">            <span class="tok-comment">/// Queries the current memory use of this arena.</span></span>
<span class="line" id="L2062">            <span class="tok-comment">/// This will **not** include the storage required for internal keeping.</span></span>
<span class="line" id="L2063">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">queryCapacity</span>(self: Self) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2064">                <span class="tok-kw">var</span> size: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2065">                <span class="tok-kw">var</span> it = self.state.buffer_list.first;</span>
<span class="line" id="L2066">                <span class="tok-kw">while</span> (it) |node| : (it = node.next) {</span>
<span class="line" id="L2067">                    <span class="tok-comment">// Compute the actually allocated size excluding the</span>
</span>
<span class="line" id="L2068">                    <span class="tok-comment">// linked list node.</span>
</span>
<span class="line" id="L2069">                    size += node.data - <span class="tok-builtin">@sizeOf</span>(BufNode);</span>
<span class="line" id="L2070">                }</span>
<span class="line" id="L2071">                <span class="tok-kw">return</span> size;</span>
<span class="line" id="L2072">            }</span>
<span class="line" id="L2073"></span>
<span class="line" id="L2074">            <span class="tok-comment">/// Resets the arena allocator and frees all allocated memory.</span></span>
<span class="line" id="L2075">            <span class="tok-comment">///</span></span>
<span class="line" id="L2076">            <span class="tok-comment">/// `mode` defines how the currently allocated memory is handled.</span></span>
<span class="line" id="L2077">            <span class="tok-comment">/// See the variant documentation for `ResetMode` for the effects of each mode.</span></span>
<span class="line" id="L2078">            <span class="tok-comment">///</span></span>
<span class="line" id="L2079">            <span class="tok-comment">/// The function will return whether the reset operation was successful or not.</span></span>
<span class="line" id="L2080">            <span class="tok-comment">/// If the reallocation  failed `false` is returned. The arena will still be fully</span></span>
<span class="line" id="L2081">            <span class="tok-comment">/// functional in that case, all memory is released. Future allocations just might</span></span>
<span class="line" id="L2082">            <span class="tok-comment">/// be slower.</span></span>
<span class="line" id="L2083">            <span class="tok-comment">///</span></span>
<span class="line" id="L2084">            <span class="tok-comment">/// NOTE: If `mode` is `free_all`, the function will always return `true`.</span></span>
<span class="line" id="L2085">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(self: *Self, mode: ResetMode) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2086">                <span class="tok-comment">// Some words on the implementation:</span>
</span>
<span class="line" id="L2087">                <span class="tok-comment">// The reset function can be implemented with two basic approaches:</span>
</span>
<span class="line" id="L2088">                <span class="tok-comment">// - Counting how much bytes were allocated since the last reset, and storing that</span>
</span>
<span class="line" id="L2089">                <span class="tok-comment">//   information in State. This will make reset fast and alloc only a teeny tiny bit</span>
</span>
<span class="line" id="L2090">                <span class="tok-comment">//   slower.</span>
</span>
<span class="line" id="L2091"></span>
<span class="line" id="L2092">                <span class="tok-comment">// - Counting how much bytes were allocated by iterating the chunk linked list. This</span>
</span>
<span class="line" id="L2093">                <span class="tok-comment">//   will make reset slower, but alloc() keeps the same speed when reset() as if reset()</span>
</span>
<span class="line" id="L2094">                <span class="tok-comment">//   would not exist.</span>
</span>
<span class="line" id="L2095">                <span class="tok-comment">//</span>
</span>
<span class="line" id="L2096"></span>
<span class="line" id="L2097">                <span class="tok-comment">// The second variant was chosen for implementation, as with more and more calls to reset(),</span>
</span>
<span class="line" id="L2098">                <span class="tok-comment">// the function will get faster and faster. At one point, the complexity of the function</span>
</span>
<span class="line" id="L2099">                <span class="tok-comment">// will drop to amortized O(1), as we're only ever having a single chunk that will not be</span>
</span>
<span class="line" id="L2100">                <span class="tok-comment">// reallocated, and we're not even touching the backing allocator anymore.</span>
</span>
<span class="line" id="L2101">                <span class="tok-comment">//</span>
</span>
<span class="line" id="L2102"></span>
<span class="line" id="L2103">                <span class="tok-comment">// Thus, only the first hand full of calls to reset() will actually need to iterate the linked</span>
</span>
<span class="line" id="L2104">                <span class="tok-comment">// list, all future calls are just taking the first node, and only resetting the `end_index`</span>
</span>
<span class="line" id="L2105">                <span class="tok-comment">// value.</span>
</span>
<span class="line" id="L2106"></span>
<span class="line" id="L2107">                <span class="tok-kw">const</span> requested_capacity = <span class="tok-kw">switch</span> (mode) {</span>
<span class="line" id="L2108">                    .retain_capacity =&gt; self.queryCapacity(),</span>
<span class="line" id="L2109">                    .retain_with_limit =&gt; |limit| <span class="tok-builtin">@min</span>(limit, self.queryCapacity()),</span>
<span class="line" id="L2110">                    .free_all =&gt; <span class="tok-number">0</span>,</span>
<span class="line" id="L2111">                };</span>
<span class="line" id="L2112"></span>
<span class="line" id="L2113">                <span class="tok-kw">if</span> (requested_capacity == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2114">                    <span class="tok-comment">// just reset when we don't have anything to reallocate</span>
</span>
<span class="line" id="L2115">                    self.deinit();</span>
<span class="line" id="L2116">                    self.state = State{};</span>
<span class="line" id="L2117">                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2118">                }</span>
<span class="line" id="L2119"></span>
<span class="line" id="L2120">                <span class="tok-kw">const</span> total_size = requested_capacity + <span class="tok-builtin">@sizeOf</span>(BufNode);</span>
<span class="line" id="L2121">                <span class="tok-kw">const</span> align_bits = std.math.log2_int(<span class="tok-type">usize</span>, <span class="tok-builtin">@alignOf</span>(BufNode));</span>
<span class="line" id="L2122">                <span class="tok-comment">// Free all nodes except for the last one</span>
</span>
<span class="line" id="L2123"></span>
<span class="line" id="L2124">                <span class="tok-kw">var</span> it = self.state.buffer_list.first;</span>
<span class="line" id="L2125">                <span class="tok-kw">const</span> maybe_first_node = <span class="tok-kw">while</span> (it) |node| {</span>
<span class="line" id="L2126">                    <span class="tok-comment">// this has to occur before the free because the free frees node</span>
</span>
<span class="line" id="L2127">                    <span class="tok-kw">const</span> next_it = node.next;</span>
<span class="line" id="L2128">                    <span class="tok-kw">if</span> (next_it == <span class="tok-null">null</span>)</span>
<span class="line" id="L2129">                        <span class="tok-kw">break</span> node;</span>
<span class="line" id="L2130">                    <span class="tok-kw">const</span> alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(node))[<span class="tok-number">0</span>..node.data];</span>
<span class="line" id="L2131">                    self.child_allocator.rawFree(alloc_buf, align_bits, <span class="tok-builtin">@returnAddress</span>());</span>
<span class="line" id="L2132">                    it = next_it;</span>
<span class="line" id="L2133">                } <span class="tok-kw">else</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2134">                std.debug.assert(maybe_first_node == <span class="tok-null">null</span> <span class="tok-kw">or</span> maybe_first_node.?.next == <span class="tok-null">null</span>);</span>
<span class="line" id="L2135">                <span class="tok-comment">// reset the state before we try resizing the buffers, so we definitely have reset the arena to 0.</span>
</span>
<span class="line" id="L2136"></span>
<span class="line" id="L2137">                self.state.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L2138">                <span class="tok-kw">if</span> (maybe_first_node) |first_node| {</span>
<span class="line" id="L2139">                    self.state.buffer_list.first = first_node;</span>
<span class="line" id="L2140">                    <span class="tok-comment">// perfect, no need to invoke the child_allocator</span>
</span>
<span class="line" id="L2141">                    <span class="tok-kw">if</span> (first_node.data == total_size)</span>
<span class="line" id="L2142">                        <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2143">                    <span class="tok-kw">const</span> first_alloc_buf = <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(first_node))[<span class="tok-number">0</span>..first_node.data];</span>
<span class="line" id="L2144">                    <span class="tok-kw">if</span> (self.child_allocator.rawResize(first_alloc_buf, align_bits, total_size, <span class="tok-builtin">@returnAddress</span>())) {</span>
<span class="line" id="L2145">                        <span class="tok-comment">// successful resize</span>
</span>
<span class="line" id="L2146">                        first_node.data = total_size;</span>
<span class="line" id="L2147">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2148">                        <span class="tok-comment">// manual realloc</span>
</span>
<span class="line" id="L2149">                        <span class="tok-kw">const</span> new_ptr = self.child_allocator.rawAlloc(total_size, align_bits, <span class="tok-builtin">@returnAddress</span>()) <span class="tok-kw">orelse</span> {</span>
<span class="line" id="L2150">                            <span class="tok-comment">// we failed to preheat the arena properly, signal this to the user.</span>
</span>
<span class="line" id="L2151">                            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2152">                        };</span>
<span class="line" id="L2153">                        self.child_allocator.rawFree(first_alloc_buf, align_bits, <span class="tok-builtin">@returnAddress</span>());</span>
<span class="line" id="L2154">                        <span class="tok-kw">const</span> node: *BufNode = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(new_ptr));</span>
<span class="line" id="L2155">                        node.* = .{ .data = total_size };</span>
<span class="line" id="L2156">                        self.state.buffer_list.first = node;</span>
<span class="line" id="L2157">                    }</span>
<span class="line" id="L2158">                }</span>
<span class="line" id="L2159">                <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2160">            }</span>
<span class="line" id="L2161"></span>
<span class="line" id="L2162">            <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">curAllocBuf</span>(cur_node: *BufNode) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L2163">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>([*]<span class="tok-type">u8</span>, <span class="tok-builtin">@ptrCast</span>(cur_node))[<span class="tok-number">0</span>..cur_node.data];</span>
<span class="line" id="L2164">            }</span>
<span class="line" id="L2165"></span>
<span class="line" id="L2166">            <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">curBuf</span>(cur_alloc_buf: []<span class="tok-type">u8</span>) []<span class="tok-type">u8</span> {</span>
<span class="line" id="L2167">                <span class="tok-kw">return</span> cur_alloc_buf[<span class="tok-builtin">@sizeOf</span>(BufNode)..];</span>
<span class="line" id="L2168">            }</span>
<span class="line" id="L2169"></span>
<span class="line" id="L2170">            <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">actualMinSize</span>(minimum_size: <span class="tok-type">usize</span>) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2171">                <span class="tok-comment">// seems each node is layed out as</span>
</span>
<span class="line" id="L2172">                <span class="tok-comment">//    |BufNode struct| data buf (minimum_size)|</span>
</span>
<span class="line" id="L2173">                <span class="tok-comment">// so calculate size</span>
</span>
<span class="line" id="L2174">                <span class="tok-kw">return</span> minimum_size + <span class="tok-builtin">@sizeOf</span>(BufNode);</span>
<span class="line" id="L2175">            }</span>
<span class="line" id="L2176"></span>
<span class="line" id="L2177">            <span class="tok-kw">fn</span> <span class="tok-fn">createNode</span>(self: *Self, prev_len: <span class="tok-type">usize</span>, minimum_size: <span class="tok-type">usize</span>) ?*BufNode {</span>
<span class="line" id="L2178">                <span class="tok-kw">const</span> actual_min_size = actualMinSize(minimum_size);</span>
<span class="line" id="L2179">                <span class="tok-kw">const</span> len = prev_len + actual_min_size;</span>
<span class="line" id="L2180">                <span class="tok-kw">const</span> log2_align = <span class="tok-kw">comptime</span> std.math.log2_int(<span class="tok-type">usize</span>, <span class="tok-builtin">@alignOf</span>(BufNode));</span>
<span class="line" id="L2181">                <span class="tok-kw">const</span> ptr = self.child_allocator.rawAlloc(len, log2_align, <span class="tok-builtin">@returnAddress</span>()) <span class="tok-kw">orelse</span></span>
<span class="line" id="L2182">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2183">                <span class="tok-kw">const</span> buf_node: *BufNode = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ptr));</span>
<span class="line" id="L2184">                buf_node.* = .{ .data = len };</span>
<span class="line" id="L2185">                self.state.buffer_list.prepend(buf_node);</span>
<span class="line" id="L2186">                self.state.end_index = <span class="tok-number">0</span>;</span>
<span class="line" id="L2187">                <span class="tok-kw">return</span> buf_node;</span>
<span class="line" id="L2188">            }</span>
<span class="line" id="L2189"></span>
<span class="line" id="L2190">            <span class="tok-kw">fn</span> <span class="tok-fn">alloc</span>(ctx: *<span class="tok-type">anyopaque</span>, n: <span class="tok-type">usize</span>, log2_ptr_align: <span class="tok-type">u8</span>, ra: <span class="tok-type">usize</span>) ?[*]<span class="tok-type">u8</span> {</span>
<span class="line" id="L2191">                <span class="tok-kw">const</span> self: *Self = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));</span>
<span class="line" id="L2192">                _ = ra;</span>
<span class="line" id="L2193"></span>
<span class="line" id="L2194">                <span class="tok-kw">const</span> ptr_align = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-number">1</span>) &lt;&lt; <span class="tok-builtin">@as</span>(std.mem.Allocator.Log2Align, <span class="tok-builtin">@intCast</span>(log2_ptr_align));</span>
<span class="line" id="L2195">                <span class="tok-kw">var</span> cur_node = <span class="tok-kw">if</span> (self.state.buffer_list.first) |first_node|</span>
<span class="line" id="L2196">                    first_node</span>
<span class="line" id="L2197">                <span class="tok-kw">else</span></span>
<span class="line" id="L2198">                    (self.createNode(<span class="tok-number">0</span>, n + ptr_align) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>);</span>
<span class="line" id="L2199">                <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L2200">                    <span class="tok-kw">const</span> cur_alloc_buf = curAllocBuf(cur_node);</span>
<span class="line" id="L2201">                    <span class="tok-kw">const</span> cur_buf = curBuf(cur_alloc_buf);</span>
<span class="line" id="L2202"></span>
<span class="line" id="L2203">                    <span class="tok-comment">// find new_end_index as follows</span>
</span>
<span class="line" id="L2204">                    <span class="tok-comment">//    Memory Layout</span>
</span>
<span class="line" id="L2205">                    <span class="tok-comment">//    |--------------------|-----------------------|-------------------&gt;</span>
</span>
<span class="line" id="L2206">                    <span class="tok-comment">//    ^cur ptr+end_index   ^cur ptr_aligned addr   ^next ptr+end_index (+n)</span>
</span>
<span class="line" id="L2207">                    <span class="tok-comment">//         ^addr            ^adjusted_addr</span>
</span>
<span class="line" id="L2208">                    <span class="tok-comment">//         ^----------------^</span>
</span>
<span class="line" id="L2209">                    <span class="tok-comment">//          ^delta</span>
</span>
<span class="line" id="L2210">                    <span class="tok-comment">//          so: new_end_index = end_index + delta</span>
</span>
<span class="line" id="L2211">                    <span class="tok-kw">const</span> addr = <span class="tok-builtin">@intFromPtr</span>(cur_buf.ptr) + self.state.end_index;</span>
<span class="line" id="L2212">                    <span class="tok-kw">const</span> adjusted_addr = std.mem.alignForward(<span class="tok-type">usize</span>, addr, ptr_align);</span>
<span class="line" id="L2213">                    <span class="tok-kw">const</span> adjusted_index = self.state.end_index + (adjusted_addr - addr);</span>
<span class="line" id="L2214">                    <span class="tok-kw">const</span> new_end_index = adjusted_index + n;</span>
<span class="line" id="L2215"></span>
<span class="line" id="L2216">                    <span class="tok-kw">if</span> (new_end_index &lt;= cur_buf.len) {</span>
<span class="line" id="L2217">                        <span class="tok-kw">const</span> result = cur_buf[adjusted_index..new_end_index];</span>
<span class="line" id="L2218">                        self.state.end_index = new_end_index;</span>
<span class="line" id="L2219">                        <span class="tok-kw">return</span> result.ptr;</span>
<span class="line" id="L2220">                    }</span>
<span class="line" id="L2221"></span>
<span class="line" id="L2222">                    <span class="tok-kw">const</span> bigger_buf_size = actualMinSize(new_end_index);</span>
<span class="line" id="L2223">                    <span class="tok-kw">const</span> log2_align = <span class="tok-kw">comptime</span> std.math.log2_int(<span class="tok-type">usize</span>, <span class="tok-builtin">@alignOf</span>(BufNode));</span>
<span class="line" id="L2224">                    <span class="tok-kw">if</span> (self.child_allocator.rawResize(cur_alloc_buf, log2_align, bigger_buf_size, <span class="tok-builtin">@returnAddress</span>())) {</span>
<span class="line" id="L2225">                        cur_node.data = bigger_buf_size;</span>
<span class="line" id="L2226">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2227">                        <span class="tok-comment">// Allocate a new node if that's not possible</span>
</span>
<span class="line" id="L2228">                        cur_node = self.createNode(cur_buf.len, n + ptr_align) <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2229">                    }</span>
<span class="line" id="L2230">                }</span>
<span class="line" id="L2231">            }</span>
<span class="line" id="L2232"></span>
<span class="line" id="L2233">            <span class="tok-kw">fn</span> <span class="tok-fn">resize</span>(ctx: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>, log2_buf_align: <span class="tok-type">u8</span>, new_len: <span class="tok-type">usize</span>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2234">                <span class="tok-kw">const</span> self: *Self = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));</span>
<span class="line" id="L2235">                _ = log2_buf_align;</span>
<span class="line" id="L2236">                _ = ret_addr;</span>
<span class="line" id="L2237"></span>
<span class="line" id="L2238">                <span class="tok-kw">const</span> cur_node = self.state.buffer_list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2239">                <span class="tok-kw">const</span> cur_buf = curBuf(curAllocBuf(cur_node));</span>
<span class="line" id="L2240">                <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromPtr</span>(cur_buf.ptr) + self.state.end_index != <span class="tok-builtin">@intFromPtr</span>(buf.ptr) + buf.len) {</span>
<span class="line" id="L2241">                    <span class="tok-comment">// It's not the most recent allocation, so it cannot be expanded or shrinked</span>
</span>
<span class="line" id="L2242">                    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2243">                }</span>
<span class="line" id="L2244"></span>
<span class="line" id="L2245">                <span class="tok-kw">if</span> (buf.len &gt;= new_len) {</span>
<span class="line" id="L2246">                    self.state.end_index -= buf.len - new_len;</span>
<span class="line" id="L2247">                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2248">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (cur_buf.len - self.state.end_index &gt;= new_len - buf.len) {</span>
<span class="line" id="L2249">                    self.state.end_index += new_len - buf.len;</span>
<span class="line" id="L2250">                    <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L2251">                }</span>
<span class="line" id="L2252"></span>
<span class="line" id="L2253">                <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2254">            }</span>
<span class="line" id="L2255"></span>
<span class="line" id="L2256">            <span class="tok-kw">fn</span> <span class="tok-fn">free</span>(ctx: *<span class="tok-type">anyopaque</span>, buf: []<span class="tok-type">u8</span>, log2_buf_align: <span class="tok-type">u8</span>, ret_addr: <span class="tok-type">usize</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2257">                _ = log2_buf_align;</span>
<span class="line" id="L2258">                _ = ret_addr;</span>
<span class="line" id="L2259">                <span class="tok-kw">const</span> self: *Self = <span class="tok-builtin">@ptrCast</span>(<span class="tok-builtin">@alignCast</span>(ctx));</span>
<span class="line" id="L2260">                <span class="tok-kw">const</span> cur_node = self.state.buffer_list.first <span class="tok-kw">orelse</span> <span class="tok-kw">return</span>;</span>
<span class="line" id="L2261">                <span class="tok-kw">const</span> cur_buf = curBuf(curAllocBuf(cur_node));</span>
<span class="line" id="L2262">                <span class="tok-kw">if</span> (<span class="tok-builtin">@intFromPtr</span>(cur_buf.ptr) + self.state.end_index == <span class="tok-builtin">@intFromPtr</span>(buf.ptr) + buf.len) {</span>
<span class="line" id="L2263">                    <span class="tok-comment">// It is the most recent allocation...just shirnk the end_index?</span>
</span>
<span class="line" id="L2264">                    self.state.end_index -= buf.len;</span>
<span class="line" id="L2265">                }</span>
<span class="line" id="L2266">            }</span>
<span class="line" id="L2267">        };</span>
<span class="line" id="L2268">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2269">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2270">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L2271"></span>
<span class="line" id="L2272">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(child_allocator: std.mem.Allocator) Self {</span>
<span class="line" id="L2273">                _ = child_allocator;</span>
<span class="line" id="L2274">                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_arena_allocator`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L2275">            }</span>
<span class="line" id="L2276">        };</span>
<span class="line" id="L2277">    }</span>
<span class="line" id="L2278">}</span>
<span class="line" id="L2279"></span>
<span class="line" id="L2280"><span class="tok-kw">fn</span> <span class="tok-fn">defineRegex</span>(<span class="tok-kw">comptime</span> with_pcre: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L2281">    <span class="tok-kw">if</span> (with_pcre) {</span>
<span class="line" id="L2282">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2283">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L2284"></span>
<span class="line" id="L2285">            allocator: std.mem.Allocator,</span>
<span class="line" id="L2286">            unmanaged: RegexUnmanaged,</span>
<span class="line" id="L2287"></span>
<span class="line" id="L2288">            <span class="tok-kw">const</span> MatchedResultsList = RegexUnmanaged.MatchedResultsList;</span>
<span class="line" id="L2289">            <span class="tok-kw">const</span> MatchedGroupResultsList = RegexUnmanaged.MatchedGroupResultsList;</span>
<span class="line" id="L2290"></span>
<span class="line" id="L2291">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MatchedResultIterator = RegexUnmanaged.MatchedResultIterator;</span>
<span class="line" id="L2292">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MatchedGroupResultIterator = RegexUnmanaged.MatchedGroupResultIterator;</span>
<span class="line" id="L2293">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DefaultRegexOptions = RegexUnmanaged.DefaultRegexOptions;</span>
<span class="line" id="L2294">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DefaultMatchOptions = RegexUnmanaged.DefaultMatchOptions;</span>
<span class="line" id="L2295"></span>
<span class="line" id="L2296">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, regex_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Self {</span>
<span class="line" id="L2297">                <span class="tok-kw">return</span> Self.initWithExtraRegexOptions(allocator, pattern, regex_options, <span class="tok-number">0</span>);</span>
<span class="line" id="L2298">            }</span>
<span class="line" id="L2299"></span>
<span class="line" id="L2300">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithExtraRegexOptions</span>(allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, regex_options: <span class="tok-type">u32</span>, regex_extra_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Self {</span>
<span class="line" id="L2301">                <span class="tok-kw">return</span> Self{</span>
<span class="line" id="L2302">                    .allocator = allocator,</span>
<span class="line" id="L2303">                    .unmanaged = <span class="tok-kw">try</span> RegexUnmanaged.initWithExtraRegexOptions(allocator, pattern, regex_options, regex_extra_options),</span>
<span class="line" id="L2304">                };</span>
<span class="line" id="L2305">            }</span>
<span class="line" id="L2306"></span>
<span class="line" id="L2307">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">matchSucceed</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2308">                <span class="tok-kw">return</span> this.unmanaged.matchSucceed();</span>
<span class="line" id="L2309">            }</span>
<span class="line" id="L2310"></span>
<span class="line" id="L2311">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">succeed</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2312">                <span class="tok-kw">return</span> this.unmanaged.succeed();</span>
<span class="line" id="L2313">            }</span>
<span class="line" id="L2314"></span>
<span class="line" id="L2315">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorNumber</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2316">                <span class="tok-kw">return</span> this.unmanaged.errorNumber();</span>
<span class="line" id="L2317">            }</span>
<span class="line" id="L2318"></span>
<span class="line" id="L2319">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorOffset</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2320">                <span class="tok-kw">return</span> this.unmanaged.errorOffset();</span>
<span class="line" id="L2321">            }</span>
<span class="line" id="L2322"></span>
<span class="line" id="L2323">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorMessage</span>(this: *<span class="tok-kw">const</span> Self) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2324">                <span class="tok-kw">return</span> this.unmanaged.errorMessage();</span>
<span class="line" id="L2325">            }</span>
<span class="line" id="L2326"></span>
<span class="line" id="L2327">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getResults</span>(this: *<span class="tok-kw">const</span> Self) ?[]pcre.RegexMatchResult {</span>
<span class="line" id="L2328">                <span class="tok-kw">return</span> this.unmanaged.getResults();</span>
<span class="line" id="L2329">            }</span>
<span class="line" id="L2330"></span>
<span class="line" id="L2331">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getResultsIterator</span>(this: *Self, subject: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) MatchedResultIterator {</span>
<span class="line" id="L2332">                <span class="tok-kw">return</span> this.unmanaged.getResultsIterator(subject);</span>
<span class="line" id="L2333">            }</span>
<span class="line" id="L2334"></span>
<span class="line" id="L2335">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResults</span>(this: *<span class="tok-kw">const</span> Self) ?[]pcre.RegexGroupResult {</span>
<span class="line" id="L2336">                <span class="tok-kw">return</span> this.unmanaged.getGroupResults();</span>
<span class="line" id="L2337">            }</span>
<span class="line" id="L2338"></span>
<span class="line" id="L2339">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResultByIndex</span>(this: *<span class="tok-kw">const</span> Self, index: <span class="tok-type">usize</span>) ?pcre.RegexGroupResult {</span>
<span class="line" id="L2340">                <span class="tok-kw">return</span> this.unmanaged.getGroupResultByIndex(index);</span>
<span class="line" id="L2341">            }</span>
<span class="line" id="L2342"></span>
<span class="line" id="L2343">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResultByName</span>(this: *<span class="tok-kw">const</span> Self, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?pcre.RegexGroupResult {</span>
<span class="line" id="L2344">                <span class="tok-kw">return</span> this.unmanaged.getGroupResultByName(name);</span>
<span class="line" id="L2345">            }</span>
<span class="line" id="L2346"></span>
<span class="line" id="L2347">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResultsIterator</span>(this: *Self, subject: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) MatchedGroupResultIterator {</span>
<span class="line" id="L2348">                <span class="tok-kw">return</span> this.unmanaged.getGroupResultsIterator(subject);</span>
<span class="line" id="L2349">            }</span>
<span class="line" id="L2350"></span>
<span class="line" id="L2351">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(this: *Self) <span class="tok-type">void</span> {</span>
<span class="line" id="L2352">                this.unmanaged.deinit(this.allocator);</span>
<span class="line" id="L2353">            }</span>
<span class="line" id="L2354"></span>
<span class="line" id="L2355">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(this: *Self) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2356">                <span class="tok-kw">return</span> this.unmanaged.reset(this.allocator);</span>
<span class="line" id="L2357">            }</span>
<span class="line" id="L2358"></span>
<span class="line" id="L2359">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">match</span>(this: *Self, subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset_pos: <span class="tok-type">usize</span>, fetch_results: <span class="tok-type">bool</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2360">                <span class="tok-kw">return</span> this.unmanaged.match(this.allocator, subject_slice, offset_pos, fetch_results, match_options);</span>
<span class="line" id="L2361">            }</span>
<span class="line" id="L2362"></span>
<span class="line" id="L2363">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNextOffset</span>(this: *Self, subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">usize</span> {</span>
<span class="line" id="L2364">                <span class="tok-kw">return</span> this.unmanaged.getNextOffset(subject_slice);</span>
<span class="line" id="L2365">            }</span>
<span class="line" id="L2366"></span>
<span class="line" id="L2367">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchResults</span>(this: *Self) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2368">                <span class="tok-kw">try</span> this.unmanaged.fetchResults(this.allocator);</span>
<span class="line" id="L2369">            }</span>
<span class="line" id="L2370"></span>
<span class="line" id="L2371">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">matchAll</span>(this: *Self, subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset_pos: <span class="tok-type">usize</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2372">                <span class="tok-kw">try</span> this.unmanaged.matchAll(this.allocator, subject_slice, offset_pos, match_options);</span>
<span class="line" id="L2373">            }</span>
<span class="line" id="L2374">        };</span>
<span class="line" id="L2375">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2376">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2377">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L2378"></span>
<span class="line" id="L2379">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, regex_options: <span class="tok-type">u32</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Self {</span>
<span class="line" id="L2380">                _ = allocator;</span>
<span class="line" id="L2381">                _ = pattern;</span>
<span class="line" id="L2382">                _ = regex_options;</span>
<span class="line" id="L2383">                _ = match_options;</span>
<span class="line" id="L2384">                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L2385">            }</span>
<span class="line" id="L2386">        };</span>
<span class="line" id="L2387">    }</span>
<span class="line" id="L2388">}</span>
<span class="line" id="L2389"></span>
<span class="line" id="L2390"><span class="tok-kw">fn</span> <span class="tok-fn">defineRegexUnmanaged</span>(<span class="tok-kw">comptime</span> with_pcre: <span class="tok-type">bool</span>) <span class="tok-type">type</span> {</span>
<span class="line" id="L2391">    <span class="tok-kw">if</span> (with_pcre) {</span>
<span class="line" id="L2392">        <span class="tok-comment">// The RegexUnmanaged is THE struct used for regex matching. It integrates with PCRE2 (if enabled). The regex</span>
</span>
<span class="line" id="L2393">        <span class="tok-comment">// syntax used is pcre2, can read here: https://pcre2project.github.io/pcre2/doc/html/pcre2pattern.html, or</span>
</span>
<span class="line" id="L2394">        <span class="tok-comment">// try it here: https://regex101.com/</span>
</span>
<span class="line" id="L2395">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2396">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L2397">            <span class="tok-kw">const</span> MatchedResultsList = std.SinglyLinkedList([]pcre.RegexMatchResult);</span>
<span class="line" id="L2398">            <span class="tok-kw">const</span> MatchedGroupResultsList = std.SinglyLinkedList([]pcre.RegexGroupResult);</span>
<span class="line" id="L2399"></span>
<span class="line" id="L2400">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MatchedResultIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2401">                <span class="tok-kw">const</span> Result = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2402">                    start: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2403">                    len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2404">                    value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2405">                };</span>
<span class="line" id="L2406"></span>
<span class="line" id="L2407">                maybe_matched_results: ?[]pcre.RegexMatchResult,</span>
<span class="line" id="L2408">                cur_pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L2409">                subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2410"></span>
<span class="line" id="L2411">                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(regex: *Self, subject: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) MatchedResultIterator {</span>
<span class="line" id="L2412">                    <span class="tok-kw">return</span> MatchedResultIterator{</span>
<span class="line" id="L2413">                        .maybe_matched_results = regex.getResults(),</span>
<span class="line" id="L2414">                        .subject_slice = subject,</span>
<span class="line" id="L2415">                    };</span>
<span class="line" id="L2416">                }</span>
<span class="line" id="L2417"></span>
<span class="line" id="L2418">                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextResult</span>(this: *MatchedResultIterator) ?Result {</span>
<span class="line" id="L2419">                    <span class="tok-kw">if</span> (this.maybe_matched_results) |matched_results| {</span>
<span class="line" id="L2420">                        <span class="tok-kw">if</span> (this.cur_pos &lt; matched_results.len) {</span>
<span class="line" id="L2421">                            <span class="tok-kw">const</span> start = matched_results[this.cur_pos].start;</span>
<span class="line" id="L2422">                            <span class="tok-kw">const</span> len = matched_results[this.cur_pos].len;</span>
<span class="line" id="L2423">                            this.cur_pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L2424">                            <span class="tok-kw">return</span> Result{</span>
<span class="line" id="L2425">                                .start = start,</span>
<span class="line" id="L2426">                                .len = len,</span>
<span class="line" id="L2427">                                .value = this.subject_slice[start .. start + len],</span>
<span class="line" id="L2428">                            };</span>
<span class="line" id="L2429">                        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2430">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2431">                }</span>
<span class="line" id="L2432">            };</span>
<span class="line" id="L2433"></span>
<span class="line" id="L2434">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> MatchedGroupResultIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2435">                <span class="tok-kw">const</span> Result = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2436">                    start: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2437">                    len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2438">                    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2439">                    value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2440">                };</span>
<span class="line" id="L2441"></span>
<span class="line" id="L2442">                maybe_group_results: ?[]pcre.RegexGroupResult,</span>
<span class="line" id="L2443">                cur_pos: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L2444">                subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L2445"></span>
<span class="line" id="L2446">                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(regex: *Self, subject: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) MatchedGroupResultIterator {</span>
<span class="line" id="L2447">                    <span class="tok-kw">return</span> MatchedGroupResultIterator{</span>
<span class="line" id="L2448">                        .maybe_group_results = regex.getGroupResults(),</span>
<span class="line" id="L2449">                        .subject_slice = subject,</span>
<span class="line" id="L2450">                    };</span>
<span class="line" id="L2451">                }</span>
<span class="line" id="L2452"></span>
<span class="line" id="L2453">                <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextResult</span>(this: *MatchedGroupResultIterator) ?Result {</span>
<span class="line" id="L2454">                    <span class="tok-kw">if</span> (this.maybe_group_results) |group_results| {</span>
<span class="line" id="L2455">                        <span class="tok-kw">if</span> (this.cur_pos &lt; group_results.len) {</span>
<span class="line" id="L2456">                            <span class="tok-kw">const</span> start = group_results[this.cur_pos].start;</span>
<span class="line" id="L2457">                            <span class="tok-kw">const</span> len = group_results[this.cur_pos].len;</span>
<span class="line" id="L2458">                            <span class="tok-kw">const</span> name_len = group_results[this.cur_pos].name_len;</span>
<span class="line" id="L2459">                            <span class="tok-kw">const</span> name = <span class="tok-kw">if</span> (name_len &gt; <span class="tok-number">0</span>) group_results[this.cur_pos].name[<span class="tok-number">0</span>..group_results[this.cur_pos].name_len] <span class="tok-kw">else</span> <span class="tok-str">&quot;&quot;</span>;</span>
<span class="line" id="L2460">                            this.cur_pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L2461">                            <span class="tok-kw">return</span> Result{</span>
<span class="line" id="L2462">                                .start = start,</span>
<span class="line" id="L2463">                                .len = len,</span>
<span class="line" id="L2464">                                .name = name,</span>
<span class="line" id="L2465">                                .value = this.subject_slice[start .. start + len],</span>
<span class="line" id="L2466">                            };</span>
<span class="line" id="L2467">                        } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2468">                    } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2469">                }</span>
<span class="line" id="L2470">            };</span>
<span class="line" id="L2471"></span>
<span class="line" id="L2472">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DefaultRegexOptions: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2473">            <span class="tok-kw">pub</span> <span class="tok-kw">const</span> DefaultMatchOptions: <span class="tok-type">u32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2474"></span>
<span class="line" id="L2475">            context_: *pcre.RegexContext = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2476"></span>
<span class="line" id="L2477">            matched_results_list: MatchedResultsList = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2478">            matched_group_results_list: MatchedGroupResultsList = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2479">            total_matched_results: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L2480">            total_matched_group_results: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L2481"></span>
<span class="line" id="L2482">            matched_results: []pcre.RegexMatchResult = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2483">            matched_group_results: []pcre.RegexGroupResult = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L2484"></span>
<span class="line" id="L2485">            <span class="tok-comment">/// This just means the pcre2 match action has not gone wrong. If want to be sure that there are results,</span></span>
<span class="line" id="L2486">            <span class="tok-comment">/// combine it with `matchSucceed`.</span></span>
<span class="line" id="L2487">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">succeed</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2488">                <span class="tok-comment">// PCRE error code 100 == success</span>
</span>
<span class="line" id="L2489">                <span class="tok-kw">return</span> this.context_.error_number == <span class="tok-number">100</span>;</span>
<span class="line" id="L2490">            }</span>
<span class="line" id="L2491"></span>
<span class="line" id="L2492">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">matchSucceed</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2493">                <span class="tok-kw">return</span> this.context_.rc &gt; <span class="tok-number">0</span> <span class="tok-kw">or</span> this.total_matched_results &gt; <span class="tok-number">0</span>;</span>
<span class="line" id="L2494">            }</span>
<span class="line" id="L2495"></span>
<span class="line" id="L2496">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorNumber</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2497">                <span class="tok-kw">return</span> <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(this.context_.error_number));</span>
<span class="line" id="L2498">            }</span>
<span class="line" id="L2499"></span>
<span class="line" id="L2500">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorOffset</span>(this: *<span class="tok-kw">const</span> Self) <span class="tok-type">usize</span> {</span>
<span class="line" id="L2501">                <span class="tok-kw">return</span> this.context_.error_offset;</span>
<span class="line" id="L2502">            }</span>
<span class="line" id="L2503"></span>
<span class="line" id="L2504">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">errorMessage</span>(this: *<span class="tok-kw">const</span> Self) []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2505">                <span class="tok-kw">return</span> this.context_.error_message[<span class="tok-number">0</span>..this.context_.error_message_len];</span>
<span class="line" id="L2506">            }</span>
<span class="line" id="L2507"></span>
<span class="line" id="L2508">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getResults</span>(this: *<span class="tok-kw">const</span> Self) ?[]pcre.RegexMatchResult {</span>
<span class="line" id="L2509">                <span class="tok-kw">if</span> (this.total_matched_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2510">                    <span class="tok-kw">return</span> this.matched_results;</span>
<span class="line" id="L2511">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2512">            }</span>
<span class="line" id="L2513"></span>
<span class="line" id="L2514">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getResultsIterator</span>(this: *Self, subject: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) MatchedResultIterator {</span>
<span class="line" id="L2515">                <span class="tok-kw">return</span> MatchedResultIterator.init(this, subject);</span>
<span class="line" id="L2516">            }</span>
<span class="line" id="L2517"></span>
<span class="line" id="L2518">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResults</span>(this: *<span class="tok-kw">const</span> Self) ?[]pcre.RegexGroupResult {</span>
<span class="line" id="L2519">                <span class="tok-kw">if</span> (this.total_matched_group_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2520">                    <span class="tok-kw">return</span> this.matched_group_results;</span>
<span class="line" id="L2521">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2522">            }</span>
<span class="line" id="L2523"></span>
<span class="line" id="L2524">            <span class="tok-kw">pub</span> <span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResultsIterator</span>(this: *Self, subject: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) MatchedGroupResultIterator {</span>
<span class="line" id="L2525">                <span class="tok-kw">return</span> MatchedGroupResultIterator.init(this, subject);</span>
<span class="line" id="L2526">            }</span>
<span class="line" id="L2527"></span>
<span class="line" id="L2528">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResultByIndex</span>(this: *<span class="tok-kw">const</span> Self, index: <span class="tok-type">usize</span>) ?pcre.RegexGroupResult {</span>
<span class="line" id="L2529">                <span class="tok-kw">if</span> (this.total_matched_group_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2530">                    <span class="tok-kw">for</span> (this.matched_group_results[<span class="tok-number">0</span>..this.total_matched_group_results]) |gr| {</span>
<span class="line" id="L2531">                        <span class="tok-kw">if</span> (gr.index == index) {</span>
<span class="line" id="L2532">                            <span class="tok-kw">return</span> gr;</span>
<span class="line" id="L2533">                        }</span>
<span class="line" id="L2534">                    }</span>
<span class="line" id="L2535">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2536">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2537">            }</span>
<span class="line" id="L2538"></span>
<span class="line" id="L2539">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getGroupResultByName</span>(this: *<span class="tok-kw">const</span> Self, name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?pcre.RegexGroupResult {</span>
<span class="line" id="L2540">                <span class="tok-kw">if</span> (name.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2541">                    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;name for getGroupResultByName must not be empty!&quot;</span>);</span>
<span class="line" id="L2542">                }</span>
<span class="line" id="L2543">                <span class="tok-kw">if</span> (this.total_matched_group_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2544">                    <span class="tok-kw">for</span> (this.matched_group_results[<span class="tok-number">0</span>..this.total_matched_group_results]) |gr| {</span>
<span class="line" id="L2545">                        <span class="tok-kw">if</span> (gr.name_len &gt; <span class="tok-number">0</span> <span class="tok-kw">and</span> std.mem.eql(<span class="tok-type">u8</span>, gr.name[<span class="tok-number">0</span>..gr.name_len], name)) {</span>
<span class="line" id="L2546">                            <span class="tok-kw">return</span> gr;</span>
<span class="line" id="L2547">                        }</span>
<span class="line" id="L2548">                    }</span>
<span class="line" id="L2549">                    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2550">                } <span class="tok-kw">else</span> <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2551">            }</span>
<span class="line" id="L2552"></span>
<span class="line" id="L2553">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, regex_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Self {</span>
<span class="line" id="L2554">                <span class="tok-comment">// last 0 means no extra regex options, which should be used 99% of time, unless you know</span>
</span>
<span class="line" id="L2555">                <span class="tok-comment">// this doc well: https://pcre.org/current/doc/html/pcre2api.html</span>
</span>
<span class="line" id="L2556">                <span class="tok-kw">return</span> Self.initWithExtraRegexOptions(allocator, pattern, regex_options, <span class="tok-number">0</span>);</span>
<span class="line" id="L2557">            }</span>
<span class="line" id="L2558"></span>
<span class="line" id="L2559">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">initWithExtraRegexOptions</span>(allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, regex_options: <span class="tok-type">u32</span>, regex_extra_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Self {</span>
<span class="line" id="L2560">                <span class="tok-kw">if</span> (pattern.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2561">                    <span class="tok-kw">return</span> JStringError.RegexBadPattern;</span>
<span class="line" id="L2562">                }</span>
<span class="line" id="L2563">                <span class="tok-kw">var</span> context_ = <span class="tok-kw">try</span> allocator.create(pcre.RegexContext);</span>
<span class="line" id="L2564">                context_.regex_options = regex_options;</span>
<span class="line" id="L2565">                context_.regex_extra_options = regex_extra_options;</span>
<span class="line" id="L2566">                <span class="tok-kw">const</span> result = pcre.compile(context_, pattern[<span class="tok-number">0</span>..].ptr);</span>
<span class="line" id="L2567">                <span class="tok-kw">if</span> (result == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2568">                    pcre.get_last_error_message(context_);</span>
<span class="line" id="L2569">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2570">                    <span class="tok-kw">if</span> (context_.matched_group_capacity &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2571">                        <span class="tok-kw">var</span> mgrs = <span class="tok-kw">try</span> allocator.alloc(pcre.RegexGroupResult, <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(context_.matched_group_capacity)));</span>
<span class="line" id="L2572">                        context_.matched_group_results = mgrs[<span class="tok-number">0</span>..].ptr;</span>
<span class="line" id="L2573">                    }</span>
<span class="line" id="L2574">                }</span>
<span class="line" id="L2575">                <span class="tok-kw">return</span> Self{</span>
<span class="line" id="L2576">                    .context_ = context_,</span>
<span class="line" id="L2577">                    .matched_results_list = MatchedResultsList{},</span>
<span class="line" id="L2578">                    .matched_group_results_list = MatchedGroupResultsList{},</span>
<span class="line" id="L2579">                };</span>
<span class="line" id="L2580">            }</span>
<span class="line" id="L2581"></span>
<span class="line" id="L2582">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">deinit</span>(this: *Self, allocator: std.mem.Allocator) <span class="tok-type">void</span> {</span>
<span class="line" id="L2583">                <span class="tok-kw">defer</span> allocator.destroy(this.context_);</span>
<span class="line" id="L2584">                <span class="tok-kw">if</span> (this.total_matched_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2585">                    allocator.free(this.matched_results);</span>
<span class="line" id="L2586">                }</span>
<span class="line" id="L2587">                <span class="tok-kw">if</span> (this.total_matched_group_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2588">                    allocator.free(this.matched_group_results);</span>
<span class="line" id="L2589">                }</span>
<span class="line" id="L2590">                <span class="tok-kw">if</span> (this.context_.matched_group_capacity &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2591">                    <span class="tok-kw">const</span> c = <span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(this.context_.matched_group_capacity));</span>
<span class="line" id="L2592">                    allocator.free(this.context_.matched_group_results[<span class="tok-number">0</span>..c]);</span>
<span class="line" id="L2593">                }</span>
<span class="line" id="L2594">                <span class="tok-comment">// this must be at last as it will reset context_ from c code</span>
</span>
<span class="line" id="L2595">                pcre.free_context(this.context_);</span>
<span class="line" id="L2596">            }</span>
<span class="line" id="L2597"></span>
<span class="line" id="L2598">            <span class="tok-comment">/// reset regex for next new match. This will only reset matched_results &amp; matched_group_results &amp; free</span></span>
<span class="line" id="L2599">            <span class="tok-comment">/// pcre underlying match object.</span></span>
<span class="line" id="L2600">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">reset</span>(this: *Self, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2601">                <span class="tok-kw">if</span> (this.total_matched_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2602">                    allocator.free(this.matched_results);</span>
<span class="line" id="L2603">                    this.total_matched_results = <span class="tok-number">0</span>;</span>
<span class="line" id="L2604">                }</span>
<span class="line" id="L2605">                <span class="tok-kw">if</span> (this.total_matched_group_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2606">                    allocator.free(this.matched_group_results);</span>
<span class="line" id="L2607">                    this.total_matched_group_results = <span class="tok-number">0</span>;</span>
<span class="line" id="L2608">                }</span>
<span class="line" id="L2609">                <span class="tok-comment">// order is important, must do after free matched_results &amp; matched_group_results</span>
</span>
<span class="line" id="L2610">                <span class="tok-comment">// as pcre.free_for_next_match will reset them</span>
</span>
<span class="line" id="L2611">                pcre.free_for_next_match(this.context_);</span>
<span class="line" id="L2612">            }</span>
<span class="line" id="L2613"></span>
<span class="line" id="L2614">            <span class="tok-comment">/// if not fetch_results, this.context_.next_offset is not set, need to manually do</span></span>
<span class="line" id="L2615">            <span class="tok-comment">/// `this.getNextOffset(subject)` for it. The regex syntax used is pcre2, can read</span></span>
<span class="line" id="L2616">            <span class="tok-comment">/// here: https://pcre2project.github.io/pcre2/doc/html/pcre2pattern.html, or try it here:</span></span>
<span class="line" id="L2617">            <span class="tok-comment">/// https://regex101.com/</span></span>
<span class="line" id="L2618">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">match</span>(this: *Self, allocator: std.mem.Allocator, subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset_pos: <span class="tok-type">usize</span>, fetch_results: <span class="tok-type">bool</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2619">                this.context_.match_options = match_options;</span>
<span class="line" id="L2620">                <span class="tok-kw">const</span> m = pcre.match(this.context_, subject_slice[<span class="tok-number">0</span>..].ptr, subject_slice.len, offset_pos);</span>
<span class="line" id="L2621">                <span class="tok-kw">if</span> (m &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2622">                    <span class="tok-kw">if</span> (fetch_results) {</span>
<span class="line" id="L2623">                        <span class="tok-kw">try</span> this.fetchResults(allocator);</span>
<span class="line" id="L2624">                        pcre.get_next_offset(this.context_, subject_slice[<span class="tok-number">0</span>..].ptr, subject_slice.len);</span>
<span class="line" id="L2625">                    }</span>
<span class="line" id="L2626">                }</span>
<span class="line" id="L2627">            }</span>
<span class="line" id="L2628"></span>
<span class="line" id="L2629">            <span class="tok-comment">/// must call after successful match, otherwise error</span></span>
<span class="line" id="L2630">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">getNextOffset</span>(this: *Self, subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">usize</span> {</span>
<span class="line" id="L2631">                <span class="tok-kw">if</span> (this.context_.with_match_result == <span class="tok-number">1</span>) {</span>
<span class="line" id="L2632">                    <span class="tok-kw">if</span> (this.matchSucceed()) {</span>
<span class="line" id="L2633">                        pcre.get_next_offset(this.context_, subject_slice[<span class="tok-number">0</span>..].ptr, subject_slice.len);</span>
<span class="line" id="L2634">                        <span class="tok-kw">return</span> this.context_.next_offset;</span>
<span class="line" id="L2635">                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2636">                        <span class="tok-kw">return</span> this.context_.origin_offset;</span>
<span class="line" id="L2637">                    }</span>
<span class="line" id="L2638">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2639">                    <span class="tok-kw">return</span> JStringError.RegexFetchBeforeMatch;</span>
<span class="line" id="L2640">                }</span>
<span class="line" id="L2641">            }</span>
<span class="line" id="L2642"></span>
<span class="line" id="L2643">            <span class="tok-comment">/// only for single match fetchResults lazily. For matchAll it will always fetch while match.</span></span>
<span class="line" id="L2644">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">fetchResults</span>(this: *Self, allocator: std.mem.Allocator) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2645">                <span class="tok-kw">if</span> (this.matchSucceed()) {</span>
<span class="line" id="L2646">                    pcre.fetch_match_results(this.context_);</span>
<span class="line" id="L2647">                    <span class="tok-kw">if</span> (this.context_.matched_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2648">                        this.matched_results = <span class="tok-kw">try</span> allocator.alloc(pcre.RegexMatchResult, this.context_.matched_count);</span>
<span class="line" id="L2649">                        this.matched_results[<span class="tok-number">0</span>] = this.context_.matched_result;</span>
<span class="line" id="L2650">                        this.total_matched_results = <span class="tok-number">1</span>;</span>
<span class="line" id="L2651">                    }</span>
<span class="line" id="L2652">                    <span class="tok-kw">if</span> (this.context_.matched_group_count &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2653">                        this.matched_group_results = <span class="tok-kw">try</span> allocator.alloc(pcre.RegexGroupResult, this.context_.matched_group_count);</span>
<span class="line" id="L2654">                        <span class="tok-kw">for</span> (<span class="tok-number">0</span>..this.context_.matched_group_count) |i| {</span>
<span class="line" id="L2655">                            this.matched_group_results[i] = this.context_.matched_group_results[i];</span>
<span class="line" id="L2656">                        }</span>
<span class="line" id="L2657">                        this.total_matched_group_results = this.context_.matched_group_count;</span>
<span class="line" id="L2658">                    }</span>
<span class="line" id="L2659">                }</span>
<span class="line" id="L2660">            }</span>
<span class="line" id="L2661"></span>
<span class="line" id="L2662">            <span class="tok-comment">/// matchAll will do `fetchResults` in anyway. The regex syntax used is pcre2, can read</span></span>
<span class="line" id="L2663">            <span class="tok-comment">/// here: https://pcre2project.github.io/pcre2/doc/html/pcre2pattern.html, or try it here:</span></span>
<span class="line" id="L2664">            <span class="tok-comment">/// https://regex101.com/.</span></span>
<span class="line" id="L2665">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">matchAll</span>(this: *Self, allocator: std.mem.Allocator, subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, offset_pos: <span class="tok-type">usize</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2666">                this.context_.match_options = match_options;</span>
<span class="line" id="L2667">                <span class="tok-kw">var</span> m: <span class="tok-type">i64</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2668">                <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = offset_pos;</span>
<span class="line" id="L2669">                <span class="tok-kw">var</span> matched_result_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2670">                <span class="tok-kw">var</span> matched_group_result_count: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2671">                <span class="tok-kw">while</span> (offset &lt; subject_slice.len) {</span>
<span class="line" id="L2672">                    m = pcre.match(this.context_, subject_slice[<span class="tok-number">0</span>..].ptr, subject_slice.len, offset);</span>
<span class="line" id="L2673">                    <span class="tok-kw">if</span> (m &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2674">                        <span class="tok-kw">try</span> this.fetchResults(allocator);</span>
<span class="line" id="L2675">                        <span class="tok-kw">if</span> (this.getResults()) |matched_results| {</span>
<span class="line" id="L2676">                            <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> allocator.create(MatchedResultsList.Node);</span>
<span class="line" id="L2677">                            n.data = matched_results;</span>
<span class="line" id="L2678">                            this.matched_results_list.prepend(n);</span>
<span class="line" id="L2679">                            matched_result_count += matched_results.len;</span>
<span class="line" id="L2680">                            <span class="tok-comment">// set total_matched_results = 0 so later in reset it will not be freed</span>
</span>
<span class="line" id="L2681">                            this.total_matched_results = <span class="tok-number">0</span>;</span>
<span class="line" id="L2682">                        }</span>
<span class="line" id="L2683">                        <span class="tok-kw">if</span> (this.getGroupResults()) |group_results| {</span>
<span class="line" id="L2684">                            <span class="tok-kw">const</span> n = <span class="tok-kw">try</span> allocator.create(MatchedGroupResultsList.Node);</span>
<span class="line" id="L2685">                            n.data = group_results;</span>
<span class="line" id="L2686">                            this.matched_group_results_list.prepend(n);</span>
<span class="line" id="L2687">                            matched_group_result_count += group_results.len;</span>
<span class="line" id="L2688">                            <span class="tok-comment">// set total_matched_group_results = 0 so later in reset it will not be freed</span>
</span>
<span class="line" id="L2689">                            this.total_matched_group_results = <span class="tok-number">0</span>;</span>
<span class="line" id="L2690">                        }</span>
<span class="line" id="L2691">                        pcre.get_next_offset(this.context_, subject_slice[<span class="tok-number">0</span>..].ptr, subject_slice.len);</span>
<span class="line" id="L2692">                        offset = this.context_.next_offset;</span>
<span class="line" id="L2693">                        <span class="tok-kw">try</span> this.reset(allocator);</span>
<span class="line" id="L2694">                    } <span class="tok-kw">else</span> <span class="tok-kw">break</span>;</span>
<span class="line" id="L2695">                }</span>
<span class="line" id="L2696"></span>
<span class="line" id="L2697">                <span class="tok-kw">try</span> this._mergeMatchedResults(allocator, matched_result_count);</span>
<span class="line" id="L2698">                <span class="tok-kw">try</span> this._mergeMatchedGroupResults(allocator, matched_group_result_count);</span>
<span class="line" id="L2699">            }</span>
<span class="line" id="L2700"></span>
<span class="line" id="L2701">            <span class="tok-kw">fn</span> <span class="tok-fn">_mergeMatchedResults</span>(this: *Self, allocator: std.mem.Allocator, matched_count: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2702">                <span class="tok-kw">if</span> (this.total_matched_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2703">                    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;must not enter this function before reset&quot;</span>);</span>
<span class="line" id="L2704">                }</span>
<span class="line" id="L2705">                this.total_matched_results = matched_count;</span>
<span class="line" id="L2706">                <span class="tok-kw">if</span> (matched_count == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2707">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L2708">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2709">                    <span class="tok-kw">var</span> merged_matched_results: []pcre.RegexMatchResult = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2710">                    merged_matched_results = <span class="tok-kw">try</span> allocator.alloc(pcre.RegexMatchResult, matched_count);</span>
<span class="line" id="L2711">                    <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = merged_matched_results.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L2712">                    brk: {</span>
<span class="line" id="L2713">                        <span class="tok-kw">while</span> (this.matched_results_list.popFirst()) |n| {</span>
<span class="line" id="L2714">                            <span class="tok-kw">for</span> (<span class="tok-number">1</span>..n.data.len + <span class="tok-number">1</span>) |i| {</span>
<span class="line" id="L2715">                                merged_matched_results[offset] = n.data[n.data.len - i];</span>
<span class="line" id="L2716">                                <span class="tok-kw">if</span> (offset == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2717">                                    allocator.free(n.data);</span>
<span class="line" id="L2718">                                    allocator.destroy(n);</span>
<span class="line" id="L2719">                                    <span class="tok-kw">break</span> :brk;</span>
<span class="line" id="L2720">                                }</span>
<span class="line" id="L2721">                                offset -= <span class="tok-number">1</span>;</span>
<span class="line" id="L2722">                            }</span>
<span class="line" id="L2723">                            allocator.free(n.data);</span>
<span class="line" id="L2724">                            allocator.destroy(n);</span>
<span class="line" id="L2725">                        }</span>
<span class="line" id="L2726">                    }</span>
<span class="line" id="L2727">                    this.matched_results = merged_matched_results;</span>
<span class="line" id="L2728">                }</span>
<span class="line" id="L2729">            }</span>
<span class="line" id="L2730"></span>
<span class="line" id="L2731">            <span class="tok-kw">fn</span> <span class="tok-fn">_mergeMatchedGroupResults</span>(this: *Self, allocator: std.mem.Allocator, matched_group_count: <span class="tok-type">usize</span>) <span class="tok-type">anyerror</span>!<span class="tok-type">void</span> {</span>
<span class="line" id="L2732">                <span class="tok-kw">if</span> (this.total_matched_group_results &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2733">                    <span class="tok-builtin">@panic</span>(<span class="tok-str">&quot;must not enter this function before reset&quot;</span>);</span>
<span class="line" id="L2734">                }</span>
<span class="line" id="L2735">                this.total_matched_group_results = matched_group_count;</span>
<span class="line" id="L2736">                <span class="tok-kw">if</span> (matched_group_count == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2737">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L2738">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2739">                    <span class="tok-kw">var</span> merged_matched_group_results: []pcre.RegexGroupResult = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2740">                    merged_matched_group_results = <span class="tok-kw">try</span> allocator.alloc(pcre.RegexGroupResult, matched_group_count);</span>
<span class="line" id="L2741">                    <span class="tok-kw">var</span> offset: <span class="tok-type">usize</span> = merged_matched_group_results.len - <span class="tok-number">1</span>;</span>
<span class="line" id="L2742">                    brk: {</span>
<span class="line" id="L2743">                        <span class="tok-kw">while</span> (this.matched_group_results_list.popFirst()) |n| {</span>
<span class="line" id="L2744">                            <span class="tok-kw">for</span> (<span class="tok-number">1</span>..n.data.len + <span class="tok-number">1</span>) |i| {</span>
<span class="line" id="L2745">                                merged_matched_group_results[offset] = n.data[n.data.len - i];</span>
<span class="line" id="L2746">                                <span class="tok-kw">if</span> (offset == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2747">                                    allocator.free(n.data);</span>
<span class="line" id="L2748">                                    allocator.destroy(n);</span>
<span class="line" id="L2749">                                    <span class="tok-kw">break</span> :brk;</span>
<span class="line" id="L2750">                                }</span>
<span class="line" id="L2751">                                offset -= <span class="tok-number">1</span>;</span>
<span class="line" id="L2752">                            }</span>
<span class="line" id="L2753">                            allocator.free(n.data);</span>
<span class="line" id="L2754">                            allocator.destroy(n);</span>
<span class="line" id="L2755">                        }</span>
<span class="line" id="L2756">                    }</span>
<span class="line" id="L2757">                    this.matched_group_results = merged_matched_group_results;</span>
<span class="line" id="L2758">                }</span>
<span class="line" id="L2759">            }</span>
<span class="line" id="L2760">        };</span>
<span class="line" id="L2761">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2762">        <span class="tok-kw">return</span> <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2763">            <span class="tok-kw">const</span> Self = <span class="tok-builtin">@This</span>();</span>
<span class="line" id="L2764"></span>
<span class="line" id="L2765">            <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(allocator: std.mem.Allocator, pattern: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, regex_options: <span class="tok-type">u32</span>, match_options: <span class="tok-type">u32</span>) <span class="tok-type">anyerror</span>!Self {</span>
<span class="line" id="L2766">                _ = allocator;</span>
<span class="line" id="L2767">                _ = pattern;</span>
<span class="line" id="L2768">                _ = regex_options;</span>
<span class="line" id="L2769">                _ = match_options;</span>
<span class="line" id="L2770">                <span class="tok-builtin">@compileError</span>(<span class="tok-str">&quot;disabled by comptime var `enable_pcre`, set it true to enable.&quot;</span>);</span>
<span class="line" id="L2771">            }</span>
<span class="line" id="L2772">        };</span>
<span class="line" id="L2773">    }</span>
<span class="line" id="L2774">}</span>
<span class="line" id="L2775"></span>
<span class="line" id="L2776"><span class="tok-comment">// &gt;&gt;&gt; internal functions</span>
</span>
<span class="line" id="L2777"></span>
<span class="line" id="L2778"><span class="tok-kw">fn</span> <span class="tok-fn">_bufPrintFmt</span>(<span class="tok-kw">comptime</span> type_info: std.builtin.Type, <span class="tok-kw">comptime</span> fmt_buf: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> fmt_len_: *<span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> fmt_print_slice_: *[]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2779">    <span class="tok-kw">var</span> printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;{{&quot;</span>, .{});</span>
<span class="line" id="L2780">    fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2781">    fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2782"></span>
<span class="line" id="L2783">    _bufPrintSpecifier(type_info, fmt_buf, fmt_len_, fmt_print_slice_);</span>
<span class="line" id="L2784"></span>
<span class="line" id="L2785">    printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;}}&quot;</span>, .{});</span>
<span class="line" id="L2786">    fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2787">    fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2788">}</span>
<span class="line" id="L2789"></span>
<span class="line" id="L2790"><span class="tok-kw">fn</span> <span class="tok-fn">_bufPrintSpecifier</span>(<span class="tok-kw">comptime</span> type_info: std.builtin.Type, <span class="tok-kw">comptime</span> fmt_buf: []<span class="tok-type">u8</span>, <span class="tok-kw">comptime</span> fmt_len_: *<span class="tok-type">usize</span>, <span class="tok-kw">comptime</span> fmt_print_slice_: *[]<span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L2791">    <span class="tok-kw">var</span> printed_fmt: []<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2792">    <span class="tok-kw">switch</span> (type_info) {</span>
<span class="line" id="L2793">        .Array =&gt; {</span>
<span class="line" id="L2794">            printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;any&quot;</span>, .{});</span>
<span class="line" id="L2795">            fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2796">            fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2797">        },</span>
<span class="line" id="L2798">        .Pointer =&gt; |ptr_info| <span class="tok-kw">switch</span> (ptr_info.size) {</span>
<span class="line" id="L2799">            .One, .Many, .C =&gt; {</span>
<span class="line" id="L2800">                printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;s&quot;</span>, .{});</span>
<span class="line" id="L2801">                fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2802">                fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2803">            },</span>
<span class="line" id="L2804">            .Slice =&gt; {</span>
<span class="line" id="L2805">                printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;any&quot;</span>, .{});</span>
<span class="line" id="L2806">                fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2807">                fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2808">            },</span>
<span class="line" id="L2809">        },</span>
<span class="line" id="L2810">        .Optional =&gt; |info| {</span>
<span class="line" id="L2811">            printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;?&quot;</span>, .{});</span>
<span class="line" id="L2812">            fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2813">            fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2814">            _bufPrintSpecifier(<span class="tok-builtin">@typeInfo</span>(info.child), fmt_buf, fmt_len_, fmt_print_slice_);</span>
<span class="line" id="L2815">        },</span>
<span class="line" id="L2816">        .ErrorUnion =&gt; |info| {</span>
<span class="line" id="L2817">            printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;!&quot;</span>, .{});</span>
<span class="line" id="L2818">            fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2819">            fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2820">            _bufPrintSpecifier(<span class="tok-builtin">@typeInfo</span>(info.payload), fmt_buf, fmt_len_, fmt_print_slice_);</span>
<span class="line" id="L2821">        },</span>
<span class="line" id="L2822">        <span class="tok-kw">else</span> =&gt; {</span>
<span class="line" id="L2823">            printed_fmt = <span class="tok-kw">try</span> std.fmt.bufPrint(fmt_print_slice_.*, <span class="tok-str">&quot;&quot;</span>, .{});</span>
<span class="line" id="L2824">            fmt_len_.* = fmt_len_.* + printed_fmt.len;</span>
<span class="line" id="L2825">            fmt_print_slice_.* = fmt_buf[fmt_len_.*..];</span>
<span class="line" id="L2826">        },</span>
<span class="line" id="L2827">    }</span>
<span class="line" id="L2828">}</span>
<span class="line" id="L2829"></span>
<span class="line" id="L2830"><span class="tok-comment">// take advantage of both matched results and group matched results are sorted based on start when taking out of pcre,</span>
</span>
<span class="line" id="L2831"><span class="tok-comment">// do a merge algorithm here</span>
</span>
<span class="line" id="L2832"><span class="tok-kw">const</span> _MatchedGapIterator = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2833">    <span class="tok-kw">const</span> Gap = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L2834">        start: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2835">        len: <span class="tok-type">usize</span>,</span>
<span class="line" id="L2836">    };</span>
<span class="line" id="L2837"></span>
<span class="line" id="L2838">    it: RegexUnmanaged.MatchedResultIterator,</span>
<span class="line" id="L2839">    it_should_fetch: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L2840">    group_it: RegexUnmanaged.MatchedGroupResultIterator,</span>
<span class="line" id="L2841">    group_it_should_fetch: <span class="tok-type">bool</span> = <span class="tok-null">true</span>,</span>
<span class="line" id="L2842">    maybe_result: ?RegexUnmanaged.MatchedResultIterator.Result = <span class="tok-null">null</span>,</span>
<span class="line" id="L2843">    maybe_group_result: ?RegexUnmanaged.MatchedGroupResultIterator.Result = <span class="tok-null">null</span>,</span>
<span class="line" id="L2844">    last_start: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L2845">    last_len: <span class="tok-type">usize</span> = <span class="tok-number">0</span>,</span>
<span class="line" id="L2846"></span>
<span class="line" id="L2847">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">init</span>(re: *RegexUnmanaged, subject_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) _MatchedGapIterator {</span>
<span class="line" id="L2848">        <span class="tok-kw">return</span> _MatchedGapIterator{</span>
<span class="line" id="L2849">            .it = re.getResultsIterator(subject_slice),</span>
<span class="line" id="L2850">            .group_it = re.getGroupResultsIterator(subject_slice),</span>
<span class="line" id="L2851">        };</span>
<span class="line" id="L2852">    }</span>
<span class="line" id="L2853"></span>
<span class="line" id="L2854">    <span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">nextGap</span>(this: *_MatchedGapIterator) <span class="tok-type">anyerror</span>!?Gap {</span>
<span class="line" id="L2855">        <span class="tok-kw">if</span> (this.it_should_fetch) {</span>
<span class="line" id="L2856">            this.maybe_result = this.it.nextResult();</span>
<span class="line" id="L2857">            this.it_should_fetch = <span class="tok-null">false</span>;</span>
<span class="line" id="L2858">        }</span>
<span class="line" id="L2859">        <span class="tok-kw">if</span> (this.group_it_should_fetch) {</span>
<span class="line" id="L2860">            this.maybe_group_result = this.group_it.nextResult();</span>
<span class="line" id="L2861">            this.group_it_should_fetch = <span class="tok-null">false</span>;</span>
<span class="line" id="L2862">        }</span>
<span class="line" id="L2863">        <span class="tok-kw">if</span> (this.maybe_result) |r| {</span>
<span class="line" id="L2864">            <span class="tok-kw">if</span> (this.maybe_group_result) |gr| {</span>
<span class="line" id="L2865">                <span class="tok-kw">if</span> (r.start &lt;= gr.start) {</span>
<span class="line" id="L2866">                    <span class="tok-kw">return</span> this._nextGapFromIt(r);</span>
<span class="line" id="L2867">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2868">                    <span class="tok-kw">return</span> this._nextGapFromGroupIt(gr);</span>
<span class="line" id="L2869">                }</span>
<span class="line" id="L2870">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2871">                <span class="tok-kw">return</span> this._nextGapFromIt(r);</span>
<span class="line" id="L2872">            }</span>
<span class="line" id="L2873">        }</span>
<span class="line" id="L2874">        <span class="tok-kw">if</span> (this.maybe_group_result) |gr| {</span>
<span class="line" id="L2875">            <span class="tok-comment">// this.maybe_result must be null if we reach here, no need to check it</span>
</span>
<span class="line" id="L2876">            <span class="tok-kw">return</span> this._nextGapFromGroupIt(gr);</span>
<span class="line" id="L2877">        }</span>
<span class="line" id="L2878">        <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L2879">    }</span>
<span class="line" id="L2880"></span>
<span class="line" id="L2881">    <span class="tok-kw">fn</span> <span class="tok-fn">_nextGapFromIt</span>(this: *_MatchedGapIterator, r: RegexUnmanaged.MatchedResultIterator.Result) <span class="tok-type">anyerror</span>!?Gap {</span>
<span class="line" id="L2882">        this.it_should_fetch = <span class="tok-null">true</span>;</span>
<span class="line" id="L2883">        <span class="tok-kw">if</span> (this.last_start == r.start <span class="tok-kw">and</span> this.last_len == r.len) {</span>
<span class="line" id="L2884">            <span class="tok-comment">// can never reach here because we can reach here either</span>
</span>
<span class="line" id="L2885">            <span class="tok-comment">// 1. in front other other group result</span>
</span>
<span class="line" id="L2886">            <span class="tok-comment">// 2. or when move to next single match result</span>
</span>
<span class="line" id="L2887">            <span class="tok-comment">//</span>
</span>
<span class="line" id="L2888">            <span class="tok-comment">// for case 2, impossible to meet the condition, as match results will not overlap, and next match</span>
</span>
<span class="line" id="L2889">            <span class="tok-comment">//   result will never overlap last match's group result</span>
</span>
<span class="line" id="L2890">            <span class="tok-comment">// for case 1, impossible too, because either this is first match result, or we just move from last</span>
</span>
<span class="line" id="L2891">            <span class="tok-comment">//   match, so reduce to case 2</span>
</span>
<span class="line" id="L2892">            <span class="tok-comment">//</span>
</span>
<span class="line" id="L2893">            <span class="tok-comment">// return this.nextGap();</span>
</span>
<span class="line" id="L2894">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2895">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this.last_start + this.last_len &gt; r.start) {</span>
<span class="line" id="L2896">            <span class="tok-comment">// see above, this is impossible too.</span>
</span>
<span class="line" id="L2897">            <span class="tok-comment">//</span>
</span>
<span class="line" id="L2898">            <span class="tok-comment">// return JStringError.RegexMatchOverlapped;</span>
</span>
<span class="line" id="L2899">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2900">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2901">            this.last_start = r.start;</span>
<span class="line" id="L2902">            this.last_len = r.len;</span>
<span class="line" id="L2903">            <span class="tok-kw">return</span> Gap{</span>
<span class="line" id="L2904">                .start = r.start,</span>
<span class="line" id="L2905">                .len = r.len,</span>
<span class="line" id="L2906">            };</span>
<span class="line" id="L2907">        }</span>
<span class="line" id="L2908">    }</span>
<span class="line" id="L2909"></span>
<span class="line" id="L2910">    <span class="tok-kw">fn</span> <span class="tok-fn">_nextGapFromGroupIt</span>(this: *_MatchedGapIterator, gr: RegexUnmanaged.MatchedGroupResultIterator.Result) <span class="tok-type">anyerror</span>!?Gap {</span>
<span class="line" id="L2911">        this.group_it_should_fetch = <span class="tok-null">true</span>;</span>
<span class="line" id="L2912">        <span class="tok-kw">if</span> (this.last_start == gr.start <span class="tok-kw">and</span> this.last_len == gr.len) {</span>
<span class="line" id="L2913">            <span class="tok-kw">return</span> this.nextGap();</span>
<span class="line" id="L2914">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (this.last_start + this.last_len &gt; gr.start) {</span>
<span class="line" id="L2915">            <span class="tok-kw">return</span> JStringError.RegexMatchOverlapped;</span>
<span class="line" id="L2916">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2917">            <span class="tok-comment">// originally I wrote down:</span>
</span>
<span class="line" id="L2918">            <span class="tok-comment">//</span>
</span>
<span class="line" id="L2919">            <span class="tok-comment">// this.last_start = gr.start;</span>
</span>
<span class="line" id="L2920">            <span class="tok-comment">// this.last_len = gr.len;</span>
</span>
<span class="line" id="L2921">            <span class="tok-comment">// return Gap{</span>
</span>
<span class="line" id="L2922">            <span class="tok-comment">//     .start = gr.start,</span>
</span>
<span class="line" id="L2923">            <span class="tok-comment">//     .len = gr.len,</span>
</span>
<span class="line" id="L2924">            <span class="tok-comment">// };</span>
</span>
<span class="line" id="L2925">            <span class="tok-comment">//</span>
</span>
<span class="line" id="L2926">            <span class="tok-comment">// but this can never happen, because if we reach here, means we find a group result outside of</span>
</span>
<span class="line" id="L2927">            <span class="tok-comment">// 1. all match results</span>
</span>
<span class="line" id="L2928">            <span class="tok-comment">// 2. all other group results</span>
</span>
<span class="line" id="L2929">            <span class="tok-comment">// where 2. be always true (as groups are not overlapping), but for 1., at least one match result must</span>
</span>
<span class="line" id="L2930">            <span class="tok-comment">// cover our group (as how pcre works). So, we can never reach here.</span>
</span>
<span class="line" id="L2931">            <span class="tok-comment">//</span>
</span>
<span class="line" id="L2932">            <span class="tok-kw">unreachable</span>;</span>
<span class="line" id="L2933">        }</span>
<span class="line" id="L2934">    }</span>
<span class="line" id="L2935">};</span>
<span class="line" id="L2936"></span>
<span class="line" id="L2937"><span class="tok-comment">/// very unsafe, you have been warned to know what you are doing</span></span>
<span class="line" id="L2938"><span class="tok-kw">fn</span> <span class="tok-fn">_sliceAt</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, haystack: []<span class="tok-kw">const</span> T, index: <span class="tok-type">isize</span>) T {</span>
<span class="line" id="L2939">    <span class="tok-kw">if</span> (index &gt;= <span class="tok-number">0</span>) {</span>
<span class="line" id="L2940">        <span class="tok-kw">return</span> haystack[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(index))];</span>
<span class="line" id="L2941">    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2942">        <span class="tok-kw">return</span> haystack[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(<span class="tok-builtin">@as</span>(<span class="tok-type">isize</span>, <span class="tok-builtin">@intCast</span>(haystack.len)) + index))];</span>
<span class="line" id="L2943">    }</span>
<span class="line" id="L2944">}</span>
<span class="line" id="L2945"></span>
<span class="line" id="L2946"><span class="tok-kw">fn</span> <span class="tok-fn">_kmpBuildFailureTable</span>(allocator: std.mem.Allocator, needle_slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">anyerror</span>![]<span class="tok-type">isize</span> {</span>
<span class="line" id="L2947">    <span class="tok-kw">const</span> t = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">isize</span>, (needle_slice.len + <span class="tok-number">1</span>));</span>
<span class="line" id="L2948">    <span class="tok-builtin">@memset</span>(t, <span class="tok-number">0</span>);</span>
<span class="line" id="L2949"></span>
<span class="line" id="L2950">    t[<span class="tok-number">0</span>] = -<span class="tok-number">1</span>;</span>
<span class="line" id="L2951">    <span class="tok-kw">var</span> pos: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L2952">    <span class="tok-kw">var</span> cnd: <span class="tok-type">isize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2953">    <span class="tok-kw">while</span> (pos &lt; needle_slice.len) {</span>
<span class="line" id="L2954">        <span class="tok-kw">if</span> (needle_slice[pos] == needle_slice[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cnd))]) {</span>
<span class="line" id="L2955">            t[pos] = t[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cnd))];</span>
<span class="line" id="L2956">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2957">            t[pos] = cnd;</span>
<span class="line" id="L2958">            <span class="tok-kw">while</span> (cnd &gt;= <span class="tok-number">0</span> <span class="tok-kw">and</span> needle_slice[pos] != needle_slice[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cnd))]) {</span>
<span class="line" id="L2959">                cnd = t[<span class="tok-builtin">@as</span>(<span class="tok-type">usize</span>, <span class="tok-builtin">@intCast</span>(cnd))];</span>
<span class="line" id="L2960">            }</span>
<span class="line" id="L2961">        }</span>
<span class="line" id="L2962">        pos += <span class="tok-number">1</span>;</span>
<span class="line" id="L2963">        cnd += <span class="tok-number">1</span>;</span>
<span class="line" id="L2964">    }</span>
<span class="line" id="L2965">    t[pos] = cnd;</span>
<span class="line" id="L2966"></span>
<span class="line" id="L2967">    <span class="tok-kw">return</span> t;</span>
<span class="line" id="L2968">}</span>
<span class="line" id="L2969"></span>
<span class="line" id="L2970"><span class="tok-kw">fn</span> <span class="tok-fn">_testCreateErrorUnion</span>(value_or_error: <span class="tok-type">bool</span>, <span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, value: T, err: <span class="tok-type">anyerror</span>) <span class="tok-type">anyerror</span>!T {</span>
<span class="line" id="L2971">    <span class="tok-kw">return</span> <span class="tok-kw">if</span> (value_or_error) value <span class="tok-kw">else</span> err;</span>
<span class="line" id="L2972">}</span>
<span class="line" id="L2973"></span>
<span class="line" id="L2974"><span class="tok-kw">fn</span> <span class="tok-fn">_testIsError</span>(<span class="tok-kw">comptime</span> T: <span class="tok-type">type</span>, maybe_value: <span class="tok-type">anyerror</span>!T, expected_error: <span class="tok-type">anyerror</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L2975">    <span class="tok-kw">if</span> (maybe_value) |_| {</span>
<span class="line" id="L2976">        <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L2977">    } <span class="tok-kw">else</span> |err| {</span>
<span class="line" id="L2978">        <span class="tok-kw">return</span> err == expected_error;</span>
<span class="line" id="L2979">    }</span>
<span class="line" id="L2980">}</span>
<span class="line" id="L2981"></span>
<span class="line" id="L2982"><span class="tok-comment">// &gt;&gt;&gt; all your tests belong to me and list in below &lt;&lt;&lt;</span>
</span>
<span class="line" id="L2983"></span>
<span class="line" id="L2984"><span class="tok-kw">test</span> <span class="tok-str">&quot;ArenaAllocator&quot;</span> {</span>
<span class="line" id="L2985">    <span class="tok-kw">if</span> (enable_arena_allocator) {</span>
<span class="line" id="L2986">        {</span>
<span class="line" id="L2987">            <span class="tok-kw">var</span> arena_allocator = ArenaAllocator.init(std.testing.allocator);</span>
<span class="line" id="L2988">            <span class="tok-kw">defer</span> arena_allocator.deinit();</span>
<span class="line" id="L2989">            <span class="tok-comment">// provides some variance in the allocated data</span>
</span>
<span class="line" id="L2990"></span>
<span class="line" id="L2991">            <span class="tok-kw">var</span> rng_src = std.rand.DefaultPrng.init(<span class="tok-number">19930913</span>);</span>
<span class="line" id="L2992">            <span class="tok-kw">const</span> random = rng_src.random();</span>
<span class="line" id="L2993">            <span class="tok-kw">var</span> rounds: <span class="tok-type">usize</span> = <span class="tok-number">25</span>;</span>
<span class="line" id="L2994">            <span class="tok-kw">while</span> (rounds &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2995">                rounds -= <span class="tok-number">1</span>;</span>
<span class="line" id="L2996">                _ = arena_allocator.reset(.retain_capacity);</span>
<span class="line" id="L2997">                <span class="tok-kw">var</span> alloced_bytes: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2998">                <span class="tok-kw">const</span> total_size: <span class="tok-type">usize</span> = random.intRangeAtMost(<span class="tok-type">usize</span>, <span class="tok-number">256</span>, <span class="tok-number">16384</span>);</span>
<span class="line" id="L2999">                <span class="tok-kw">while</span> (alloced_bytes &lt; total_size) {</span>
<span class="line" id="L3000">                    <span class="tok-kw">const</span> size = random.intRangeAtMost(<span class="tok-type">usize</span>, <span class="tok-number">16</span>, <span class="tok-number">256</span>);</span>
<span class="line" id="L3001">                    <span class="tok-kw">const</span> alignment = <span class="tok-number">32</span>;</span>
<span class="line" id="L3002">                    <span class="tok-kw">const</span> slice = <span class="tok-kw">try</span> arena_allocator.allocator().alignedAlloc(<span class="tok-type">u8</span>, alignment, size);</span>
<span class="line" id="L3003">                    <span class="tok-kw">try</span> std.testing.expect(std.mem.isAligned(<span class="tok-builtin">@intFromPtr</span>(slice.ptr), alignment));</span>
<span class="line" id="L3004">                    <span class="tok-kw">try</span> std.testing.expectEqual(size, slice.len);</span>
<span class="line" id="L3005">                    alloced_bytes += slice.len;</span>
<span class="line" id="L3006">                }</span>
<span class="line" id="L3007">            }</span>
<span class="line" id="L3008">        }</span>
<span class="line" id="L3009">        {</span>
<span class="line" id="L3010">            <span class="tok-kw">var</span> arena_allocator = ArenaAllocator.init(std.testing.allocator);</span>
<span class="line" id="L3011">            <span class="tok-kw">defer</span> arena_allocator.deinit();</span>
<span class="line" id="L3012">            <span class="tok-kw">const</span> a = arena_allocator.allocator();</span>
<span class="line" id="L3013"></span>
<span class="line" id="L3014">            <span class="tok-comment">// Create two internal buffers</span>
</span>
<span class="line" id="L3015">            _ = <span class="tok-kw">try</span> a.alloc(<span class="tok-type">u8</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L3016">            _ = <span class="tok-kw">try</span> a.alloc(<span class="tok-type">u8</span>, <span class="tok-number">1000</span>);</span>
<span class="line" id="L3017"></span>
<span class="line" id="L3018">            <span class="tok-comment">// Check that we have at least two buffers</span>
</span>
<span class="line" id="L3019">            <span class="tok-kw">try</span> std.testing.expect(arena_allocator.state.buffer_list.first.?.next != <span class="tok-null">null</span>);</span>
<span class="line" id="L3020"></span>
<span class="line" id="L3021">            <span class="tok-comment">// This retains the first allocated buffer</span>
</span>
<span class="line" id="L3022">            <span class="tok-kw">try</span> std.testing.expect(arena_allocator.reset(.{ .retain_with_limit = <span class="tok-number">1</span> }));</span>
<span class="line" id="L3023">        }</span>
<span class="line" id="L3024">        {</span>
<span class="line" id="L3025">            <span class="tok-kw">var</span> arena_allocator = ArenaAllocator.init(std.testing.allocator);</span>
<span class="line" id="L3026">            <span class="tok-kw">defer</span> arena_allocator.deinit();</span>
<span class="line" id="L3027">            <span class="tok-kw">const</span> a = arena_allocator.allocator();</span>
<span class="line" id="L3028">            <span class="tok-kw">var</span> buf = <span class="tok-kw">try</span> a.alloc(<span class="tok-type">u8</span>, <span class="tok-number">100</span>);</span>
<span class="line" id="L3029">            buf = <span class="tok-kw">try</span> a.realloc(buf, <span class="tok-number">50</span>);</span>
<span class="line" id="L3030">            <span class="tok-kw">try</span> testing.expectEqual(buf.len, <span class="tok-number">50</span>);</span>
<span class="line" id="L3031">            buf = <span class="tok-kw">try</span> a.realloc(buf, <span class="tok-number">60</span>);</span>
<span class="line" id="L3032">            <span class="tok-kw">try</span> testing.expectEqual(buf.len, <span class="tok-number">60</span>);</span>
<span class="line" id="L3033">        }</span>
<span class="line" id="L3034">    }</span>
<span class="line" id="L3035">}</span>
<span class="line" id="L3036"></span>
<span class="line" id="L3037"><span class="tok-kw">test</span> <span class="tok-str">&quot;constructors&quot;</span> {</span>
<span class="line" id="L3038">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3039">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3040">    {</span>
<span class="line" id="L3041">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newEmpty(arena.allocator());</span>
<span class="line" id="L3042">        <span class="tok-kw">try</span> testing.expectEqual(str1.len(), <span class="tok-number">0</span>);</span>
<span class="line" id="L3043">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3044">        <span class="tok-kw">try</span> testing.expectEqual(str2.len(), <span class="tok-number">11</span>);</span>
<span class="line" id="L3045">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> JStringUnmanaged.newFromJStringUnmanaged(arena.allocator(), str2);</span>
<span class="line" id="L3046">        <span class="tok-kw">try</span> testing.expectEqual(str3.len(), <span class="tok-number">11</span>);</span>
<span class="line" id="L3047">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> JStringUnmanaged.newFromFormat(arena.allocator(), <span class="tok-str">&quot;{s}&quot;</span>, .{<span class="tok-str">&quot;jstring&quot;</span>});</span>
<span class="line" id="L3048">        <span class="tok-kw">try</span> testing.expectEqual(str4.len(), <span class="tok-number">7</span>);</span>
<span class="line" id="L3049">        <span class="tok-kw">const</span> str5 = <span class="tok-kw">try</span> JStringUnmanaged.newFromTuple(arena.allocator(), .{ <span class="tok-str">&quot;jstring&quot;</span>, <span class="tok-number">5</span> });</span>
<span class="line" id="L3050">        <span class="tok-kw">try</span> testing.expectEqual(str5.len(), <span class="tok-number">8</span>);</span>
<span class="line" id="L3051">        <span class="tok-kw">const</span> str6 = <span class="tok-kw">try</span> JStringUnmanaged.newFromNumber(arena.allocator(), <span class="tok-type">i32</span>, -<span class="tok-number">5</span>);</span>
<span class="line" id="L3052">        <span class="tok-kw">try</span> testing.expect(str6.eqlSlice(<span class="tok-str">&quot;-5&quot;</span>));</span>
<span class="line" id="L3053">        <span class="tok-kw">const</span> str7 = <span class="tok-kw">try</span> JStringUnmanaged.newFromNumber(arena.allocator(), <span class="tok-type">f32</span>, -<span class="tok-number">5.5</span>);</span>
<span class="line" id="L3054">        <span class="tok-kw">try</span> testing.expect(str7.eqlSlice(<span class="tok-str">&quot;-5.5&quot;</span>));</span>
<span class="line" id="L3055">        <span class="tok-kw">const</span> TestType = <span class="tok-kw">struct</span> { a: <span class="tok-type">i32</span>, b: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> };</span>
<span class="line" id="L3056">        <span class="tok-kw">const</span> str8 = <span class="tok-kw">try</span> JStringUnmanaged.newFromStringify(arena.allocator(), TestType{ .a = <span class="tok-number">123</span>, .b = <span class="tok-str">&quot;xy&quot;</span> });</span>
<span class="line" id="L3057">        <span class="tok-kw">try</span> testing.expect(str8.eqlSlice(<span class="tok-str">&quot;{\&quot;a\&quot;:123,\&quot;b\&quot;:\&quot;xy\&quot;}&quot;</span>));</span>
<span class="line" id="L3058">        <span class="tok-kw">const</span> str9 = <span class="tok-kw">try</span> JStringUnmanaged.newFromStringifyWithOptions(arena.allocator(), TestType{ .a = <span class="tok-number">123</span>, .b = <span class="tok-str">&quot;xy&quot;</span> }, .{ .whitespace = .indent_2 });</span>
<span class="line" id="L3059">        <span class="tok-kw">const</span> str9value =</span>
<span class="line" id="L3060">            <span class="tok-str">\\{</span></span>

<span class="line" id="L3061">            <span class="tok-str">\\  &quot;a&quot;: 123,</span></span>

<span class="line" id="L3062">            <span class="tok-str">\\  &quot;b&quot;: &quot;xy&quot;</span></span>

<span class="line" id="L3063">            <span class="tok-str">\\}</span></span>

<span class="line" id="L3064">        ;</span>
<span class="line" id="L3065">        <span class="tok-kw">try</span> testing.expect(str9.eqlSlice(str9value));</span>
<span class="line" id="L3066">    }</span>
<span class="line" id="L3067">    {</span>
<span class="line" id="L3068">        <span class="tok-kw">var</span> tmp_dir = std.testing.tmpDir(.{});</span>
<span class="line" id="L3069">        <span class="tok-kw">defer</span> tmp_dir.cleanup();</span>
<span class="line" id="L3070">        <span class="tok-kw">var</span> tmp_file = <span class="tok-kw">try</span> tmp_dir.dir.createFile(<span class="tok-str">&quot;test.txt&quot;</span>, .{ .read = <span class="tok-null">true</span> });</span>
<span class="line" id="L3071">        <span class="tok-kw">try</span> tmp_file.writeAll(<span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3072">        <span class="tok-kw">try</span> tmp_file.seekTo(<span class="tok-number">0</span>);</span>
<span class="line" id="L3073">        <span class="tok-kw">const</span> str10 = <span class="tok-kw">try</span> JStringUnmanaged.newFromFile(arena.allocator(), tmp_file);</span>
<span class="line" id="L3074">        <span class="tok-kw">try</span> testing.expect(str10.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3075">        <span class="tok-comment">// now file is at the end, so read again should give us 0 len slice</span>
</span>
<span class="line" id="L3076">        <span class="tok-kw">const</span> str11 = <span class="tok-kw">try</span> JStringUnmanaged.newFromFile(arena.allocator(), tmp_file);</span>
<span class="line" id="L3077">        <span class="tok-kw">try</span> testing.expect(str11.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3078">    }</span>
<span class="line" id="L3079">}</span>
<span class="line" id="L3080"></span>
<span class="line" id="L3081"><span class="tok-kw">test</span> <span class="tok-str">&quot;formatter&quot;</span> {</span>
<span class="line" id="L3082">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3083">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3084">    <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3085">    <span class="tok-kw">const</span> s = <span class="tok-kw">try</span> std.fmt.allocPrint(arena.allocator(), <span class="tok-str">&quot;{}&quot;</span>, .{str1});</span>
<span class="line" id="L3086">    <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, s, <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3087">}</span>
<span class="line" id="L3088"></span>
<span class="line" id="L3089"><span class="tok-kw">test</span> <span class="tok-str">&quot;utils&quot;</span> {</span>
<span class="line" id="L3090">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3091">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3092">    {</span>
<span class="line" id="L3093">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newEmpty(arena.allocator());</span>
<span class="line" id="L3094">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3095">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> JStringUnmanaged.newFromJStringUnmanaged(arena.allocator(), str2);</span>
<span class="line" id="L3096">        <span class="tok-kw">try</span> testing.expect(str1.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3097">        <span class="tok-kw">try</span> testing.expect(str1.isEmpty());</span>
<span class="line" id="L3098">        <span class="tok-kw">try</span> testing.expect(str2.eql(str3));</span>
<span class="line" id="L3099">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3100">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> str3.clone(arena.allocator());</span>
<span class="line" id="L3101">        <span class="tok-kw">try</span> testing.expect(str4.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3102">        <span class="tok-kw">try</span> testing.expect(str3.str_slice.ptr != str4.str_slice.ptr);</span>
<span class="line" id="L3103">    }</span>
<span class="line" id="L3104">    {</span>
<span class="line" id="L3105">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;zigc&quot;</span>);</span>
<span class="line" id="L3106">        <span class="tok-kw">try</span> testing.expectEqual(str1.utf8Len(), <span class="tok-number">8</span>);</span>
<span class="line" id="L3107">    }</span>
<span class="line" id="L3108">    {</span>
<span class="line" id="L3109">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot; zig  \t c\t&quot;</span>);</span>
<span class="line" id="L3110">        <span class="tok-kw">var</span> strings1 = <span class="tok-kw">try</span> str1.explode(arena.allocator(), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3111">        <span class="tok-kw">try</span> testing.expectEqual(strings1.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L3112">        <span class="tok-kw">var</span> strings2 = <span class="tok-kw">try</span> str1.explode(arena.allocator(), <span class="tok-number">2</span>);</span>
<span class="line" id="L3113">        <span class="tok-kw">try</span> testing.expectEqual(strings2.len, <span class="tok-number">2</span>);</span>
<span class="line" id="L3114">        <span class="tok-kw">try</span> testing.expect(strings2[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;zig&quot;</span>));</span>
<span class="line" id="L3115">        <span class="tok-kw">try</span> testing.expect(strings2[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3116">        strings1 = <span class="tok-kw">try</span> str1.splitByWhiteSpace(arena.allocator(), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3117">        <span class="tok-kw">try</span> testing.expectEqual(strings1.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L3118">        strings2 = <span class="tok-kw">try</span> str1.splitByWhiteSpace(arena.allocator(), <span class="tok-number">2</span>);</span>
<span class="line" id="L3119">        <span class="tok-kw">try</span> testing.expectEqual(strings2.len, <span class="tok-number">2</span>);</span>
<span class="line" id="L3120">        <span class="tok-kw">try</span> testing.expect(strings2[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;zig&quot;</span>));</span>
<span class="line" id="L3121">        <span class="tok-kw">try</span> testing.expect(strings2[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3122">    }</span>
<span class="line" id="L3123">    {</span>
<span class="line" id="L3124">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot; zig  \t c\t&quot;</span>);</span>
<span class="line" id="L3125">        <span class="tok-kw">var</span> wyhash = std.hash.Wyhash.init(<span class="tok-number">0</span>);</span>
<span class="line" id="L3126">        wyhash.update(<span class="tok-str">&quot; zig  \t c\t&quot;</span>);</span>
<span class="line" id="L3127">        <span class="tok-kw">const</span> h = wyhash.final();</span>
<span class="line" id="L3128">        <span class="tok-kw">try</span> testing.expectEqual(str1.hash(), h);</span>
<span class="line" id="L3129">    }</span>
<span class="line" id="L3130">}</span>
<span class="line" id="L3131"></span>
<span class="line" id="L3132"><span class="tok-kw">test</span> <span class="tok-str">&quot;concat&quot;</span> {</span>
<span class="line" id="L3133">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3134">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3135">    <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3136">    <span class="tok-kw">var</span> str_array_buf: [<span class="tok-number">256</span>]JStringUnmanaged = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3137">    str_array_buf[<span class="tok-number">0</span>] = str1;</span>
<span class="line" id="L3138">    <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.concatMany(arena.allocator(), str_array_buf[<span class="tok-number">0</span>..<span class="tok-number">1</span>]);</span>
<span class="line" id="L3139">    <span class="tok-kw">try</span> testing.expect(str1.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span> ** <span class="tok-number">1</span>));</span>
<span class="line" id="L3140">    <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span> ** <span class="tok-number">2</span>));</span>
<span class="line" id="L3141">    str_array_buf[<span class="tok-number">1</span>] = str2;</span>
<span class="line" id="L3142">    <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str1.concatMany(arena.allocator(), str_array_buf[<span class="tok-number">0</span>..<span class="tok-number">2</span>]);</span>
<span class="line" id="L3143">    <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span> ** <span class="tok-number">4</span>));</span>
<span class="line" id="L3144">    <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> str1.concatMany(arena.allocator(), str_array_buf[<span class="tok-number">0</span>..<span class="tok-number">0</span>]);</span>
<span class="line" id="L3145">    <span class="tok-kw">try</span> testing.expect(str4.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3146">    <span class="tok-kw">try</span> testing.expect(str4.str_slice.ptr != str1.str_slice.ptr);</span>
<span class="line" id="L3147">    <span class="tok-kw">const</span> str5 = <span class="tok-kw">try</span> str1.concatFormat(arena.allocator(), <span class="tok-str">&quot;{s}&quot;</span>, .{<span class="tok-str">&quot; jstring&quot;</span>});</span>
<span class="line" id="L3148">    <span class="tok-kw">try</span> testing.expect(str5.eqlSlice(<span class="tok-str">&quot;hello,world jstring&quot;</span>));</span>
<span class="line" id="L3149">    <span class="tok-kw">const</span> optional_6: ?<span class="tok-type">i32</span> = <span class="tok-number">6</span>;</span>
<span class="line" id="L3150">    <span class="tok-kw">const</span> error1 = _testCreateErrorUnion(<span class="tok-null">false</span>, <span class="tok-type">i32</span>, <span class="tok-number">0</span>, <span class="tok-kw">error</span>.OutOfMemory);</span>
<span class="line" id="L3151">    <span class="tok-kw">const</span> str6 = <span class="tok-kw">try</span> str1.concatTuple(arena.allocator(), .{</span>
<span class="line" id="L3152">        <span class="tok-str">&quot; jstring&quot;</span>,</span>
<span class="line" id="L3153">        <span class="tok-number">5</span>,</span>
<span class="line" id="L3154">        optional_6,</span>
<span class="line" id="L3155">        error1,</span>
<span class="line" id="L3156">    });</span>
<span class="line" id="L3157">    <span class="tok-kw">try</span> testing.expect(str6.eqlSlice(<span class="tok-str">&quot;hello,world jstring56error.OutOfMemory&quot;</span>));</span>
<span class="line" id="L3158">    <span class="tok-kw">const</span> str7 = <span class="tok-kw">try</span> str1.concat(arena.allocator(), str1);</span>
<span class="line" id="L3159">    <span class="tok-kw">try</span> testing.expect(str7.eqlSlice(<span class="tok-str">&quot;hello,worldhello,world&quot;</span>));</span>
<span class="line" id="L3160">    <span class="tok-kw">const</span> str8 = <span class="tok-kw">try</span> str1.concatSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3161">    <span class="tok-kw">try</span> testing.expect(str8.eqlSlice(<span class="tok-str">&quot;hello,worldhello&quot;</span>));</span>
<span class="line" id="L3162">    <span class="tok-kw">var</span> some_slices: [<span class="tok-number">1</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3163">    some_slices[<span class="tok-number">0</span>] = <span class="tok-str">&quot;hello&quot;</span>;</span>
<span class="line" id="L3164">    <span class="tok-kw">const</span> str9 = <span class="tok-kw">try</span> str1.concatManySlices(arena.allocator(), &amp;some_slices);</span>
<span class="line" id="L3165">    <span class="tok-kw">try</span> testing.expect(str9.eqlSlice(<span class="tok-str">&quot;hello,worldhello&quot;</span>));</span>
<span class="line" id="L3166">    <span class="tok-kw">const</span> str10 = <span class="tok-kw">try</span> str1.concatSlice(arena.allocator(), <span class="tok-str">&quot;&quot;</span>);</span>
<span class="line" id="L3167">    <span class="tok-kw">try</span> testing.expect(str10.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3168">    <span class="tok-kw">const</span> str11 = <span class="tok-kw">try</span> str1.concatManySlices(arena.allocator(), some_slices[<span class="tok-number">0</span>..<span class="tok-number">0</span>]);</span>
<span class="line" id="L3169">    <span class="tok-kw">try</span> testing.expect(str11.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3170">}</span>
<span class="line" id="L3171"></span>
<span class="line" id="L3172"><span class="tok-kw">test</span> <span class="tok-str">&quot;startsWith/endsWith&quot;</span> {</span>
<span class="line" id="L3173">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3174">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3175">    <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3176">    <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3177">    <span class="tok-kw">try</span> testing.expect(str1.startsWith(str2));</span>
<span class="line" id="L3178">    <span class="tok-kw">try</span> testing.expect(str1.startsWithSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3179">    <span class="tok-kw">try</span> testing.expect(str1.startsWithSlice(<span class="tok-str">&quot;hello&quot;</span>));</span>
<span class="line" id="L3180">    <span class="tok-kw">try</span> testing.expect(!str1.startsWithSlice(<span class="tok-str">&quot;hello,world,more&quot;</span>));</span>
<span class="line" id="L3181">    <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;world&quot;</span>);</span>
<span class="line" id="L3182">    <span class="tok-kw">try</span> testing.expect(str1.endsWith(str3));</span>
<span class="line" id="L3183">    <span class="tok-kw">try</span> testing.expect(str1.endsWithSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3184">    <span class="tok-kw">try</span> testing.expect(str1.endsWithSlice(<span class="tok-str">&quot;world&quot;</span>));</span>
<span class="line" id="L3185">    <span class="tok-kw">try</span> testing.expect(!str1.endsWithSlice(<span class="tok-str">&quot;hello,world,more&quot;</span>));</span>
<span class="line" id="L3186">}</span>
<span class="line" id="L3187"></span>
<span class="line" id="L3188"><span class="tok-kw">test</span> <span class="tok-str">&quot;trim/trimStart/trimEnd&quot;</span> {</span>
<span class="line" id="L3189">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3190">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3191">    {</span>
<span class="line" id="L3192">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  hello,world&quot;</span>);</span>
<span class="line" id="L3193">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.trimStart(arena.allocator());</span>
<span class="line" id="L3194">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3195">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str2.trimStart(arena.allocator());</span>
<span class="line" id="L3196">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3197">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  \t  &quot;</span>);</span>
<span class="line" id="L3198">        <span class="tok-kw">const</span> str5 = <span class="tok-kw">try</span> str4.trimStart(arena.allocator());</span>
<span class="line" id="L3199">        <span class="tok-kw">try</span> testing.expect(str5.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3200">    }</span>
<span class="line" id="L3201">    {</span>
<span class="line" id="L3202">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world  &quot;</span>);</span>
<span class="line" id="L3203">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.trimEnd(arena.allocator());</span>
<span class="line" id="L3204">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3205">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str2.trimEnd(arena.allocator());</span>
<span class="line" id="L3206">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3207">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  \t  &quot;</span>);</span>
<span class="line" id="L3208">        <span class="tok-kw">const</span> str5 = <span class="tok-kw">try</span> str4.trimEnd(arena.allocator());</span>
<span class="line" id="L3209">        <span class="tok-kw">try</span> testing.expect(str5.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3210">    }</span>
<span class="line" id="L3211">    {</span>
<span class="line" id="L3212">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  hello,world  &quot;</span>);</span>
<span class="line" id="L3213">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.trim(arena.allocator());</span>
<span class="line" id="L3214">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3215">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  \t  &quot;</span>);</span>
<span class="line" id="L3216">        <span class="tok-kw">const</span> str5 = <span class="tok-kw">try</span> str4.trimEnd(arena.allocator());</span>
<span class="line" id="L3217">        <span class="tok-kw">try</span> testing.expect(str5.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3218">    }</span>
<span class="line" id="L3219">    {</span>
<span class="line" id="L3220">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  &quot;</span>);</span>
<span class="line" id="L3221">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.trim(arena.allocator());</span>
<span class="line" id="L3222">        <span class="tok-kw">try</span> testing.expect(str2.isEmpty());</span>
<span class="line" id="L3223">    }</span>
<span class="line" id="L3224">}</span>
<span class="line" id="L3225"></span>
<span class="line" id="L3226"><span class="tok-kw">test</span> <span class="tok-str">&quot;chartAt/at&quot;</span> {</span>
<span class="line" id="L3227">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3228">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3229">    {</span>
<span class="line" id="L3230">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newEmpty(arena.allocator());</span>
<span class="line" id="L3231">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;abcdefg&quot;</span>);</span>
<span class="line" id="L3232">        <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">u8</span>, str1.charAt(<span class="tok-number">100</span>), <span class="tok-kw">error</span>.IndexOutOfBounds));</span>
<span class="line" id="L3233">        <span class="tok-kw">try</span> testing.expectEqual(str2.charAt(<span class="tok-number">0</span>), <span class="tok-str">'a'</span>);</span>
<span class="line" id="L3234">        <span class="tok-kw">try</span> testing.expectEqual(str2.charAt(<span class="tok-number">2</span>), <span class="tok-str">'c'</span>);</span>
<span class="line" id="L3235">        <span class="tok-kw">try</span> testing.expectEqual(str2.charAt(-<span class="tok-number">3</span>), <span class="tok-str">'e'</span>);</span>
<span class="line" id="L3236">        <span class="tok-kw">try</span> testing.expectEqual(str2.charAt(-<span class="tok-number">7</span>), <span class="tok-str">'a'</span>);</span>
<span class="line" id="L3237">        <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">u8</span>, str2.charAt(-<span class="tok-number">100</span>), <span class="tok-kw">error</span>.IndexOutOfBounds));</span>
<span class="line" id="L3238">    }</span>
<span class="line" id="L3239">    {</span>
<span class="line" id="L3240">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;zigc&quot;</span>);</span>
<span class="line" id="L3241">        <span class="tok-kw">try</span> testing.expectEqual(str1.at(<span class="tok-number">0</span>), <span class="tok-str">'z'</span>);</span>
<span class="line" id="L3242">        <span class="tok-kw">try</span> testing.expectEqual(str1.at(<span class="tok-number">3</span>), <span class="tok-str">''</span>);</span>
<span class="line" id="L3243">        <span class="tok-kw">try</span> testing.expectEqual(str1.at(-<span class="tok-number">1</span>), <span class="tok-str">''</span>);</span>
<span class="line" id="L3244">        <span class="tok-kw">try</span> testing.expectEqual(str1.at(-<span class="tok-number">8</span>), <span class="tok-str">'z'</span>);</span>
<span class="line" id="L3245">        <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">u21</span>, str1.at(<span class="tok-number">100</span>), <span class="tok-kw">error</span>.IndexOutOfBounds));</span>
<span class="line" id="L3246">        <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">u21</span>, str1.at(-<span class="tok-number">100</span>), <span class="tok-kw">error</span>.IndexOutOfBounds));</span>
<span class="line" id="L3247">    }</span>
<span class="line" id="L3248">}</span>
<span class="line" id="L3249"></span>
<span class="line" id="L3250"><span class="tok-kw">test</span> <span class="tok-str">&quot;iterator/reverseIterator/utf8Iterator&quot;</span> {</span>
<span class="line" id="L3251">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3252">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3253">    {</span>
<span class="line" id="L3254">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newEmpty(arena.allocator());</span>
<span class="line" id="L3255">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;ab&quot;</span>);</span>
<span class="line" id="L3256">        <span class="tok-kw">var</span> it1 = str1.iterator();</span>
<span class="line" id="L3257">        <span class="tok-kw">try</span> testing.expectEqual(it1.next(), <span class="tok-null">null</span>);</span>
<span class="line" id="L3258">        <span class="tok-kw">var</span> it2 = str2.iterator();</span>
<span class="line" id="L3259">        <span class="tok-kw">try</span> testing.expectEqual(it2.next(), <span class="tok-str">'a'</span>);</span>
<span class="line" id="L3260">        <span class="tok-kw">try</span> testing.expectEqual(it2.next(), <span class="tok-str">'b'</span>);</span>
<span class="line" id="L3261">        <span class="tok-kw">try</span> testing.expectEqual(it2.next(), <span class="tok-null">null</span>);</span>
<span class="line" id="L3262">        <span class="tok-kw">var</span> it3 = str2.reverseIterator();</span>
<span class="line" id="L3263">        <span class="tok-kw">try</span> testing.expectEqual(it3.next(), <span class="tok-str">'b'</span>);</span>
<span class="line" id="L3264">        <span class="tok-kw">try</span> testing.expectEqual(it3.next(), <span class="tok-str">'a'</span>);</span>
<span class="line" id="L3265">        <span class="tok-kw">try</span> testing.expectEqual(it3.next(), <span class="tok-null">null</span>);</span>
<span class="line" id="L3266">    }</span>
<span class="line" id="L3267">    {</span>
<span class="line" id="L3268">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;zigc&quot;</span>);</span>
<span class="line" id="L3269">        <span class="tok-kw">var</span> it1 = <span class="tok-kw">try</span> str1.utf8Iterator();</span>
<span class="line" id="L3270">        <span class="tok-kw">try</span> testing.expectEqual(it1.nextCodepoint(), <span class="tok-str">'z'</span>);</span>
<span class="line" id="L3271">    }</span>
<span class="line" id="L3272">}</span>
<span class="line" id="L3273"></span>
<span class="line" id="L3274"><span class="tok-kw">test</span> <span class="tok-str">&quot;padStart/padEnd&quot;</span> {</span>
<span class="line" id="L3275">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3276">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3277">    {</span>
<span class="line" id="L3278">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3279">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.padStart(arena.allocator(), <span class="tok-number">12</span>, <span class="tok-str">&quot;welcome&quot;</span>);</span>
<span class="line" id="L3280">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;welcomehello&quot;</span>));</span>
<span class="line" id="L3281">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str1.padStart(arena.allocator(), <span class="tok-number">15</span>, <span class="tok-str">&quot;welcome&quot;</span>);</span>
<span class="line" id="L3282">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;omewelcomehello&quot;</span>));</span>
<span class="line" id="L3283">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> str1.padStart(arena.allocator(), <span class="tok-number">4</span>, <span class="tok-str">&quot;welcome&quot;</span>);</span>
<span class="line" id="L3284">        <span class="tok-kw">try</span> testing.expect(str4.eqlSlice(<span class="tok-str">&quot;hello&quot;</span>));</span>
<span class="line" id="L3285">    }</span>
<span class="line" id="L3286">    {</span>
<span class="line" id="L3287">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3288">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.padEnd(arena.allocator(), <span class="tok-number">10</span>, <span class="tok-str">&quot;world&quot;</span>);</span>
<span class="line" id="L3289">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;helloworld&quot;</span>));</span>
<span class="line" id="L3290">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str1.padEnd(arena.allocator(), <span class="tok-number">13</span>, <span class="tok-str">&quot;world&quot;</span>);</span>
<span class="line" id="L3291">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;helloworldwor&quot;</span>));</span>
<span class="line" id="L3292">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> str1.padEnd(arena.allocator(), <span class="tok-number">4</span>, <span class="tok-str">&quot;welcome&quot;</span>);</span>
<span class="line" id="L3293">        <span class="tok-kw">try</span> testing.expect(str4.eqlSlice(<span class="tok-str">&quot;hello&quot;</span>));</span>
<span class="line" id="L3294">    }</span>
<span class="line" id="L3295">    {</span>
<span class="line" id="L3296">        <span class="tok-comment">// zig = 0x7a 0x69 0x67 0xf0 0x9f 0x92 0xaf, 7 bytes</span>
</span>
<span class="line" id="L3297">        <span class="tok-kw">const</span> raw_bytes = <span class="tok-str">&quot;zig&quot;</span>;</span>
<span class="line" id="L3298">        <span class="tok-kw">const</span> wrong_raw_bytes = raw_bytes[<span class="tok-number">0</span>..<span class="tok-number">6</span>]; <span class="tok-comment">// now this is corrupted unicode string</span>
</span>
<span class="line" id="L3299">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), wrong_raw_bytes);</span>
<span class="line" id="L3300">        <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">u21</span>, str1.at(<span class="tok-number">4</span>), <span class="tok-kw">error</span>.InvalidUtf8));</span>
<span class="line" id="L3301">    }</span>
<span class="line" id="L3302">}</span>
<span class="line" id="L3303"></span>
<span class="line" id="L3304"><span class="tok-kw">test</span> <span class="tok-str">&quot;indexOf/lastIndexOf/includes/search&quot;</span> {</span>
<span class="line" id="L3305">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3306">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3307">    {</span>
<span class="line" id="L3308">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,worldhello,world&quot;</span>);</span>
<span class="line" id="L3309">        <span class="tok-kw">try</span> testing.expectEqual(str1.indexOf(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L3310">        <span class="tok-kw">try</span> testing.expectEqual(str1.lastIndexOf(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">11</span>);</span>
<span class="line" id="L3311">        <span class="tok-kw">try</span> testing.expectEqual(str1.indexOf(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">6</span>), <span class="tok-number">11</span>);</span>
<span class="line" id="L3312">        <span class="tok-kw">try</span> testing.expectEqual(str1.indexOf(<span class="tok-str">&quot;nothere&quot;</span>, <span class="tok-number">0</span>), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3313">        <span class="tok-kw">try</span> testing.expectEqual(str1.indexOf(<span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L3314">        <span class="tok-kw">try</span> testing.expectEqual(str1.indexOf(<span class="tok-str">&quot;&quot;</span>, <span class="tok-number">6</span>), <span class="tok-number">6</span>);</span>
<span class="line" id="L3315">        <span class="tok-kw">try</span> testing.expectEqual(str1.lastIndexOf(<span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">21</span>);</span>
<span class="line" id="L3316">        <span class="tok-kw">try</span> testing.expectEqual(str1.lastIndexOf(<span class="tok-str">&quot;&quot;</span>, <span class="tok-number">6</span>), <span class="tok-number">21</span>);</span>
<span class="line" id="L3317">        <span class="tok-kw">try</span> testing.expect(str1.includes(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L3318">        <span class="tok-kw">try</span> testing.expect(!str1.includes(<span class="tok-str">&quot;nothere&quot;</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L3319">    }</span>
<span class="line" id="L3320">    {</span>
<span class="line" id="L3321">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,worldhello,world&quot;</span>);</span>
<span class="line" id="L3322">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L3323">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastLastIndexOf(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">11</span>);</span>
<span class="line" id="L3324">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">6</span>), <span class="tok-number">11</span>);</span>
<span class="line" id="L3325">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;nothere&quot;</span>, <span class="tok-number">0</span>), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3326">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L3327">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">6</span>), <span class="tok-number">6</span>);</span>
<span class="line" id="L3328">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastLastIndexOf(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">21</span>);</span>
<span class="line" id="L3329">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastLastIndexOf(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">6</span>), <span class="tok-number">21</span>);</span>
<span class="line" id="L3330">        <span class="tok-kw">try</span> testing.expect(str2.fastIncludes(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L3331">        <span class="tok-kw">try</span> testing.expect(!str2.fastIncludes(arena.allocator(), <span class="tok-str">&quot;nothere&quot;</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L3332">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">20</span>), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3333">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">24</span>), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3334">    }</span>
<span class="line" id="L3335">    {</span>
<span class="line" id="L3336">        <span class="tok-comment">// TODO: more kmp test cases</span>
</span>
<span class="line" id="L3337">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;GATCCATATG&quot;</span>);</span>
<span class="line" id="L3338">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(arena.allocator(), <span class="tok-str">&quot;ATAT&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">5</span>);</span>
<span class="line" id="L3339">    }</span>
<span class="line" id="L3340">    {</span>
<span class="line" id="L3341">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3342">        <span class="tok-kw">try</span> testing.expectEqual(str1.indexOf(<span class="tok-str">&quot;hello,world&quot;</span>, <span class="tok-number">0</span>), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3343">        <span class="tok-kw">try</span> testing.expectEqual(str1.search(<span class="tok-str">&quot;hello,world&quot;</span>, <span class="tok-number">0</span>), -<span class="tok-number">1</span>);</span>
<span class="line" id="L3344">    }</span>
<span class="line" id="L3345">}</span>
<span class="line" id="L3346"></span>
<span class="line" id="L3347"><span class="tok-kw">test</span> <span class="tok-str">&quot;repeat&quot;</span> {</span>
<span class="line" id="L3348">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3349">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3350">    {</span>
<span class="line" id="L3351">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3352">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.repeat(arena.allocator(), <span class="tok-number">2</span>);</span>
<span class="line" id="L3353">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hellohello&quot;</span>));</span>
<span class="line" id="L3354">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str1.repeat(arena.allocator(), <span class="tok-number">0</span>);</span>
<span class="line" id="L3355">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3356">    }</span>
<span class="line" id="L3357">}</span>
<span class="line" id="L3358"></span>
<span class="line" id="L3359"><span class="tok-kw">test</span> <span class="tok-str">&quot;slice&quot;</span> {</span>
<span class="line" id="L3360">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3361">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3362">    {</span>
<span class="line" id="L3363">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3364">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.sliceWithStartOnly(arena.allocator(), <span class="tok-number">0</span>);</span>
<span class="line" id="L3365">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3366">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str1.sliceWithStartOnly(arena.allocator(), <span class="tok-number">6</span>);</span>
<span class="line" id="L3367">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;world&quot;</span>));</span>
<span class="line" id="L3368">        <span class="tok-kw">const</span> str4 = <span class="tok-kw">try</span> str1.sliceWithStartOnly(arena.allocator(), -<span class="tok-number">5</span>);</span>
<span class="line" id="L3369">        <span class="tok-kw">try</span> testing.expect(str4.eqlSlice(<span class="tok-str">&quot;world&quot;</span>));</span>
<span class="line" id="L3370">        <span class="tok-kw">const</span> str5 = <span class="tok-kw">try</span> str1.sliceWithStartOnly(arena.allocator(), -<span class="tok-number">11</span>);</span>
<span class="line" id="L3371">        <span class="tok-kw">try</span> testing.expect(str5.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3372">        <span class="tok-kw">var</span> r = str1.sliceWithStartOnly(arena.allocator(), -<span class="tok-number">15</span>);</span>
<span class="line" id="L3373">        <span class="tok-kw">try</span> testing.expectEqual(r, <span class="tok-kw">error</span>.IndexOutOfBounds);</span>
<span class="line" id="L3374">        r = str1.slice(arena.allocator(), <span class="tok-number">0</span>, -<span class="tok-number">15</span>);</span>
<span class="line" id="L3375">        <span class="tok-kw">try</span> testing.expectEqual(r, <span class="tok-kw">error</span>.IndexOutOfBounds);</span>
<span class="line" id="L3376">        <span class="tok-kw">const</span> str6 = <span class="tok-kw">try</span> str1.slice(arena.allocator(), <span class="tok-number">15</span>, <span class="tok-number">7</span>);</span>
<span class="line" id="L3377">        <span class="tok-kw">try</span> testing.expect(str6.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3378">        <span class="tok-kw">const</span> str7 = <span class="tok-kw">try</span> str1.slice(arena.allocator(), <span class="tok-number">8</span>, <span class="tok-number">7</span>);</span>
<span class="line" id="L3379">        <span class="tok-kw">try</span> testing.expect(str7.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3380">        <span class="tok-kw">const</span> str8 = <span class="tok-kw">try</span> str1.slice(arena.allocator(), <span class="tok-number">6</span>, <span class="tok-number">15</span>);</span>
<span class="line" id="L3381">        <span class="tok-kw">try</span> testing.expect(str8.eqlSlice(<span class="tok-str">&quot;world&quot;</span>));</span>
<span class="line" id="L3382">        <span class="tok-kw">const</span> str9 = <span class="tok-kw">try</span> str1.slice(arena.allocator(), <span class="tok-number">6</span>, <span class="tok-number">8</span>);</span>
<span class="line" id="L3383">        <span class="tok-kw">try</span> testing.expect(str9.eqlSlice(<span class="tok-str">&quot;wo&quot;</span>));</span>
<span class="line" id="L3384">        <span class="tok-kw">const</span> str10 = <span class="tok-kw">try</span> str1.slice(arena.allocator(), <span class="tok-number">6</span>, -<span class="tok-number">3</span>);</span>
<span class="line" id="L3385">        <span class="tok-kw">try</span> testing.expect(str10.eqlSlice(<span class="tok-str">&quot;wo&quot;</span>));</span>
<span class="line" id="L3386">    }</span>
<span class="line" id="L3387">}</span>
<span class="line" id="L3388"></span>
<span class="line" id="L3389"><span class="tok-kw">test</span> <span class="tok-str">&quot;toLowerCase/toUpperCase&quot;</span> {</span>
<span class="line" id="L3390">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3391">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3392">    {</span>
<span class="line" id="L3393">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hEllO,woRld&quot;</span>);</span>
<span class="line" id="L3394">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.toUpperCase(arena.allocator());</span>
<span class="line" id="L3395">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;HELLO,WORLD&quot;</span>));</span>
<span class="line" id="L3396">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str1.toLowerCase(arena.allocator());</span>
<span class="line" id="L3397">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3398">    }</span>
<span class="line" id="L3399">    {</span>
<span class="line" id="L3400">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;&quot;</span>);</span>
<span class="line" id="L3401">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.toUpperCase(arena.allocator());</span>
<span class="line" id="L3402">        <span class="tok-kw">try</span> testing.expect(str2.isEmpty());</span>
<span class="line" id="L3403">        str2 = <span class="tok-kw">try</span> str1.toLowerCase(arena.allocator());</span>
<span class="line" id="L3404">        <span class="tok-kw">try</span> testing.expect(str2.isEmpty());</span>
<span class="line" id="L3405">    }</span>
<span class="line" id="L3406">}</span>
<span class="line" id="L3407"></span>
<span class="line" id="L3408"><span class="tok-kw">test</span> <span class="tok-str">&quot;split&quot;</span> {</span>
<span class="line" id="L3409">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3410">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3411">    {</span>
<span class="line" id="L3412">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3413">        <span class="tok-kw">var</span> strings1 = <span class="tok-kw">try</span> str1.split(arena.allocator(), <span class="tok-str">&quot;,&quot;</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3414">        <span class="tok-kw">try</span> testing.expectEqual(strings1.len, <span class="tok-number">2</span>);</span>
<span class="line" id="L3415">        <span class="tok-kw">try</span> testing.expect(strings1[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;hello&quot;</span>));</span>
<span class="line" id="L3416">        <span class="tok-kw">try</span> testing.expect(strings1[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;world&quot;</span>));</span>
<span class="line" id="L3417">        <span class="tok-kw">var</span> strings2 = <span class="tok-kw">try</span> str1.split(arena.allocator(), <span class="tok-str">&quot;,&quot;</span>, <span class="tok-number">1</span>);</span>
<span class="line" id="L3418">        <span class="tok-kw">try</span> testing.expectEqual(strings2.len, <span class="tok-number">1</span>);</span>
<span class="line" id="L3419">        <span class="tok-kw">try</span> testing.expect(strings2[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;hello&quot;</span>));</span>
<span class="line" id="L3420">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;\thello  world &quot;</span>);</span>
<span class="line" id="L3421">        <span class="tok-kw">var</span> strings3 = <span class="tok-kw">try</span> str2.split(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3422">        <span class="tok-kw">try</span> testing.expectEqual(strings3.len, <span class="tok-number">15</span>);</span>
<span class="line" id="L3423">        <span class="tok-kw">try</span> testing.expect(strings3[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;\t&quot;</span>));</span>
<span class="line" id="L3424">        <span class="tok-kw">try</span> testing.expect(strings3[<span class="tok-number">7</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3425">        <span class="tok-kw">try</span> testing.expect(strings3[<span class="tok-number">13</span>].eqlSlice(<span class="tok-str">&quot;d&quot;</span>));</span>
<span class="line" id="L3426">    }</span>
<span class="line" id="L3427">    {</span>
<span class="line" id="L3428">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3429">        <span class="tok-kw">var</span> strings = <span class="tok-kw">try</span> str1.split(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3430">        <span class="tok-kw">try</span> testing.expectEqual(strings.len, <span class="tok-number">5</span>);</span>
<span class="line" id="L3431">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;h&quot;</span>));</span>
<span class="line" id="L3432">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;e&quot;</span>));</span>
<span class="line" id="L3433">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;l&quot;</span>));</span>
<span class="line" id="L3434">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">3</span>].eqlSlice(<span class="tok-str">&quot;l&quot;</span>));</span>
<span class="line" id="L3435">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">4</span>].eqlSlice(<span class="tok-str">&quot;o&quot;</span>));</span>
<span class="line" id="L3436">        strings = <span class="tok-kw">try</span> str1.split(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">3</span>);</span>
<span class="line" id="L3437">        <span class="tok-kw">try</span> testing.expectEqual(strings.len, <span class="tok-number">3</span>);</span>
<span class="line" id="L3438">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;h&quot;</span>));</span>
<span class="line" id="L3439">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;e&quot;</span>));</span>
<span class="line" id="L3440">        <span class="tok-kw">try</span> testing.expect(strings[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;l&quot;</span>));</span>
<span class="line" id="L3441">        strings = <span class="tok-kw">try</span> str1.split(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3442">        <span class="tok-kw">try</span> testing.expectEqual(strings.len, <span class="tok-number">0</span>);</span>
<span class="line" id="L3443">    }</span>
<span class="line" id="L3444">}</span>
<span class="line" id="L3445"></span>
<span class="line" id="L3446"><span class="tok-kw">test</span> <span class="tok-str">&quot;RegexUnmanged&quot;</span> {</span>
<span class="line" id="L3447">    <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L3448">        <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3449">        <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3450">        {</span>
<span class="line" id="L3451">            <span class="tok-kw">const</span> re = RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3452">            <span class="tok-kw">try</span> testing.expect(_testIsError(RegexUnmanaged, re, JStringError.RegexBadPattern));</span>
<span class="line" id="L3453">        }</span>
<span class="line" id="L3454">        {</span>
<span class="line" id="L3455">            <span class="tok-kw">const</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(hello&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3456">            <span class="tok-kw">try</span> testing.expect(!re.succeed());</span>
<span class="line" id="L3457">            <span class="tok-kw">try</span> testing.expectEqual(re.errorNumber(), <span class="tok-number">114</span>);</span>
<span class="line" id="L3458">            <span class="tok-kw">try</span> testing.expectEqual(re.errorOffset(), <span class="tok-number">6</span>);</span>
<span class="line" id="L3459">            <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, re.errorMessage(), <span class="tok-str">&quot;PCRE2 compilation failed at offset 6: missing closing parenthesis\n&quot;</span>);</span>
<span class="line" id="L3460">        }</span>
<span class="line" id="L3461">        {</span>
<span class="line" id="L3462">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3463">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3464">            re.deinit(arena.allocator());</span>
<span class="line" id="L3465">        }</span>
<span class="line" id="L3466">        {</span>
<span class="line" id="L3467">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(?&lt;H&gt;hel+o)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3468">            <span class="tok-kw">try</span> re.matchAll(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3469">            re.deinit(arena.allocator());</span>
<span class="line" id="L3470">        }</span>
<span class="line" id="L3471">        {</span>
<span class="line" id="L3472">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3473">            <span class="tok-kw">try</span> testing.expectEqual(re.errorNumber(), <span class="tok-number">100</span>);</span>
<span class="line" id="L3474">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3475">            <span class="tok-kw">try</span> testing.expect(re.matchSucceed());</span>
<span class="line" id="L3476">            <span class="tok-kw">const</span> matched_results = re.getResults();</span>
<span class="line" id="L3477">            <span class="tok-kw">try</span> testing.expect(matched_results != <span class="tok-null">null</span>);</span>
<span class="line" id="L3478">            <span class="tok-kw">if</span> (matched_results) |mr| {</span>
<span class="line" id="L3479">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].start == <span class="tok-number">0</span>);</span>
<span class="line" id="L3480">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L3481">            }</span>
<span class="line" id="L3482">        }</span>
<span class="line" id="L3483">        {</span>
<span class="line" id="L3484">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3485">            <span class="tok-kw">try</span> testing.expectEqual(re.errorNumber(), <span class="tok-number">100</span>);</span>
<span class="line" id="L3486">            <span class="tok-kw">try</span> re.matchAll(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3487">            <span class="tok-kw">try</span> testing.expect(re.matchSucceed());</span>
<span class="line" id="L3488">            <span class="tok-kw">const</span> matched_results = re.getResults();</span>
<span class="line" id="L3489">            <span class="tok-kw">try</span> testing.expect(matched_results != <span class="tok-null">null</span>);</span>
<span class="line" id="L3490">            <span class="tok-kw">if</span> (matched_results) |mr| {</span>
<span class="line" id="L3491">                <span class="tok-kw">try</span> testing.expect(mr.len == <span class="tok-number">2</span>);</span>
<span class="line" id="L3492">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].start == <span class="tok-number">0</span>);</span>
<span class="line" id="L3493">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L3494">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">1</span>].start == <span class="tok-number">6</span>);</span>
<span class="line" id="L3495">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">1</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L3496">            }</span>
<span class="line" id="L3497">        }</span>
<span class="line" id="L3498">        {</span>
<span class="line" id="L3499">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(?&lt;h&gt;hel+o)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3500">            <span class="tok-kw">try</span> testing.expectEqual(re.errorNumber(), <span class="tok-number">100</span>);</span>
<span class="line" id="L3501">            <span class="tok-kw">try</span> re.matchAll(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3502">            <span class="tok-kw">try</span> testing.expect(re.matchSucceed());</span>
<span class="line" id="L3503">            <span class="tok-kw">const</span> matched_results = re.getResults();</span>
<span class="line" id="L3504">            <span class="tok-kw">try</span> testing.expect(matched_results != <span class="tok-null">null</span>);</span>
<span class="line" id="L3505">            <span class="tok-kw">if</span> (matched_results) |mr| {</span>
<span class="line" id="L3506">                <span class="tok-kw">try</span> testing.expect(mr.len == <span class="tok-number">2</span>);</span>
<span class="line" id="L3507">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].start == <span class="tok-number">0</span>);</span>
<span class="line" id="L3508">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L3509">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">1</span>].start == <span class="tok-number">6</span>);</span>
<span class="line" id="L3510">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">1</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L3511">            }</span>
<span class="line" id="L3512">            <span class="tok-kw">const</span> matched_group_results = re.getGroupResults();</span>
<span class="line" id="L3513">            <span class="tok-kw">try</span> testing.expect(matched_group_results != <span class="tok-null">null</span>);</span>
<span class="line" id="L3514">            <span class="tok-kw">if</span> (matched_group_results) |mgr| {</span>
<span class="line" id="L3515">                <span class="tok-kw">try</span> testing.expect(mgr.len == <span class="tok-number">2</span>);</span>
<span class="line" id="L3516">                <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, mgr[<span class="tok-number">0</span>].name[<span class="tok-number">0</span>..mgr[<span class="tok-number">0</span>].name_len], <span class="tok-str">&quot;h&quot;</span>);</span>
<span class="line" id="L3517">                <span class="tok-kw">try</span> testing.expect(mgr[<span class="tok-number">0</span>].start == <span class="tok-number">0</span>);</span>
<span class="line" id="L3518">                <span class="tok-kw">try</span> testing.expect(mgr[<span class="tok-number">0</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L3519">                <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, mgr[<span class="tok-number">1</span>].name[<span class="tok-number">0</span>..mgr[<span class="tok-number">1</span>].name_len], <span class="tok-str">&quot;h&quot;</span>);</span>
<span class="line" id="L3520">                <span class="tok-kw">try</span> testing.expect(mgr[<span class="tok-number">1</span>].start == <span class="tok-number">6</span>);</span>
<span class="line" id="L3521">                <span class="tok-kw">try</span> testing.expect(mgr[<span class="tok-number">1</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L3522">            }</span>
<span class="line" id="L3523">        }</span>
<span class="line" id="L3524">        {</span>
<span class="line" id="L3525">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(?&lt;h&gt;hel+o)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3526">            <span class="tok-kw">try</span> re.matchAll(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3527">            re.deinit(arena.allocator());</span>
<span class="line" id="L3528">        }</span>
<span class="line" id="L3529">        {</span>
<span class="line" id="L3530">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3531">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3532">            <span class="tok-kw">const</span> match_results = re.getResults();</span>
<span class="line" id="L3533">            <span class="tok-kw">const</span> group_results = re.getGroupResults();</span>
<span class="line" id="L3534">            _ = group_results;</span>
<span class="line" id="L3535">            <span class="tok-kw">if</span> (match_results) |mrs| {</span>
<span class="line" id="L3536">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">0</span>].start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3537">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">0</span>].len, <span class="tok-number">8</span>);</span>
<span class="line" id="L3538">            }</span>
<span class="line" id="L3539">        }</span>
<span class="line" id="L3540">        {</span>
<span class="line" id="L3541">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3542">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3543">            <span class="tok-kw">try</span> re.reset(arena.allocator());</span>
<span class="line" id="L3544">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3545">            <span class="tok-kw">const</span> match_results = re.getResults();</span>
<span class="line" id="L3546">            <span class="tok-kw">const</span> group_results = re.getGroupResults();</span>
<span class="line" id="L3547">            _ = group_results;</span>
<span class="line" id="L3548">            <span class="tok-kw">if</span> (match_results) |mrs| {</span>
<span class="line" id="L3549">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">0</span>].start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3550">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">0</span>].len, <span class="tok-number">8</span>);</span>
<span class="line" id="L3551">            }</span>
<span class="line" id="L3552">            <span class="tok-kw">var</span> it = re.getGroupResultsIterator(<span class="tok-str">&quot;hi,hello&quot;</span>);</span>
<span class="line" id="L3553">            <span class="tok-kw">var</span> maybe_r = it.nextResult();</span>
<span class="line" id="L3554">            <span class="tok-kw">try</span> testing.expect(maybe_r != <span class="tok-null">null</span>);</span>
<span class="line" id="L3555">            <span class="tok-kw">if</span> (maybe_r) |r| {</span>
<span class="line" id="L3556">                <span class="tok-kw">try</span> testing.expect(std.mem.eql(<span class="tok-type">u8</span>, r.name, <span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3557">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3558">            }</span>
<span class="line" id="L3559">            maybe_r = it.nextResult();</span>
<span class="line" id="L3560">            <span class="tok-kw">try</span> testing.expect(maybe_r != <span class="tok-null">null</span>);</span>
<span class="line" id="L3561">            <span class="tok-kw">if</span> (maybe_r) |r| {</span>
<span class="line" id="L3562">                <span class="tok-kw">try</span> testing.expect(std.mem.eql(<span class="tok-type">u8</span>, r.name, <span class="tok-str">&quot;h&quot;</span>));</span>
<span class="line" id="L3563">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">3</span>);</span>
<span class="line" id="L3564">            }</span>
<span class="line" id="L3565">        }</span>
<span class="line" id="L3566">        {</span>
<span class="line" id="L3567">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3568">            <span class="tok-kw">try</span> re.matchAll(arena.allocator(), <span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3569">            <span class="tok-kw">const</span> match_results = re.getResults();</span>
<span class="line" id="L3570">            <span class="tok-kw">const</span> group_results = re.getGroupResults();</span>
<span class="line" id="L3571">            <span class="tok-kw">if</span> (match_results) |mrs| {</span>
<span class="line" id="L3572">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">0</span>].start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3573">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">0</span>].len, <span class="tok-number">8</span>);</span>
<span class="line" id="L3574">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">1</span>].start, <span class="tok-number">9</span>);</span>
<span class="line" id="L3575">                <span class="tok-kw">try</span> testing.expectEqual(mrs[<span class="tok-number">1</span>].len, <span class="tok-number">8</span>);</span>
<span class="line" id="L3576">            }</span>
<span class="line" id="L3577">            <span class="tok-kw">if</span> (group_results) |grs| {</span>
<span class="line" id="L3578">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">0</span>].start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3579">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">0</span>].len, <span class="tok-number">3</span>);</span>
<span class="line" id="L3580">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">1</span>].start, <span class="tok-number">3</span>);</span>
<span class="line" id="L3581">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">1</span>].len, <span class="tok-number">5</span>);</span>
<span class="line" id="L3582">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">2</span>].start, <span class="tok-number">9</span>);</span>
<span class="line" id="L3583">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">2</span>].len, <span class="tok-number">3</span>);</span>
<span class="line" id="L3584">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">3</span>].start, <span class="tok-number">12</span>);</span>
<span class="line" id="L3585">                <span class="tok-kw">try</span> testing.expectEqual(grs[<span class="tok-number">3</span>].len, <span class="tok-number">5</span>);</span>
<span class="line" id="L3586">            }</span>
<span class="line" id="L3587">        }</span>
<span class="line" id="L3588">        {</span>
<span class="line" id="L3589">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3590">            <span class="tok-kw">try</span> re.reset(arena.allocator()); <span class="tok-comment">// this should works find without error</span>
</span>
<span class="line" id="L3591">        }</span>
<span class="line" id="L3592">        {</span>
<span class="line" id="L3593">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3594">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3595">            <span class="tok-kw">var</span> maybe_r = re.getGroupResultByName(<span class="tok-str">&quot;h&quot;</span>);</span>
<span class="line" id="L3596">            <span class="tok-kw">try</span> testing.expect(maybe_r != <span class="tok-null">null</span>);</span>
<span class="line" id="L3597">            <span class="tok-kw">if</span> (maybe_r) |r| {</span>
<span class="line" id="L3598">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">3</span>);</span>
<span class="line" id="L3599">                <span class="tok-kw">try</span> testing.expectEqual(r.len, <span class="tok-number">5</span>);</span>
<span class="line" id="L3600">            }</span>
<span class="line" id="L3601">            maybe_r = re.getGroupResultByName(<span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3602">            <span class="tok-kw">try</span> testing.expect(maybe_r == <span class="tok-null">null</span>);</span>
<span class="line" id="L3603">            <span class="tok-kw">var</span> maybe_r2 = re.getGroupResultByIndex(<span class="tok-number">1</span>);</span>
<span class="line" id="L3604">            <span class="tok-kw">try</span> testing.expect(maybe_r2 != <span class="tok-null">null</span>);</span>
<span class="line" id="L3605">            <span class="tok-kw">if</span> (maybe_r2) |r| {</span>
<span class="line" id="L3606">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3607">                <span class="tok-kw">try</span> testing.expectEqual(r.len, <span class="tok-number">3</span>);</span>
<span class="line" id="L3608">            }</span>
<span class="line" id="L3609">            maybe_r2 = re.getGroupResultByIndex(<span class="tok-number">100</span>);</span>
<span class="line" id="L3610">            <span class="tok-kw">try</span> re.reset(arena.allocator());</span>
<span class="line" id="L3611">            maybe_r = re.getGroupResultByName(<span class="tok-str">&quot;h&quot;</span>);</span>
<span class="line" id="L3612">            <span class="tok-kw">try</span> testing.expect(maybe_r == <span class="tok-null">null</span>);</span>
<span class="line" id="L3613">            maybe_r2 = re.getGroupResultByIndex(<span class="tok-number">1</span>);</span>
<span class="line" id="L3614">            <span class="tok-kw">try</span> testing.expect(maybe_r2 == <span class="tok-null">null</span>);</span>
<span class="line" id="L3615">        }</span>
<span class="line" id="L3616">        {</span>
<span class="line" id="L3617">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3618">            <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">usize</span>, re.getNextOffset(<span class="tok-str">&quot;hello&quot;</span>), JStringError.RegexFetchBeforeMatch));</span>
<span class="line" id="L3619">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3620">            <span class="tok-kw">try</span> testing.expectEqual(re.getNextOffset(<span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>), <span class="tok-number">8</span>);</span>
<span class="line" id="L3621">            <span class="tok-kw">try</span> re.reset(arena.allocator());</span>
<span class="line" id="L3622">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;notsomething&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3623">            <span class="tok-kw">try</span> testing.expectEqual(re.getNextOffset(<span class="tok-str">&quot;notsomething&quot;</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L3624">        }</span>
<span class="line" id="L3625">        {</span>
<span class="line" id="L3626">            <span class="tok-comment">// example mentioned at: https://www.pcre.org/current/doc/html/pcre2pattern.html about</span>
</span>
<span class="line" id="L3627">            <span class="tok-comment">// PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK</span>
</span>
<span class="line" id="L3628">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.initWithExtraRegexOptions(arena.allocator(), <span class="tok-str">&quot;(?&lt;=\\Kfoo)bar&quot;</span>, <span class="tok-number">0</span>, pcre.PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK);</span>
<span class="line" id="L3629">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;foobar&quot;</span>, <span class="tok-number">3</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3630">            <span class="tok-kw">const</span> offset = <span class="tok-kw">try</span> re.getNextOffset(<span class="tok-str">&quot;foobar&quot;</span>);</span>
<span class="line" id="L3631">            <span class="tok-kw">try</span> testing.expectEqual(offset, <span class="tok-number">6</span>);</span>
<span class="line" id="L3632">            re.deinit(arena.allocator());</span>
<span class="line" id="L3633">        }</span>
<span class="line" id="L3634">        {</span>
<span class="line" id="L3635">            <span class="tok-comment">// this example will trigger the tricky case mentioned in pcre2 demo on get next offset.</span>
</span>
<span class="line" id="L3636">            <span class="tok-comment">// check https://pcre.org/current/doc/html/pcre2demo.html, line around comment &quot;If the previous match was</span>
</span>
<span class="line" id="L3637">            <span class="tok-comment">// not an empty string, there is one tricky case to consider.&quot;</span>
</span>
<span class="line" id="L3638">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.initWithExtraRegexOptions(arena.allocator(), <span class="tok-str">&quot;(?&lt;=\\Kfoo)&quot;</span>, pcre.PCRE2_UTF, pcre.PCRE2_EXTRA_ALLOW_LOOKAROUND_BSK);</span>
<span class="line" id="L3639">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;foobar&quot;</span>, <span class="tok-number">3</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3640">            <span class="tok-kw">var</span> offset = <span class="tok-kw">try</span> re.getNextOffset(<span class="tok-str">&quot;foobar&quot;</span>);</span>
<span class="line" id="L3641">            <span class="tok-kw">try</span> testing.expectEqual(offset, <span class="tok-number">4</span>);</span>
<span class="line" id="L3642">            <span class="tok-kw">try</span> re.reset(arena.allocator());</span>
<span class="line" id="L3643">            <span class="tok-kw">try</span> re.match(arena.allocator(), <span class="tok-str">&quot;foo&quot;</span>, <span class="tok-number">3</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3644">            offset = <span class="tok-kw">try</span> re.getNextOffset(<span class="tok-str">&quot;foo&quot;</span>);</span>
<span class="line" id="L3645">            <span class="tok-kw">try</span> testing.expectEqual(offset, <span class="tok-number">4</span>);</span>
<span class="line" id="L3646">            re.deinit(arena.allocator());</span>
<span class="line" id="L3647">        }</span>
<span class="line" id="L3648">    }</span>
<span class="line" id="L3649">}</span>
<span class="line" id="L3650"></span>
<span class="line" id="L3651"><span class="tok-kw">test</span> <span class="tok-str">&quot;match/matchAll&quot;</span> {</span>
<span class="line" id="L3652">    <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L3653">        <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3654">        <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3655">        {</span>
<span class="line" id="L3656">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3657">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> str1.match(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, RegexUnmanaged.DefaultRegexOptions, RegexUnmanaged.DefaultMatchOptions);</span>
<span class="line" id="L3658">            <span class="tok-kw">try</span> testing.expect(re.succeed());</span>
<span class="line" id="L3659">            <span class="tok-kw">var</span> it = re.getResultsIterator(str1.str_slice);</span>
<span class="line" id="L3660">            <span class="tok-kw">const</span> maybe_result = it.nextResult();</span>
<span class="line" id="L3661">            <span class="tok-kw">if</span> (maybe_result) |r| {</span>
<span class="line" id="L3662">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3663">                <span class="tok-kw">try</span> testing.expectEqual(r.len, <span class="tok-number">5</span>);</span>
<span class="line" id="L3664">                <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, r.value, <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3665">            }</span>
<span class="line" id="L3666">        }</span>
<span class="line" id="L3667">        {</span>
<span class="line" id="L3668">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3669">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> str1.matchAll(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>, RegexUnmanaged.DefaultRegexOptions, RegexUnmanaged.DefaultMatchOptions);</span>
<span class="line" id="L3670">            <span class="tok-kw">try</span> testing.expect(re.succeed());</span>
<span class="line" id="L3671">            <span class="tok-kw">var</span> it = re.getResultsIterator(str1.str_slice);</span>
<span class="line" id="L3672">            <span class="tok-kw">const</span> maybe_result = it.nextResult();</span>
<span class="line" id="L3673">            <span class="tok-kw">if</span> (maybe_result) |r| {</span>
<span class="line" id="L3674">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">0</span>);</span>
<span class="line" id="L3675">                <span class="tok-kw">try</span> testing.expectEqual(r.len, <span class="tok-number">5</span>);</span>
<span class="line" id="L3676">                <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, r.value, <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3677">            }</span>
<span class="line" id="L3678">            <span class="tok-kw">const</span> maybe_result2 = it.nextResult();</span>
<span class="line" id="L3679">            <span class="tok-kw">if</span> (maybe_result2) |r| {</span>
<span class="line" id="L3680">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">6</span>);</span>
<span class="line" id="L3681">                <span class="tok-kw">try</span> testing.expectEqual(r.len, <span class="tok-number">5</span>);</span>
<span class="line" id="L3682">                <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, r.value, <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3683">            }</span>
<span class="line" id="L3684">            <span class="tok-kw">const</span> maybe_result3 = it.nextResult();</span>
<span class="line" id="L3685">            <span class="tok-kw">try</span> testing.expectEqual(maybe_result3, <span class="tok-null">null</span>);</span>
<span class="line" id="L3686">        }</span>
<span class="line" id="L3687">    }</span>
<span class="line" id="L3688">}</span>
<span class="line" id="L3689"></span>
<span class="line" id="L3690"><span class="tok-kw">test</span> <span class="tok-str">&quot;searchByRegex&quot;</span> {</span>
<span class="line" id="L3691">    <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L3692">        <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3693">        <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3694">        {</span>
<span class="line" id="L3695">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3696">            <span class="tok-kw">var</span> r = <span class="tok-kw">try</span> str1.searchByRegex(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3697">            <span class="tok-kw">try</span> testing.expectEqual(r, <span class="tok-number">0</span>);</span>
<span class="line" id="L3698">            r = <span class="tok-kw">try</span> str1.searchByRegex(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">3</span>);</span>
<span class="line" id="L3699">            <span class="tok-kw">try</span> testing.expectEqual(r, <span class="tok-number">6</span>);</span>
<span class="line" id="L3700">            r = <span class="tok-kw">try</span> str1.searchByRegex(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">8</span>);</span>
<span class="line" id="L3701">            <span class="tok-kw">try</span> testing.expectEqual(r, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3702">        }</span>
<span class="line" id="L3703">        {</span>
<span class="line" id="L3704">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3705">            <span class="tok-kw">const</span> r = <span class="tok-kw">try</span> str1.searchByRegex(arena.allocator(), <span class="tok-str">&quot;nonexist&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3706">            <span class="tok-kw">try</span> testing.expectEqual(r, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3707">        }</span>
<span class="line" id="L3708">        {</span>
<span class="line" id="L3709">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3710">            <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">isize</span>, str1.searchByRegex(arena.allocator(), <span class="tok-str">&quot;he(?&lt;L&gt;l+&quot;</span>, <span class="tok-number">0</span>), JStringError.RegexMatchFailed));</span>
<span class="line" id="L3711">        }</span>
<span class="line" id="L3712">    }</span>
<span class="line" id="L3713">}</span>
<span class="line" id="L3714"></span>
<span class="line" id="L3715"><span class="tok-kw">test</span> <span class="tok-str">&quot;splitByRegex&quot;</span> {</span>
<span class="line" id="L3716">    <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L3717">        <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3718">        <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3719">        {</span>
<span class="line" id="L3720">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3721">            <span class="tok-kw">var</span> results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;l+&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L3722">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">1</span>);</span>
<span class="line" id="L3723">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;hello,hello,world&quot;</span>));</span>
<span class="line" id="L3724">            results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;l+&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3725">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L3726">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;he&quot;</span>));</span>
<span class="line" id="L3727">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;o,he&quot;</span>));</span>
<span class="line" id="L3728">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;o,wor&quot;</span>));</span>
<span class="line" id="L3729">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">3</span>].eqlSlice(<span class="tok-str">&quot;d&quot;</span>));</span>
<span class="line" id="L3730">            results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;he&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3731">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">3</span>);</span>
<span class="line" id="L3732">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3733">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;llo,&quot;</span>));</span>
<span class="line" id="L3734">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;llo,world&quot;</span>));</span>
<span class="line" id="L3735">            results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;lo|d&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3736">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">3</span>);</span>
<span class="line" id="L3737">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;hel&quot;</span>));</span>
<span class="line" id="L3738">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;,hel&quot;</span>));</span>
<span class="line" id="L3739">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;,worl&quot;</span>));</span>
<span class="line" id="L3740">        }</span>
<span class="line" id="L3741">        {</span>
<span class="line" id="L3742">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3743">            <span class="tok-kw">var</span> results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;(?&lt;L&gt;l+)&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3744">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L3745">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;he&quot;</span>));</span>
<span class="line" id="L3746">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;o,he&quot;</span>));</span>
<span class="line" id="L3747">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;o,wor&quot;</span>));</span>
<span class="line" id="L3748">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">3</span>].eqlSlice(<span class="tok-str">&quot;d&quot;</span>));</span>
<span class="line" id="L3749">        }</span>
<span class="line" id="L3750">        {</span>
<span class="line" id="L3751">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3752">            <span class="tok-kw">const</span> r = str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;he(?&lt;L&gt;l+)&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3753">            <span class="tok-kw">try</span> testing.expect(_testIsError([]JStringUnmanaged, r, JStringError.RegexMatchOverlapped));</span>
<span class="line" id="L3754">        }</span>
<span class="line" id="L3755">        {</span>
<span class="line" id="L3756">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3757">            <span class="tok-comment">// stupid way of splitting every char into string, but should work</span>
</span>
<span class="line" id="L3758">            <span class="tok-kw">const</span> results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;.&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3759">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">6</span>);</span>
<span class="line" id="L3760">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3761">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3762">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3763">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">3</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3764">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">4</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3765">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">5</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3766">        }</span>
<span class="line" id="L3767">        {</span>
<span class="line" id="L3768">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hhoh&quot;</span>);</span>
<span class="line" id="L3769">            <span class="tok-kw">var</span> results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;h&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3770">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L3771">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3772">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3773">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">2</span>].eqlSlice(<span class="tok-str">&quot;o&quot;</span>));</span>
<span class="line" id="L3774">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">3</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3775">            results = <span class="tok-kw">try</span> str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;h&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">2</span>);</span>
<span class="line" id="L3776">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">2</span>);</span>
<span class="line" id="L3777">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">0</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3778">            <span class="tok-kw">try</span> testing.expect(results[<span class="tok-number">1</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3779">        }</span>
<span class="line" id="L3780">        {</span>
<span class="line" id="L3781">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3782">            <span class="tok-kw">const</span> results = str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3783">            <span class="tok-kw">try</span> testing.expect(_testIsError([]JStringUnmanaged, results, JStringError.RegexBadPattern));</span>
<span class="line" id="L3784">        }</span>
<span class="line" id="L3785">        {</span>
<span class="line" id="L3786">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3787">            <span class="tok-kw">const</span> results = str1.splitByRegex(arena.allocator(), <span class="tok-str">&quot;noexist&quot;</span>, <span class="tok-number">0</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3788">            <span class="tok-kw">try</span> testing.expect(_testIsError([]JStringUnmanaged, results, JStringError.RegexMatchFailed));</span>
<span class="line" id="L3789">        }</span>
<span class="line" id="L3790">    }</span>
<span class="line" id="L3791">}</span>
<span class="line" id="L3792"></span>
<span class="line" id="L3793"><span class="tok-kw">test</span> <span class="tok-str">&quot;replace/replaceAll/replaceByRegex/replaceAllByRegex&quot;</span> {</span>
<span class="line" id="L3794">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3795">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3796">    {</span>
<span class="line" id="L3797">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3798">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.replace(arena.allocator(), <span class="tok-str">&quot;world&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L3799">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,hello,jstring&quot;</span>));</span>
<span class="line" id="L3800">        str2 = <span class="tok-kw">try</span> str1.replaceAll(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L3801">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;jstring,jstring,world&quot;</span>));</span>
<span class="line" id="L3802">        str2 = <span class="tok-kw">try</span> str1.replace(arena.allocator(), <span class="tok-str">&quot;noexist&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L3803">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,hello,world&quot;</span>));</span>
<span class="line" id="L3804">    }</span>
<span class="line" id="L3805">    <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L3806">        {</span>
<span class="line" id="L3807">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3808">            <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.replaceByRegex(arena.allocator(), <span class="tok-str">&quot;wor.d&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L3809">            <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,hello,jstring&quot;</span>));</span>
<span class="line" id="L3810">            str2 = <span class="tok-kw">try</span> str1.replaceAllByRegex(arena.allocator(), <span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L3811">            <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;jstring,jstring,world&quot;</span>));</span>
<span class="line" id="L3812">            <span class="tok-kw">const</span> r = str1.replaceByRegex(arena.allocator(), <span class="tok-str">&quot;noexiststring&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L3813">            <span class="tok-kw">try</span> testing.expect(_testIsError(JStringUnmanaged, r, JStringError.RegexMatchFailed));</span>
<span class="line" id="L3814">        }</span>
<span class="line" id="L3815">        {</span>
<span class="line" id="L3816">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3817">            <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.replaceAllByRegex(arena.allocator(), <span class="tok-str">&quot;(?&lt;L&gt;l+)&quot;</span>, <span class="tok-str">&quot;L&quot;</span>);</span>
<span class="line" id="L3818">            <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;heLo,heLo,worLd&quot;</span>));</span>
<span class="line" id="L3819">        }</span>
<span class="line" id="L3820">        {</span>
<span class="line" id="L3821">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L3822">            <span class="tok-kw">const</span> r = str1.replaceAllByRegex(arena.allocator(), <span class="tok-str">&quot;he(?&lt;L&gt;l+)&quot;</span>, <span class="tok-str">&quot;&quot;</span>);</span>
<span class="line" id="L3823">            <span class="tok-kw">try</span> testing.expect(_testIsError(JStringUnmanaged, r, JStringError.RegexMatchOverlapped));</span>
<span class="line" id="L3824">        }</span>
<span class="line" id="L3825">        {</span>
<span class="line" id="L3826">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3827">            <span class="tok-kw">const</span> r = str1.replaceAllByRegex(arena.allocator(), <span class="tok-str">&quot;&quot;</span>, <span class="tok-str">&quot;L&quot;</span>);</span>
<span class="line" id="L3828">            <span class="tok-kw">try</span> testing.expect(_testIsError(JStringUnmanaged, r, JStringError.RegexBadPattern));</span>
<span class="line" id="L3829">            <span class="tok-kw">try</span> testing.expect(_testIsError(JStringUnmanaged, r, JStringError.RegexBadPattern));</span>
<span class="line" id="L3830">        }</span>
<span class="line" id="L3831">        {</span>
<span class="line" id="L3832">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3833">            <span class="tok-kw">const</span> r = str1.replaceByRegex(arena.allocator(), <span class="tok-str">&quot;helloworld&quot;</span>, <span class="tok-str">&quot;&quot;</span>);</span>
<span class="line" id="L3834">            <span class="tok-kw">try</span> testing.expect(_testIsError(JStringUnmanaged, r, JStringError.RegexMatchFailed));</span>
<span class="line" id="L3835">        }</span>
<span class="line" id="L3836">        {</span>
<span class="line" id="L3837">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3838">            <span class="tok-kw">try</span> testing.expect(_testIsError(JStringUnmanaged, str1.replaceAllByRegex(arena.allocator(), <span class="tok-str">&quot;he(?&lt;L&gt;l+&quot;</span>, <span class="tok-str">&quot;&quot;</span>), JStringError.RegexMatchFailed));</span>
<span class="line" id="L3839">        }</span>
<span class="line" id="L3840">    }</span>
<span class="line" id="L3841">}</span>
<span class="line" id="L3842"></span>
<span class="line" id="L3843"><span class="tok-kw">test</span> <span class="tok-str">&quot;freeJStringArray/freeJStringUnmanagedArray&quot;</span> {</span>
<span class="line" id="L3844">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3845">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3846">    {</span>
<span class="line" id="L3847">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello\nhello\nhello\n&quot;</span>);</span>
<span class="line" id="L3848">        <span class="tok-kw">const</span> strs = <span class="tok-kw">try</span> str1.split(arena.allocator(), <span class="tok-str">&quot;\n&quot;</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3849">        freeJStringUnmanagedArray(arena.allocator(), strs);</span>
<span class="line" id="L3850">    }</span>
<span class="line" id="L3851">    {</span>
<span class="line" id="L3852">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello\nhello\nhello\n&quot;</span>);</span>
<span class="line" id="L3853">        <span class="tok-kw">const</span> strs = <span class="tok-kw">try</span> str1.split(<span class="tok-str">&quot;\n&quot;</span>, -<span class="tok-number">1</span>);</span>
<span class="line" id="L3854">        freeJStringArray(strs);</span>
<span class="line" id="L3855">    }</span>
<span class="line" id="L3856">}</span>
<span class="line" id="L3857"></span>
<span class="line" id="L3858"><span class="tok-kw">test</span> <span class="tok-str">&quot;isWellFormed&quot;</span> {</span>
<span class="line" id="L3859">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3860">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3861">    <span class="tok-kw">const</span> str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello,&quot;</span>;</span>
<span class="line" id="L3862">    <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), str[<span class="tok-number">0</span> .. str.len - <span class="tok-number">1</span>]);</span>
<span class="line" id="L3863">    <span class="tok-kw">try</span> testing.expect(!str1.isWellFormed());</span>
<span class="line" id="L3864">    str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), str);</span>
<span class="line" id="L3865">    <span class="tok-kw">try</span> testing.expect(str1.isWellFormed());</span>
<span class="line" id="L3866">}</span>
<span class="line" id="L3867"></span>
<span class="line" id="L3868"><span class="tok-kw">test</span> <span class="tok-str">&quot;valueOf&quot;</span> {</span>
<span class="line" id="L3869">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3870">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3871">    <span class="tok-kw">const</span> str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello,&quot;</span>;</span>
<span class="line" id="L3872">    <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), str);</span>
<span class="line" id="L3873">    <span class="tok-kw">try</span> testing.expect(std.mem.eql(<span class="tok-type">u8</span>, str1.valueOf(), <span class="tok-str">&quot;hello,&quot;</span>));</span>
<span class="line" id="L3874">}</span>
<span class="line" id="L3875"></span>
<span class="line" id="L3876"><span class="tok-kw">test</span> <span class="tok-str">&quot;JString/Regex&quot;</span> {</span>
<span class="line" id="L3877">    <span class="tok-comment">// briefly test managed version, to make sure that they follow the the spec designed. Majority functions are tested in unmanaged version.</span>
</span>
<span class="line" id="L3878">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L3879">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L3880">    {</span>
<span class="line" id="L3881">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newEmpty(arena.allocator());</span>
<span class="line" id="L3882">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3883">        str1 = <span class="tok-kw">try</span> str1.repeat(<span class="tok-number">5</span>);</span>
<span class="line" id="L3884">        <span class="tok-kw">var</span> jstrings: [<span class="tok-number">1</span>]JString = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3885">        jstrings[<span class="tok-number">0</span>] = str2;</span>
<span class="line" id="L3886">        <span class="tok-kw">var</span> str3 = <span class="tok-kw">try</span> str1.concatMany(jstrings[<span class="tok-number">0</span>..<span class="tok-number">1</span>]);</span>
<span class="line" id="L3887">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3888">        str3 = <span class="tok-kw">try</span> str1.concatMany(jstrings[<span class="tok-number">0</span>..<span class="tok-number">0</span>]);</span>
<span class="line" id="L3889">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3890">        str3 = <span class="tok-kw">try</span> str1.concat(str2);</span>
<span class="line" id="L3891">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3892">        str3 = <span class="tok-kw">try</span> str2.clone();</span>
<span class="line" id="L3893">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3894">        <span class="tok-kw">try</span> testing.expect(!str3.isEmpty());</span>
<span class="line" id="L3895">        <span class="tok-kw">try</span> testing.expect(str3.eql(str2));</span>
<span class="line" id="L3896">        str3 = <span class="tok-kw">try</span> JString.newFromJString(str2);</span>
<span class="line" id="L3897">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3898">        str3 = <span class="tok-kw">try</span> JString.newFromFormat(arena.allocator(), <span class="tok-str">&quot;{s}!&quot;</span>, .{str2});</span>
<span class="line" id="L3899">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world!&quot;</span>));</span>
<span class="line" id="L3900">        str3 = <span class="tok-kw">try</span> JString.newFromTuple(arena.allocator(), .{ str2, <span class="tok-str">&quot;!&quot;</span> });</span>
<span class="line" id="L3901">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world!&quot;</span>));</span>
<span class="line" id="L3902">        str3 = <span class="tok-kw">try</span> JString.newFromNumber(arena.allocator(), <span class="tok-type">f32</span>, <span class="tok-number">13.5</span>);</span>
<span class="line" id="L3903">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;13.5&quot;</span>));</span>
<span class="line" id="L3904">        str3 = <span class="tok-kw">try</span> JString.newFromStringify(arena.allocator(), .{ .hello = <span class="tok-str">&quot;world&quot;</span> });</span>
<span class="line" id="L3905">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;{\&quot;hello\&quot;:\&quot;world\&quot;}&quot;</span>));</span>
<span class="line" id="L3906">        str3 = <span class="tok-kw">try</span> JString.newFromStringifyWithOptions(arena.allocator(), .{ .hello = <span class="tok-str">&quot;world&quot;</span> }, .{});</span>
<span class="line" id="L3907">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;{\&quot;hello\&quot;:\&quot;world\&quot;}&quot;</span>));</span>
<span class="line" id="L3908">        <span class="tok-kw">var</span> tmp_dir = std.testing.tmpDir(.{});</span>
<span class="line" id="L3909">        <span class="tok-kw">defer</span> tmp_dir.cleanup();</span>
<span class="line" id="L3910">        <span class="tok-kw">var</span> tmp_file = <span class="tok-kw">try</span> tmp_dir.dir.createFile(<span class="tok-str">&quot;test.txt&quot;</span>, .{ .read = <span class="tok-null">true</span> });</span>
<span class="line" id="L3911">        <span class="tok-kw">try</span> tmp_file.writeAll(<span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3912">        <span class="tok-kw">try</span> tmp_file.seekTo(<span class="tok-number">0</span>);</span>
<span class="line" id="L3913">        <span class="tok-kw">const</span> str10 = <span class="tok-kw">try</span> JString.newFromFile(arena.allocator(), tmp_file);</span>
<span class="line" id="L3914">        <span class="tok-kw">try</span> testing.expect(str10.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3915">        <span class="tok-comment">// now file is at the end, so read again should give us 0 len slice</span>
</span>
<span class="line" id="L3916">        <span class="tok-kw">const</span> str11 = <span class="tok-kw">try</span> JString.newFromFile(arena.allocator(), tmp_file);</span>
<span class="line" id="L3917">        <span class="tok-kw">try</span> testing.expect(str11.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L3918">    }</span>
<span class="line" id="L3919">    {</span>
<span class="line" id="L3920">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot; zig  \t c\t&quot;</span>);</span>
<span class="line" id="L3921">        <span class="tok-kw">var</span> wyhash = std.hash.Wyhash.init(<span class="tok-number">0</span>);</span>
<span class="line" id="L3922">        wyhash.update(<span class="tok-str">&quot; zig  \t c\t&quot;</span>);</span>
<span class="line" id="L3923">        <span class="tok-kw">const</span> h = wyhash.final();</span>
<span class="line" id="L3924">        <span class="tok-kw">try</span> testing.expectEqual(str1.hash(), h);</span>
<span class="line" id="L3925">        <span class="tok-kw">try</span> testing.expectEqual(str1.len(), <span class="tok-number">23</span>);</span>
<span class="line" id="L3926">        <span class="tok-kw">try</span> testing.expectEqual(str1.utf8Len(), <span class="tok-number">14</span>);</span>
<span class="line" id="L3927">    }</span>
<span class="line" id="L3928">    {</span>
<span class="line" id="L3929">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;ab&quot;</span>);</span>
<span class="line" id="L3930">        <span class="tok-kw">var</span> it2 = str2.iterator();</span>
<span class="line" id="L3931">        <span class="tok-kw">try</span> testing.expectEqual(it2.next(), <span class="tok-str">'a'</span>);</span>
<span class="line" id="L3932">        <span class="tok-kw">var</span> it3 = str2.reverseIterator();</span>
<span class="line" id="L3933">        <span class="tok-kw">try</span> testing.expectEqual(it3.next(), <span class="tok-str">'b'</span>);</span>
<span class="line" id="L3934">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;zigc&quot;</span>);</span>
<span class="line" id="L3935">        <span class="tok-kw">var</span> it1 = <span class="tok-kw">try</span> str1.utf8Iterator();</span>
<span class="line" id="L3936">        <span class="tok-kw">try</span> testing.expectEqual(it1.nextCodepoint(), <span class="tok-str">'z'</span>);</span>
<span class="line" id="L3937">    }</span>
<span class="line" id="L3938">    {</span>
<span class="line" id="L3939">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3940">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.padStart(<span class="tok-number">12</span>, <span class="tok-str">&quot;welcome&quot;</span>);</span>
<span class="line" id="L3941">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;welcomehello&quot;</span>));</span>
<span class="line" id="L3942">        str2 = <span class="tok-kw">try</span> str1.padStartJString(<span class="tok-number">12</span>, &amp;str1);</span>
<span class="line" id="L3943">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;lohellohello&quot;</span>));</span>
<span class="line" id="L3944">        str2 = <span class="tok-kw">try</span> str1.padEnd(<span class="tok-number">10</span>, <span class="tok-str">&quot;world&quot;</span>);</span>
<span class="line" id="L3945">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;helloworld&quot;</span>));</span>
<span class="line" id="L3946">        str2 = <span class="tok-kw">try</span> str1.padEndJString(<span class="tok-number">12</span>, &amp;str1);</span>
<span class="line" id="L3947">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hellohellohe&quot;</span>));</span>
<span class="line" id="L3948">    }</span>
<span class="line" id="L3949">    {</span>
<span class="line" id="L3950">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;abcdefg&quot;</span>);</span>
<span class="line" id="L3951">        <span class="tok-kw">try</span> testing.expectEqual(str2.charAt(<span class="tok-number">2</span>), <span class="tok-str">'c'</span>);</span>
<span class="line" id="L3952">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;zigc&quot;</span>);</span>
<span class="line" id="L3953">        <span class="tok-kw">try</span> testing.expectEqual(str1.at(-<span class="tok-number">1</span>), <span class="tok-str">''</span>);</span>
<span class="line" id="L3954">    }</span>
<span class="line" id="L3955">    {</span>
<span class="line" id="L3956">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot; zig  \t c\t&quot;</span>);</span>
<span class="line" id="L3957">        <span class="tok-kw">var</span> strings1 = <span class="tok-kw">try</span> str1.explode(-<span class="tok-number">1</span>);</span>
<span class="line" id="L3958">        <span class="tok-kw">try</span> testing.expectEqual(strings1.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L3959">        strings1 = <span class="tok-kw">try</span> str1.splitByWhiteSpace(-<span class="tok-number">1</span>);</span>
<span class="line" id="L3960">        <span class="tok-kw">try</span> testing.expectEqual(strings1.len, <span class="tok-number">4</span>);</span>
<span class="line" id="L3961">    }</span>
<span class="line" id="L3962">    {</span>
<span class="line" id="L3963">        <span class="tok-kw">const</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3964">        <span class="tok-kw">var</span> str_array_buf: [<span class="tok-number">256</span>]JString = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3965">        str_array_buf[<span class="tok-number">0</span>] = str1;</span>
<span class="line" id="L3966">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.concatMany(str_array_buf[<span class="tok-number">0</span>..<span class="tok-number">1</span>]);</span>
<span class="line" id="L3967">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span> ** <span class="tok-number">2</span>));</span>
<span class="line" id="L3968">        <span class="tok-kw">var</span> str5 = <span class="tok-kw">try</span> str1.concatFormat(<span class="tok-str">&quot;{s}&quot;</span>, .{<span class="tok-str">&quot; jstring&quot;</span>});</span>
<span class="line" id="L3969">        <span class="tok-kw">try</span> testing.expect(str5.eqlSlice(<span class="tok-str">&quot;hello,world jstring&quot;</span>));</span>
<span class="line" id="L3970">        str5 = <span class="tok-kw">try</span> str1.concatFormat(<span class="tok-str">&quot;{s}&quot;</span>, .{});</span>
<span class="line" id="L3971">        <span class="tok-kw">try</span> testing.expect(str5.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L3972">        <span class="tok-kw">const</span> optional_6: ?<span class="tok-type">i32</span> = <span class="tok-number">6</span>;</span>
<span class="line" id="L3973">        <span class="tok-kw">const</span> error1 = _testCreateErrorUnion(<span class="tok-null">false</span>, <span class="tok-type">i32</span>, <span class="tok-number">0</span>, <span class="tok-kw">error</span>.OutOfMemory);</span>
<span class="line" id="L3974">        <span class="tok-kw">const</span> str6 = <span class="tok-kw">try</span> str1.concatTuple(.{</span>
<span class="line" id="L3975">            <span class="tok-str">&quot; jstring&quot;</span>,</span>
<span class="line" id="L3976">            <span class="tok-number">5</span>,</span>
<span class="line" id="L3977">            optional_6,</span>
<span class="line" id="L3978">            error1,</span>
<span class="line" id="L3979">        });</span>
<span class="line" id="L3980">        <span class="tok-kw">try</span> testing.expect(str6.eqlSlice(<span class="tok-str">&quot;hello,world jstring56error.OutOfMemory&quot;</span>));</span>
<span class="line" id="L3981">        <span class="tok-kw">var</span> some_slices: [<span class="tok-number">1</span>][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L3982">        some_slices[<span class="tok-number">0</span>] = <span class="tok-str">&quot;hello&quot;</span>;</span>
<span class="line" id="L3983">        <span class="tok-kw">const</span> str9 = <span class="tok-kw">try</span> str1.concatManySlices(&amp;some_slices);</span>
<span class="line" id="L3984">        <span class="tok-kw">try</span> testing.expect(str9.eqlSlice(<span class="tok-str">&quot;hello,worldhello&quot;</span>));</span>
<span class="line" id="L3985">        <span class="tok-kw">const</span> str8 = <span class="tok-kw">try</span> str1.concatSlice(<span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3986">        <span class="tok-kw">try</span> testing.expect(str8.eqlSlice(<span class="tok-str">&quot;hello,worldhello&quot;</span>));</span>
<span class="line" id="L3987">    }</span>
<span class="line" id="L3988">    {</span>
<span class="line" id="L3989">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L3990">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L3991">        <span class="tok-kw">try</span> testing.expect(str1.startsWith(str2));</span>
<span class="line" id="L3992">        <span class="tok-kw">try</span> testing.expect(!str1.endsWith(str2));</span>
<span class="line" id="L3993">        <span class="tok-kw">try</span> testing.expect(str1.endsWithSlice(<span class="tok-str">&quot;world&quot;</span>));</span>
<span class="line" id="L3994">        str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,worldhello,world&quot;</span>);</span>
<span class="line" id="L3995">        <span class="tok-kw">try</span> testing.expectEqual(str1.indexOf(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L3996">        <span class="tok-kw">try</span> testing.expectEqual(str1.lastIndexOf(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">11</span>);</span>
<span class="line" id="L3997">        <span class="tok-kw">try</span> testing.expect(!str1.includes(<span class="tok-str">&quot;nothere&quot;</span>, <span class="tok-number">0</span>));</span>
<span class="line" id="L3998">        str2 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,worldhello,world&quot;</span>);</span>
<span class="line" id="L3999">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastIndexOf(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L4000">        <span class="tok-kw">try</span> testing.expectEqual(str2.fastLastIndexOf(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">11</span>);</span>
<span class="line" id="L4001">        <span class="tok-kw">try</span> testing.expectEqual(str2.search(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">0</span>), <span class="tok-number">0</span>);</span>
<span class="line" id="L4002">    }</span>
<span class="line" id="L4003">    {</span>
<span class="line" id="L4004">        <span class="tok-kw">const</span> str: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-str">&quot;hello,&quot;</span>;</span>
<span class="line" id="L4005">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), str[<span class="tok-number">0</span> .. str.len - <span class="tok-number">1</span>]);</span>
<span class="line" id="L4006">        <span class="tok-kw">try</span> testing.expect(!str1.isWellFormed());</span>
<span class="line" id="L4007">    }</span>
<span class="line" id="L4008">    {</span>
<span class="line" id="L4009">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L4010">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.replace(<span class="tok-str">&quot;world&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L4011">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,hello,jstring&quot;</span>));</span>
<span class="line" id="L4012">        str2 = <span class="tok-kw">try</span> str1.replaceAll(<span class="tok-str">&quot;hello&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L4013">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;jstring,jstring,world&quot;</span>));</span>
<span class="line" id="L4014">    }</span>
<span class="line" id="L4015">    {</span>
<span class="line" id="L4016">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hEllO,woRld&quot;</span>);</span>
<span class="line" id="L4017">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.toUpperCase();</span>
<span class="line" id="L4018">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;HELLO,WORLD&quot;</span>));</span>
<span class="line" id="L4019">        <span class="tok-kw">const</span> str3 = <span class="tok-kw">try</span> str1.toLowerCase();</span>
<span class="line" id="L4020">        <span class="tok-kw">try</span> testing.expect(str3.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L4021">    }</span>
<span class="line" id="L4022">    {</span>
<span class="line" id="L4023">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  hello,world&quot;</span>);</span>
<span class="line" id="L4024">        <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.trimStart();</span>
<span class="line" id="L4025">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L4026">        str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world  &quot;</span>);</span>
<span class="line" id="L4027">        str2 = <span class="tok-kw">try</span> str1.trimEnd();</span>
<span class="line" id="L4028">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L4029">        str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;  hello,world  &quot;</span>);</span>
<span class="line" id="L4030">        str2 = <span class="tok-kw">try</span> str1.trim();</span>
<span class="line" id="L4031">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L4032">    }</span>
<span class="line" id="L4033">    {</span>
<span class="line" id="L4034">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,world&quot;</span>);</span>
<span class="line" id="L4035">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1.sliceWithStartOnly(<span class="tok-number">0</span>);</span>
<span class="line" id="L4036">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,world&quot;</span>));</span>
<span class="line" id="L4037">        <span class="tok-kw">const</span> str6 = <span class="tok-kw">try</span> str1.slice(<span class="tok-number">15</span>, <span class="tok-number">7</span>);</span>
<span class="line" id="L4038">        <span class="tok-kw">try</span> testing.expect(str6.eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L4039">    }</span>
<span class="line" id="L4040">    <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L4041">        {</span>
<span class="line" id="L4042">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L4043">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> str1.match(<span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, Regex.DefaultRegexOptions, Regex.DefaultMatchOptions);</span>
<span class="line" id="L4044">            <span class="tok-kw">try</span> testing.expect(re.matchSucceed());</span>
<span class="line" id="L4045">            <span class="tok-kw">var</span> it = re.getResultsIterator(str1.valueOf());</span>
<span class="line" id="L4046">            <span class="tok-kw">const</span> maybe_result = it.nextResult();</span>
<span class="line" id="L4047">            <span class="tok-kw">if</span> (maybe_result) |r| {</span>
<span class="line" id="L4048">                <span class="tok-kw">try</span> testing.expectEqual(r.start, <span class="tok-number">0</span>);</span>
<span class="line" id="L4049">                <span class="tok-kw">try</span> testing.expectEqual(r.len, <span class="tok-number">5</span>);</span>
<span class="line" id="L4050">                <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, r.value, <span class="tok-str">&quot;hello&quot;</span>);</span>
<span class="line" id="L4051">            }</span>
<span class="line" id="L4052">            str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L4053">            re = <span class="tok-kw">try</span> str1.matchAll(<span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>, Regex.DefaultRegexOptions, Regex.DefaultMatchOptions);</span>
<span class="line" id="L4054">            <span class="tok-kw">try</span> testing.expect(re.matchSucceed());</span>
<span class="line" id="L4055">        }</span>
<span class="line" id="L4056">        {</span>
<span class="line" id="L4057">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L4058">            <span class="tok-kw">var</span> str2 = <span class="tok-kw">try</span> str1.replaceByRegex(<span class="tok-str">&quot;wor.d&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L4059">            <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,hello,jstring&quot;</span>));</span>
<span class="line" id="L4060">            str2 = <span class="tok-kw">try</span> str1.replaceAllByRegex(<span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-str">&quot;jstring&quot;</span>);</span>
<span class="line" id="L4061">            <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;jstring,jstring,world&quot;</span>));</span>
<span class="line" id="L4062">        }</span>
<span class="line" id="L4063">        {</span>
<span class="line" id="L4064">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L4065">            <span class="tok-kw">const</span> r = <span class="tok-kw">try</span> str1.searchByRegex(<span class="tok-str">&quot;hel+o&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4066">            <span class="tok-kw">try</span> testing.expectEqual(r, <span class="tok-number">0</span>);</span>
<span class="line" id="L4067">        }</span>
<span class="line" id="L4068">        {</span>
<span class="line" id="L4069">            <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JString.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L4070">            <span class="tok-kw">const</span> results = <span class="tok-kw">try</span> str1.splitByRegex(<span class="tok-str">&quot;l+&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4071">            <span class="tok-kw">try</span> testing.expectEqual(results.len, <span class="tok-number">1</span>);</span>
<span class="line" id="L4072">        }</span>
<span class="line" id="L4073">        <span class="tok-comment">// Regex</span>
</span>
<span class="line" id="L4074">        {</span>
<span class="line" id="L4075">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> Regex.init(arena.allocator(), <span class="tok-str">&quot;(hello&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4076">            <span class="tok-kw">try</span> testing.expect(!re.succeed());</span>
<span class="line" id="L4077">            <span class="tok-kw">try</span> testing.expectEqual(re.errorNumber(), <span class="tok-number">114</span>);</span>
<span class="line" id="L4078">            <span class="tok-kw">try</span> testing.expectEqual(re.errorOffset(), <span class="tok-number">6</span>);</span>
<span class="line" id="L4079">            <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, re.errorMessage(), <span class="tok-str">&quot;PCRE2 compilation failed at offset 6: missing closing parenthesis\n&quot;</span>);</span>
<span class="line" id="L4080">            re.deinit();</span>
<span class="line" id="L4081">        }</span>
<span class="line" id="L4082">        {</span>
<span class="line" id="L4083">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> Regex.init(arena.allocator(), <span class="tok-str">&quot;(?&lt;h&gt;hel+o)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4084">            <span class="tok-kw">try</span> re.matchAll(<span class="tok-str">&quot;hello,hello,world&quot;</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4085">            <span class="tok-kw">const</span> matched_results = re.getResults();</span>
<span class="line" id="L4086">            <span class="tok-kw">try</span> testing.expect(matched_results != <span class="tok-null">null</span>);</span>
<span class="line" id="L4087">            <span class="tok-kw">if</span> (matched_results) |mr| {</span>
<span class="line" id="L4088">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].start == <span class="tok-number">0</span>);</span>
<span class="line" id="L4089">                <span class="tok-kw">try</span> testing.expect(mr[<span class="tok-number">0</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L4090">            }</span>
<span class="line" id="L4091">            <span class="tok-kw">const</span> matched_group_results = re.getGroupResults();</span>
<span class="line" id="L4092">            <span class="tok-kw">try</span> testing.expect(matched_group_results != <span class="tok-null">null</span>);</span>
<span class="line" id="L4093">            <span class="tok-kw">if</span> (matched_group_results) |mgr| {</span>
<span class="line" id="L4094">                <span class="tok-kw">try</span> testing.expect(mgr.len == <span class="tok-number">2</span>);</span>
<span class="line" id="L4095">                <span class="tok-kw">try</span> testing.expectEqualSlices(<span class="tok-type">u8</span>, mgr[<span class="tok-number">0</span>].name[<span class="tok-number">0</span>..mgr[<span class="tok-number">0</span>].name_len], <span class="tok-str">&quot;h&quot;</span>);</span>
<span class="line" id="L4096">                <span class="tok-kw">try</span> testing.expect(mgr[<span class="tok-number">0</span>].start == <span class="tok-number">0</span>);</span>
<span class="line" id="L4097">                <span class="tok-kw">try</span> testing.expect(mgr[<span class="tok-number">0</span>].len == <span class="tok-number">5</span>);</span>
<span class="line" id="L4098">            }</span>
<span class="line" id="L4099">        }</span>
<span class="line" id="L4100">        {</span>
<span class="line" id="L4101">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> Regex.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4102">            <span class="tok-kw">try</span> re.reset(); <span class="tok-comment">// this should works find without error</span>
</span>
<span class="line" id="L4103">        }</span>
<span class="line" id="L4104">        {</span>
<span class="line" id="L4105">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> Regex.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4106">            <span class="tok-kw">try</span> re.match(<span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4107">            <span class="tok-kw">const</span> maybe_r = re.getGroupResultByName(<span class="tok-str">&quot;h&quot;</span>);</span>
<span class="line" id="L4108">            <span class="tok-kw">try</span> testing.expect(maybe_r != <span class="tok-null">null</span>);</span>
<span class="line" id="L4109">            <span class="tok-kw">const</span> maybe_r2 = re.getGroupResultByIndex(<span class="tok-number">1</span>);</span>
<span class="line" id="L4110">            <span class="tok-kw">try</span> testing.expect(maybe_r2 != <span class="tok-null">null</span>);</span>
<span class="line" id="L4111">            <span class="tok-kw">var</span> it = re.getGroupResultsIterator(<span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>);</span>
<span class="line" id="L4112">            <span class="tok-kw">try</span> testing.expect(it.nextResult() != <span class="tok-null">null</span>);</span>
<span class="line" id="L4113">        }</span>
<span class="line" id="L4114">        {</span>
<span class="line" id="L4115">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> Regex.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4116">            <span class="tok-kw">try</span> testing.expect(_testIsError(<span class="tok-type">usize</span>, re.getNextOffset(<span class="tok-str">&quot;hello&quot;</span>), JStringError.RegexFetchBeforeMatch));</span>
<span class="line" id="L4117">            <span class="tok-kw">try</span> re.match(<span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">true</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4118">            <span class="tok-kw">try</span> testing.expectEqual(re.getNextOffset(<span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>), <span class="tok-number">8</span>);</span>
<span class="line" id="L4119">        }</span>
<span class="line" id="L4120">        {</span>
<span class="line" id="L4121">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> Regex.init(arena.allocator(), <span class="tok-str">&quot;(hi,)(?&lt;h&gt;hel+o?)&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4122">            <span class="tok-kw">try</span> re.match(<span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>, <span class="tok-number">0</span>, <span class="tok-null">false</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4123">            <span class="tok-kw">try</span> re.fetchResults();</span>
<span class="line" id="L4124">            <span class="tok-kw">try</span> testing.expectEqual(re.getNextOffset(<span class="tok-str">&quot;hi,hello,hi,hello&quot;</span>), <span class="tok-number">8</span>);</span>
<span class="line" id="L4125">        }</span>
<span class="line" id="L4126">    }</span>
<span class="line" id="L4127">}</span>
<span class="line" id="L4128"></span>
<span class="line" id="L4129"><span class="tok-kw">test</span> <span class="tok-str">&quot;forbidden city&quot;</span> {</span>
<span class="line" id="L4130">    <span class="tok-comment">// tests listed here are those necessary to better coverage but not supposed to be used if not developing this lib</span>
</span>
<span class="line" id="L4131">    <span class="tok-comment">// just remember that: in practice if you call this you will be fired (not me), or they are tested here does not</span>
</span>
<span class="line" id="L4132">    <span class="tok-comment">// mean you should use it.</span>
</span>
<span class="line" id="L4133">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(testing.allocator);</span>
<span class="line" id="L4134">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L4135">    {</span>
<span class="line" id="L4136">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello,hello,world&quot;</span>);</span>
<span class="line" id="L4137">        <span class="tok-kw">const</span> gaps = <span class="tok-kw">try</span> arena.allocator().alloc(_MatchedGapIterator.Gap, <span class="tok-number">0</span>);</span>
<span class="line" id="L4138">        <span class="tok-kw">const</span> str2 = <span class="tok-kw">try</span> str1._joinGapsWithSlice(arena.allocator(), gaps, <span class="tok-str">&quot;&quot;</span>);</span>
<span class="line" id="L4139">        <span class="tok-kw">try</span> testing.expect(str2.eqlSlice(<span class="tok-str">&quot;hello,hello,world&quot;</span>));</span>
<span class="line" id="L4140">    }</span>
<span class="line" id="L4141">    {</span>
<span class="line" id="L4142">        <span class="tok-kw">try</span> testing.expectEqual(_sliceAt(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, <span class="tok-number">1</span>), <span class="tok-str">'e'</span>);</span>
<span class="line" id="L4143">        <span class="tok-kw">try</span> testing.expectEqual(_sliceAt(<span class="tok-type">u8</span>, <span class="tok-str">&quot;hello&quot;</span>, -<span class="tok-number">1</span>), <span class="tok-str">'o'</span>);</span>
<span class="line" id="L4144">        <span class="tok-kw">try</span> testing.expect(!_testIsError(<span class="tok-type">u8</span>, <span class="tok-str">'h'</span>, JStringError.RegexMatchFailed));</span>
<span class="line" id="L4145">    }</span>
<span class="line" id="L4146">    {</span>
<span class="line" id="L4147">        <span class="tok-kw">var</span> str1 = <span class="tok-kw">try</span> JStringUnmanaged.newFromSlice(arena.allocator(), <span class="tok-str">&quot;hello world&quot;</span>);</span>
<span class="line" id="L4148">        <span class="tok-kw">const</span> strs = <span class="tok-kw">try</span> str1._splitToUtf8Chars(arena.allocator(), <span class="tok-number">999</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L4149">        <span class="tok-kw">defer</span> freeJStringUnmanagedArray(arena.allocator(), strs);</span>
<span class="line" id="L4150">        <span class="tok-kw">try</span> testing.expectEqual(strs.len, <span class="tok-number">11</span>);</span>
<span class="line" id="L4151">        <span class="tok-kw">try</span> testing.expect(strs[<span class="tok-number">5</span>].eqlSlice(<span class="tok-str">&quot;&quot;</span>));</span>
<span class="line" id="L4152">    }</span>
<span class="line" id="L4153">    <span class="tok-kw">if</span> (enable_pcre) {</span>
<span class="line" id="L4154">        {</span>
<span class="line" id="L4155">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;pattern&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4156">            <span class="tok-kw">var</span> it = re.getResultsIterator(<span class="tok-str">&quot;something&quot;</span>);</span>
<span class="line" id="L4157">            _ = &amp;it;</span>
<span class="line" id="L4158">            <span class="tok-kw">try</span> testing.expectEqual(it.nextResult(), <span class="tok-null">null</span>);</span>
<span class="line" id="L4159">        }</span>
<span class="line" id="L4160">        {</span>
<span class="line" id="L4161">            <span class="tok-kw">var</span> re = <span class="tok-kw">try</span> RegexUnmanaged.init(arena.allocator(), <span class="tok-str">&quot;pattern&quot;</span>, <span class="tok-number">0</span>);</span>
<span class="line" id="L4162">            _ = &amp;re;</span>
<span class="line" id="L4163">            pcre.fetch_match_results(re.context_); <span class="tok-comment">// no panic means passed</span>
</span>
<span class="line" id="L4164">            <span class="tok-kw">const</span> str = <span class="tok-str">&quot;hello&quot;</span>;</span>
<span class="line" id="L4165">            pcre.get_next_offset(re.context_, str[<span class="tok-number">0</span>..].ptr, str.len);</span>
<span class="line" id="L4166">        }</span>
<span class="line" id="L4167">        {</span>
<span class="line" id="L4168">            <span class="tok-kw">var</span> context_ = <span class="tok-kw">try</span> arena.allocator().create(pcre.RegexContext);</span>
<span class="line" id="L4169">            context_.re = std.mem.zeroes(?*<span class="tok-type">anyopaque</span>);</span>
<span class="line" id="L4170">            <span class="tok-kw">var</span> re = RegexUnmanaged{ .context_ = context_ };</span>
<span class="line" id="L4171">            _ = &amp;re;</span>
<span class="line" id="L4172">            <span class="tok-kw">const</span> str = <span class="tok-str">&quot;hello&quot;</span>;</span>
<span class="line" id="L4173">            _ = pcre.match(re.context_, str[<span class="tok-number">0</span>..].ptr, str.len, <span class="tok-number">0</span>); <span class="tok-comment">// no panic means passed</span>
</span>
<span class="line" id="L4174">        }</span>
<span class="line" id="L4175">    }</span>
<span class="line" id="L4176">}</span>
<span class="line" id="L4177"></span>
</code></pre></body>
</html>